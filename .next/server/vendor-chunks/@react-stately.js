"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@react-stately";
exports.ids = ["vendor-chunks/@react-stately"];
exports.modules = {

/***/ "(ssr)/./node_modules/@react-stately/checkbox/dist/import.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@react-stately/checkbox/dist/import.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useCheckboxGroupState: () => (/* binding */ $587d3ad58be6d31f$export$daff6da51032a415)\n/* harmony export */ });\n/* harmony import */ var _react_stately_form__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-stately/form */ \"(ssr)/./node_modules/@react-stately/form/dist/import.mjs\");\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n\n\n/*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ /*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ function $587d3ad58be6d31f$export$daff6da51032a415(props = {}) {\n    let [selectedValues, setValue] = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.useControlledState)(props.value, props.defaultValue || [], props.onChange);\n    let isRequired = !!props.isRequired && selectedValues.length === 0;\n    let invalidValues = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(new Map());\n    let validation = (0, _react_stately_form__WEBPACK_IMPORTED_MODULE_2__.useFormValidationState)({\n        ...props,\n        value: selectedValues\n    });\n    let isInvalid = validation.displayValidation.isInvalid;\n    var _props_validationState;\n    const state = {\n        ...validation,\n        value: selectedValues,\n        setValue (value) {\n            if (props.isReadOnly || props.isDisabled) return;\n            setValue(value);\n        },\n        isDisabled: props.isDisabled || false,\n        isReadOnly: props.isReadOnly || false,\n        isSelected (value) {\n            return selectedValues.includes(value);\n        },\n        addValue (value) {\n            if (props.isReadOnly || props.isDisabled) return;\n            if (!selectedValues.includes(value)) setValue(selectedValues.concat(value));\n        },\n        removeValue (value) {\n            if (props.isReadOnly || props.isDisabled) return;\n            if (selectedValues.includes(value)) setValue(selectedValues.filter((existingValue)=>existingValue !== value));\n        },\n        toggleValue (value) {\n            if (props.isReadOnly || props.isDisabled) return;\n            if (selectedValues.includes(value)) setValue(selectedValues.filter((existingValue)=>existingValue !== value));\n            else setValue(selectedValues.concat(value));\n        },\n        setInvalid (value, v) {\n            let s = new Map(invalidValues.current);\n            if (v.isInvalid) s.set(value, v);\n            else s.delete(value);\n            invalidValues.current = s;\n            validation.updateValidation((0, _react_stately_form__WEBPACK_IMPORTED_MODULE_2__.mergeValidation)(...s.values()));\n        },\n        validationState: (_props_validationState = props.validationState) !== null && _props_validationState !== void 0 ? _props_validationState : isInvalid ? \"invalid\" : null,\n        isInvalid: isInvalid,\n        isRequired: isRequired\n    };\n    return state;\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvY2hlY2tib3gvZGlzdC9pbXBvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBdUk7QUFDbEQ7QUFDdkM7QUFFOUM7Ozs7Ozs7Ozs7Q0FVQyxHQUFHOzs7Ozs7Ozs7O0NBVUgsR0FHRCxTQUFTUSwwQ0FBMENDLFFBQVEsQ0FBQyxDQUFDO0lBQ3pELElBQUksQ0FBQ0MsZ0JBQWdCQyxTQUFTLEdBQUcsQ0FBQyxHQUFHTixvRUFBd0IsRUFBR0ksTUFBTUcsS0FBSyxFQUFFSCxNQUFNSSxZQUFZLElBQUksRUFBRSxFQUFFSixNQUFNSyxRQUFRO0lBQ3JILElBQUlDLGFBQWEsQ0FBQyxDQUFDTixNQUFNTSxVQUFVLElBQUlMLGVBQWVNLE1BQU0sS0FBSztJQUNqRSxJQUFJQyxnQkFBZ0IsQ0FBQyxHQUFHVix5Q0FBWSxFQUFHLElBQUlXO0lBQzNDLElBQUlDLGFBQWEsQ0FBQyxHQUFHbEIsdUVBQTRCLEVBQUc7UUFDaEQsR0FBR1EsS0FBSztRQUNSRyxPQUFPRjtJQUNYO0lBQ0EsSUFBSVUsWUFBWUQsV0FBV0UsaUJBQWlCLENBQUNELFNBQVM7SUFDdEQsSUFBSUU7SUFDSixNQUFNQyxRQUFRO1FBQ1YsR0FBR0osVUFBVTtRQUNiUCxPQUFPRjtRQUNQQyxVQUFVQyxLQUFLO1lBQ1gsSUFBSUgsTUFBTWUsVUFBVSxJQUFJZixNQUFNZ0IsVUFBVSxFQUFFO1lBQzFDZCxTQUFTQztRQUNiO1FBQ0FhLFlBQVloQixNQUFNZ0IsVUFBVSxJQUFJO1FBQ2hDRCxZQUFZZixNQUFNZSxVQUFVLElBQUk7UUFDaENFLFlBQVlkLEtBQUs7WUFDYixPQUFPRixlQUFlaUIsUUFBUSxDQUFDZjtRQUNuQztRQUNBZ0IsVUFBVWhCLEtBQUs7WUFDWCxJQUFJSCxNQUFNZSxVQUFVLElBQUlmLE1BQU1nQixVQUFVLEVBQUU7WUFDMUMsSUFBSSxDQUFDZixlQUFlaUIsUUFBUSxDQUFDZixRQUFRRCxTQUFTRCxlQUFlbUIsTUFBTSxDQUFDakI7UUFDeEU7UUFDQWtCLGFBQWFsQixLQUFLO1lBQ2QsSUFBSUgsTUFBTWUsVUFBVSxJQUFJZixNQUFNZ0IsVUFBVSxFQUFFO1lBQzFDLElBQUlmLGVBQWVpQixRQUFRLENBQUNmLFFBQVFELFNBQVNELGVBQWVxQixNQUFNLENBQUMsQ0FBQ0MsZ0JBQWdCQSxrQkFBa0JwQjtRQUMxRztRQUNBcUIsYUFBYXJCLEtBQUs7WUFDZCxJQUFJSCxNQUFNZSxVQUFVLElBQUlmLE1BQU1nQixVQUFVLEVBQUU7WUFDMUMsSUFBSWYsZUFBZWlCLFFBQVEsQ0FBQ2YsUUFBUUQsU0FBU0QsZUFBZXFCLE1BQU0sQ0FBQyxDQUFDQyxnQkFBZ0JBLGtCQUFrQnBCO2lCQUNqR0QsU0FBU0QsZUFBZW1CLE1BQU0sQ0FBQ2pCO1FBQ3hDO1FBQ0FzQixZQUFZdEIsS0FBSyxFQUFFdUIsQ0FBQztZQUNoQixJQUFJQyxJQUFJLElBQUlsQixJQUFJRCxjQUFjb0IsT0FBTztZQUNyQyxJQUFJRixFQUFFZixTQUFTLEVBQUVnQixFQUFFRSxHQUFHLENBQUMxQixPQUFPdUI7aUJBQ3pCQyxFQUFFRyxNQUFNLENBQUMzQjtZQUNkSyxjQUFjb0IsT0FBTyxHQUFHRDtZQUN4QmpCLFdBQVdxQixnQkFBZ0IsQ0FBQyxDQUFDLEdBQUdyQyxnRUFBcUIsS0FBTWlDLEVBQUVLLE1BQU07UUFDdkU7UUFDQUMsaUJBQWlCLENBQUNwQix5QkFBeUJiLE1BQU1pQyxlQUFlLE1BQU0sUUFBUXBCLDJCQUEyQixLQUFLLElBQUlBLHlCQUF5QkYsWUFBWSxZQUFZO1FBQ25LQSxXQUFXQTtRQUNYTCxZQUFZQTtJQUNoQjtJQUNBLE9BQU9RO0FBQ1g7QUFLNEUsQ0FDNUUsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGFuYW1vbm5leHRfdWkvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvY2hlY2tib3gvZGlzdC9pbXBvcnQubWpzP2E5YTMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHt1c2VGb3JtVmFsaWRhdGlvblN0YXRlIGFzICRiM251TyR1c2VGb3JtVmFsaWRhdGlvblN0YXRlLCBtZXJnZVZhbGlkYXRpb24gYXMgJGIzbnVPJG1lcmdlVmFsaWRhdGlvbn0gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L2Zvcm1cIjtcclxuaW1wb3J0IHt1c2VDb250cm9sbGVkU3RhdGUgYXMgJGIzbnVPJHVzZUNvbnRyb2xsZWRTdGF0ZX0gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L3V0aWxzXCI7XHJcbmltcG9ydCB7dXNlUmVmIGFzICRiM251TyR1c2VSZWZ9IGZyb20gXCJyZWFjdFwiO1xyXG5cclxuLypcclxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcclxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXHJcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxyXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi8gLypcclxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcclxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXHJcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxyXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi8gXHJcblxyXG5cclxuZnVuY3Rpb24gJDU4N2QzYWQ1OGJlNmQzMWYkZXhwb3J0JGRhZmY2ZGE1MTAzMmE0MTUocHJvcHMgPSB7fSkge1xyXG4gICAgbGV0IFtzZWxlY3RlZFZhbHVlcywgc2V0VmFsdWVdID0gKDAsICRiM251TyR1c2VDb250cm9sbGVkU3RhdGUpKHByb3BzLnZhbHVlLCBwcm9wcy5kZWZhdWx0VmFsdWUgfHwgW10sIHByb3BzLm9uQ2hhbmdlKTtcclxuICAgIGxldCBpc1JlcXVpcmVkID0gISFwcm9wcy5pc1JlcXVpcmVkICYmIHNlbGVjdGVkVmFsdWVzLmxlbmd0aCA9PT0gMDtcclxuICAgIGxldCBpbnZhbGlkVmFsdWVzID0gKDAsICRiM251TyR1c2VSZWYpKG5ldyBNYXAoKSk7XHJcbiAgICBsZXQgdmFsaWRhdGlvbiA9ICgwLCAkYjNudU8kdXNlRm9ybVZhbGlkYXRpb25TdGF0ZSkoe1xyXG4gICAgICAgIC4uLnByb3BzLFxyXG4gICAgICAgIHZhbHVlOiBzZWxlY3RlZFZhbHVlc1xyXG4gICAgfSk7XHJcbiAgICBsZXQgaXNJbnZhbGlkID0gdmFsaWRhdGlvbi5kaXNwbGF5VmFsaWRhdGlvbi5pc0ludmFsaWQ7XHJcbiAgICB2YXIgX3Byb3BzX3ZhbGlkYXRpb25TdGF0ZTtcclxuICAgIGNvbnN0IHN0YXRlID0ge1xyXG4gICAgICAgIC4uLnZhbGlkYXRpb24sXHJcbiAgICAgICAgdmFsdWU6IHNlbGVjdGVkVmFsdWVzLFxyXG4gICAgICAgIHNldFZhbHVlICh2YWx1ZSkge1xyXG4gICAgICAgICAgICBpZiAocHJvcHMuaXNSZWFkT25seSB8fCBwcm9wcy5pc0Rpc2FibGVkKSByZXR1cm47XHJcbiAgICAgICAgICAgIHNldFZhbHVlKHZhbHVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGlzRGlzYWJsZWQ6IHByb3BzLmlzRGlzYWJsZWQgfHwgZmFsc2UsXHJcbiAgICAgICAgaXNSZWFkT25seTogcHJvcHMuaXNSZWFkT25seSB8fCBmYWxzZSxcclxuICAgICAgICBpc1NlbGVjdGVkICh2YWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0ZWRWYWx1ZXMuaW5jbHVkZXModmFsdWUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWRkVmFsdWUgKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGlmIChwcm9wcy5pc1JlYWRPbmx5IHx8IHByb3BzLmlzRGlzYWJsZWQpIHJldHVybjtcclxuICAgICAgICAgICAgaWYgKCFzZWxlY3RlZFZhbHVlcy5pbmNsdWRlcyh2YWx1ZSkpIHNldFZhbHVlKHNlbGVjdGVkVmFsdWVzLmNvbmNhdCh2YWx1ZSkpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVtb3ZlVmFsdWUgKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGlmIChwcm9wcy5pc1JlYWRPbmx5IHx8IHByb3BzLmlzRGlzYWJsZWQpIHJldHVybjtcclxuICAgICAgICAgICAgaWYgKHNlbGVjdGVkVmFsdWVzLmluY2x1ZGVzKHZhbHVlKSkgc2V0VmFsdWUoc2VsZWN0ZWRWYWx1ZXMuZmlsdGVyKChleGlzdGluZ1ZhbHVlKT0+ZXhpc3RpbmdWYWx1ZSAhPT0gdmFsdWUpKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHRvZ2dsZVZhbHVlICh2YWx1ZSkge1xyXG4gICAgICAgICAgICBpZiAocHJvcHMuaXNSZWFkT25seSB8fCBwcm9wcy5pc0Rpc2FibGVkKSByZXR1cm47XHJcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZFZhbHVlcy5pbmNsdWRlcyh2YWx1ZSkpIHNldFZhbHVlKHNlbGVjdGVkVmFsdWVzLmZpbHRlcigoZXhpc3RpbmdWYWx1ZSk9PmV4aXN0aW5nVmFsdWUgIT09IHZhbHVlKSk7XHJcbiAgICAgICAgICAgIGVsc2Ugc2V0VmFsdWUoc2VsZWN0ZWRWYWx1ZXMuY29uY2F0KHZhbHVlKSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXRJbnZhbGlkICh2YWx1ZSwgdikge1xyXG4gICAgICAgICAgICBsZXQgcyA9IG5ldyBNYXAoaW52YWxpZFZhbHVlcy5jdXJyZW50KTtcclxuICAgICAgICAgICAgaWYgKHYuaXNJbnZhbGlkKSBzLnNldCh2YWx1ZSwgdik7XHJcbiAgICAgICAgICAgIGVsc2Ugcy5kZWxldGUodmFsdWUpO1xyXG4gICAgICAgICAgICBpbnZhbGlkVmFsdWVzLmN1cnJlbnQgPSBzO1xyXG4gICAgICAgICAgICB2YWxpZGF0aW9uLnVwZGF0ZVZhbGlkYXRpb24oKDAsICRiM251TyRtZXJnZVZhbGlkYXRpb24pKC4uLnMudmFsdWVzKCkpKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHZhbGlkYXRpb25TdGF0ZTogKF9wcm9wc192YWxpZGF0aW9uU3RhdGUgPSBwcm9wcy52YWxpZGF0aW9uU3RhdGUpICE9PSBudWxsICYmIF9wcm9wc192YWxpZGF0aW9uU3RhdGUgIT09IHZvaWQgMCA/IF9wcm9wc192YWxpZGF0aW9uU3RhdGUgOiBpc0ludmFsaWQgPyBcImludmFsaWRcIiA6IG51bGwsXHJcbiAgICAgICAgaXNJbnZhbGlkOiBpc0ludmFsaWQsXHJcbiAgICAgICAgaXNSZXF1aXJlZDogaXNSZXF1aXJlZFxyXG4gICAgfTtcclxuICAgIHJldHVybiBzdGF0ZTtcclxufVxyXG5cclxuXHJcblxyXG5cclxuZXhwb3J0IHskNTg3ZDNhZDU4YmU2ZDMxZiRleHBvcnQkZGFmZjZkYTUxMDMyYTQxNSBhcyB1c2VDaGVja2JveEdyb3VwU3RhdGV9O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGUuanMubWFwXHJcbiJdLCJuYW1lcyI6WyJ1c2VGb3JtVmFsaWRhdGlvblN0YXRlIiwiJGIzbnVPJHVzZUZvcm1WYWxpZGF0aW9uU3RhdGUiLCJtZXJnZVZhbGlkYXRpb24iLCIkYjNudU8kbWVyZ2VWYWxpZGF0aW9uIiwidXNlQ29udHJvbGxlZFN0YXRlIiwiJGIzbnVPJHVzZUNvbnRyb2xsZWRTdGF0ZSIsInVzZVJlZiIsIiRiM251TyR1c2VSZWYiLCIkNTg3ZDNhZDU4YmU2ZDMxZiRleHBvcnQkZGFmZjZkYTUxMDMyYTQxNSIsInByb3BzIiwic2VsZWN0ZWRWYWx1ZXMiLCJzZXRWYWx1ZSIsInZhbHVlIiwiZGVmYXVsdFZhbHVlIiwib25DaGFuZ2UiLCJpc1JlcXVpcmVkIiwibGVuZ3RoIiwiaW52YWxpZFZhbHVlcyIsIk1hcCIsInZhbGlkYXRpb24iLCJpc0ludmFsaWQiLCJkaXNwbGF5VmFsaWRhdGlvbiIsIl9wcm9wc192YWxpZGF0aW9uU3RhdGUiLCJzdGF0ZSIsImlzUmVhZE9ubHkiLCJpc0Rpc2FibGVkIiwiaXNTZWxlY3RlZCIsImluY2x1ZGVzIiwiYWRkVmFsdWUiLCJjb25jYXQiLCJyZW1vdmVWYWx1ZSIsImZpbHRlciIsImV4aXN0aW5nVmFsdWUiLCJ0b2dnbGVWYWx1ZSIsInNldEludmFsaWQiLCJ2IiwicyIsImN1cnJlbnQiLCJzZXQiLCJkZWxldGUiLCJ1cGRhdGVWYWxpZGF0aW9uIiwidmFsdWVzIiwidmFsaWRhdGlvblN0YXRlIiwidXNlQ2hlY2tib3hHcm91cFN0YXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/checkbox/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/collections/dist/import.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@react-stately/collections/dist/import.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CollectionBuilder: () => (/* binding */ $eb2240fc39a57fa5$export$bf788dd355e3a401),\n/* harmony export */   Item: () => (/* binding */ $c1d7fb2ec91bae71$export$6d08773d2e66f8f2),\n/* harmony export */   Section: () => (/* binding */ $9fc4852771d079eb$export$6e2c8f0811a474ce),\n/* harmony export */   compareNodeOrder: () => (/* binding */ $c5a24bc478652b5f$export$8c434b3a7a4dad6),\n/* harmony export */   getChildNodes: () => (/* binding */ $c5a24bc478652b5f$export$1005530eda016c13),\n/* harmony export */   getFirstItem: () => (/* binding */ $c5a24bc478652b5f$export$fbdeaa6a76694f71),\n/* harmony export */   getItemCount: () => (/* binding */ $453cc9f0df89c0a5$export$77d5aafae4e095b2),\n/* harmony export */   getLastItem: () => (/* binding */ $c5a24bc478652b5f$export$7475b2c64539e4cf),\n/* harmony export */   getNthItem: () => (/* binding */ $c5a24bc478652b5f$export$5f3398f8733f90e2),\n/* harmony export */   useCollection: () => (/* binding */ $7613b1592d41b092$export$6cd28814d92fa9c9)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n/*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ /*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ function $c1d7fb2ec91bae71$var$Item(props) {\n    return null;\n}\n$c1d7fb2ec91bae71$var$Item.getCollectionNode = function* getCollectionNode(props, context) {\n    let { childItems: childItems, title: title, children: children } = props;\n    let rendered = props.title || props.children;\n    let textValue = props.textValue || (typeof rendered === \"string\" ? rendered : \"\") || props[\"aria-label\"] || \"\";\n    // suppressTextValueWarning is used in components like Tabs, which don't have type to select support.\n    if (!textValue && !(context === null || context === void 0 ? void 0 : context.suppressTextValueWarning)) console.warn(\"<Item> with non-plain text contents is unsupported by type to select for accessibility. Please add a `textValue` prop.\");\n    yield {\n        type: \"item\",\n        props: props,\n        rendered: rendered,\n        textValue: textValue,\n        \"aria-label\": props[\"aria-label\"],\n        hasChildNodes: $c1d7fb2ec91bae71$var$hasChildItems(props),\n        *childNodes () {\n            if (childItems) for (let child of childItems)yield {\n                type: \"item\",\n                value: child\n            };\n            else if (title) {\n                let items = [];\n                (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.forEach(children, (child)=>{\n                    items.push({\n                        type: \"item\",\n                        element: child\n                    });\n                });\n                yield* items;\n            }\n        }\n    };\n};\nfunction $c1d7fb2ec91bae71$var$hasChildItems(props) {\n    if (props.hasChildItems != null) return props.hasChildItems;\n    if (props.childItems) return true;\n    if (props.title && (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.count(props.children) > 0) return true;\n    return false;\n}\n// We don't want getCollectionNode to show up in the type definition\nlet $c1d7fb2ec91bae71$export$6d08773d2e66f8f2 = $c1d7fb2ec91bae71$var$Item;\n/*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ function $9fc4852771d079eb$var$Section(props) {\n    return null;\n}\n$9fc4852771d079eb$var$Section.getCollectionNode = function* getCollectionNode(props) {\n    let { children: children, title: title, items: items } = props;\n    yield {\n        type: \"section\",\n        props: props,\n        hasChildNodes: true,\n        rendered: title,\n        \"aria-label\": props[\"aria-label\"],\n        *childNodes () {\n            if (typeof children === \"function\") {\n                if (!items) throw new Error(\"props.children was a function but props.items is missing\");\n                for (let item of items)yield {\n                    type: \"item\",\n                    value: item,\n                    renderer: children\n                };\n            } else {\n                let items = [];\n                (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.forEach(children, (child)=>{\n                    items.push({\n                        type: \"item\",\n                        element: child\n                    });\n                });\n                yield* items;\n            }\n        }\n    };\n};\n// We don't want getCollectionNode to show up in the type definition\nlet $9fc4852771d079eb$export$6e2c8f0811a474ce = $9fc4852771d079eb$var$Section;\n/*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ /*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ class $eb2240fc39a57fa5$export$bf788dd355e3a401 {\n    build(props, context) {\n        this.context = context;\n        return $eb2240fc39a57fa5$var$iterable(()=>this.iterateCollection(props));\n    }\n    *iterateCollection(props) {\n        let { children: children, items: items } = props;\n        if (typeof children === \"function\") {\n            if (!items) throw new Error(\"props.children was a function but props.items is missing\");\n            for (let item of props.items)yield* this.getFullNode({\n                value: item\n            }, {\n                renderer: children\n            });\n        } else {\n            let items = [];\n            (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.forEach(children, (child)=>{\n                items.push(child);\n            });\n            let index = 0;\n            for (let item of items){\n                let nodes = this.getFullNode({\n                    element: item,\n                    index: index\n                }, {});\n                for (let node of nodes){\n                    index++;\n                    yield node;\n                }\n            }\n        }\n    }\n    getKey(item, partialNode, state, parentKey) {\n        if (item.key != null) return item.key;\n        if (partialNode.type === \"cell\" && partialNode.key != null) return `${parentKey}${partialNode.key}`;\n        let v = partialNode.value;\n        if (v != null) {\n            var _v_key;\n            let key = (_v_key = v.key) !== null && _v_key !== void 0 ? _v_key : v.id;\n            if (key == null) throw new Error(\"No key found for item\");\n            return key;\n        }\n        return parentKey ? `${parentKey}.${partialNode.index}` : `$.${partialNode.index}`;\n    }\n    getChildState(state, partialNode) {\n        return {\n            renderer: partialNode.renderer || state.renderer\n        };\n    }\n    *getFullNode(partialNode, state, parentKey, parentNode) {\n        // If there's a value instead of an element on the node, and a parent renderer function is available,\n        // use it to render an element for the value.\n        let element = partialNode.element;\n        if (!element && partialNode.value && state && state.renderer) {\n            let cached = this.cache.get(partialNode.value);\n            if (cached && (!cached.shouldInvalidate || !cached.shouldInvalidate(this.context))) {\n                cached.index = partialNode.index;\n                cached.parentKey = parentNode ? parentNode.key : null;\n                yield cached;\n                return;\n            }\n            element = state.renderer(partialNode.value);\n        }\n        // If there's an element with a getCollectionNode function on its type, then it's a supported component.\n        // Call this function to get a partial node, and recursively build a full node from there.\n        if ((0, react__WEBPACK_IMPORTED_MODULE_0__).isValidElement(element)) {\n            let type = element.type;\n            if (typeof type !== \"function\" && typeof type.getCollectionNode !== \"function\") {\n                let name = typeof element.type === \"function\" ? element.type.name : element.type;\n                throw new Error(`Unknown element <${name}> in collection.`);\n            }\n            let childNodes = type.getCollectionNode(element.props, this.context);\n            let index = partialNode.index;\n            let result = childNodes.next();\n            while(!result.done && result.value){\n                let childNode = result.value;\n                partialNode.index = index;\n                let nodeKey = childNode.key;\n                if (!nodeKey) nodeKey = childNode.element ? null : this.getKey(element, partialNode, state, parentKey);\n                let nodes = this.getFullNode({\n                    ...childNode,\n                    key: nodeKey,\n                    index: index,\n                    wrapper: $eb2240fc39a57fa5$var$compose(partialNode.wrapper, childNode.wrapper)\n                }, this.getChildState(state, childNode), parentKey ? `${parentKey}${element.key}` : element.key, parentNode);\n                let children = [\n                    ...nodes\n                ];\n                for (let node of children){\n                    // Cache the node based on its value\n                    node.value = childNode.value || partialNode.value;\n                    if (node.value) this.cache.set(node.value, node);\n                    // The partial node may have specified a type for the child in order to specify a constraint.\n                    // Verify that the full node that was built recursively matches this type.\n                    if (partialNode.type && node.type !== partialNode.type) throw new Error(`Unsupported type <${$eb2240fc39a57fa5$var$capitalize(node.type)}> in <${$eb2240fc39a57fa5$var$capitalize(parentNode.type)}>. Only <${$eb2240fc39a57fa5$var$capitalize(partialNode.type)}> is supported.`);\n                    index++;\n                    yield node;\n                }\n                result = childNodes.next(children);\n            }\n            return;\n        }\n        // Ignore invalid elements\n        if (partialNode.key == null) return;\n        // Create full node\n        let builder = this;\n        let node = {\n            type: partialNode.type,\n            props: partialNode.props,\n            key: partialNode.key,\n            parentKey: parentNode ? parentNode.key : null,\n            value: partialNode.value,\n            level: parentNode ? parentNode.level + 1 : 0,\n            index: partialNode.index,\n            rendered: partialNode.rendered,\n            textValue: partialNode.textValue,\n            \"aria-label\": partialNode[\"aria-label\"],\n            wrapper: partialNode.wrapper,\n            shouldInvalidate: partialNode.shouldInvalidate,\n            hasChildNodes: partialNode.hasChildNodes,\n            childNodes: $eb2240fc39a57fa5$var$iterable(function*() {\n                if (!partialNode.hasChildNodes) return;\n                let index = 0;\n                for (let child of partialNode.childNodes()){\n                    // Ensure child keys are globally unique by prepending the parent node's key\n                    if (child.key != null) // Currently this line will have issues when a parent has a key `a` and a child with key `bc`\n                    // but another parent has key `ab` and its child has a key `c`. The combined keys would result in both\n                    // children having a key of `abc`.\n                    child.key = `${node.key}${child.key}`;\n                    child.index = index;\n                    let nodes = builder.getFullNode(child, builder.getChildState(state, child), node.key, node);\n                    for (let node of nodes){\n                        index++;\n                        yield node;\n                    }\n                }\n            })\n        };\n        yield node;\n    }\n    constructor(){\n        this.cache = new WeakMap();\n    }\n}\n// Wraps an iterator function as an iterable object, and caches the results.\nfunction $eb2240fc39a57fa5$var$iterable(iterator) {\n    let cache = [];\n    let iterable = null;\n    return {\n        *[Symbol.iterator] () {\n            for (let item of cache)yield item;\n            if (!iterable) iterable = iterator();\n            for (let item of iterable){\n                cache.push(item);\n                yield item;\n            }\n        }\n    };\n}\nfunction $eb2240fc39a57fa5$var$compose(outer, inner) {\n    if (outer && inner) return (element)=>outer(inner(element));\n    if (outer) return outer;\n    if (inner) return inner;\n}\nfunction $eb2240fc39a57fa5$var$capitalize(str) {\n    return str[0].toUpperCase() + str.slice(1);\n}\nfunction $7613b1592d41b092$export$6cd28814d92fa9c9(props, factory, context) {\n    let builder = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>new (0, $eb2240fc39a57fa5$export$bf788dd355e3a401)(), []);\n    let { children: children, items: items, collection: collection } = props;\n    let result = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (collection) return collection;\n        let nodes = builder.build({\n            children: children,\n            items: items\n        }, context);\n        return factory(nodes);\n    }, [\n        builder,\n        children,\n        items,\n        collection,\n        context,\n        factory\n    ]);\n    return result;\n}\n/*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ /*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ function $c5a24bc478652b5f$export$1005530eda016c13(node, collection) {\n    // New API: call collection.getChildren with the node key.\n    if (typeof collection.getChildren === \"function\") return collection.getChildren(node.key);\n    // Old API: access childNodes directly.\n    return node.childNodes;\n}\nfunction $c5a24bc478652b5f$export$fbdeaa6a76694f71(iterable) {\n    return $c5a24bc478652b5f$export$5f3398f8733f90e2(iterable, 0);\n}\nfunction $c5a24bc478652b5f$export$5f3398f8733f90e2(iterable, index) {\n    if (index < 0) return undefined;\n    let i = 0;\n    for (let item of iterable){\n        if (i === index) return item;\n        i++;\n    }\n}\nfunction $c5a24bc478652b5f$export$7475b2c64539e4cf(iterable) {\n    let lastItem = undefined;\n    for (let value of iterable)lastItem = value;\n    return lastItem;\n}\nfunction $c5a24bc478652b5f$export$8c434b3a7a4dad6(collection, a, b) {\n    // If the two nodes have the same parent, compare their indices.\n    if (a.parentKey === b.parentKey) return a.index - b.index;\n    // Otherwise, collect all of the ancestors from each node, and find the first one that doesn't match starting from the root.\n    // Include the base nodes in case we are comparing nodes of different levels so that we can compare the higher node to the lower level node's\n    // ancestor of the same level\n    let aAncestors = [\n        ...$c5a24bc478652b5f$var$getAncestors(collection, a),\n        a\n    ];\n    let bAncestors = [\n        ...$c5a24bc478652b5f$var$getAncestors(collection, b),\n        b\n    ];\n    let firstNonMatchingAncestor = aAncestors.slice(0, bAncestors.length).findIndex((a, i)=>a !== bAncestors[i]);\n    if (firstNonMatchingAncestor !== -1) {\n        // Compare the indices of two children within the common ancestor.\n        a = aAncestors[firstNonMatchingAncestor];\n        b = bAncestors[firstNonMatchingAncestor];\n        return a.index - b.index;\n    }\n    // If there isn't a non matching ancestor, we might be in a case where one of the nodes is the ancestor of the other.\n    if (aAncestors.findIndex((node)=>node === b) >= 0) return 1;\n    else if (bAncestors.findIndex((node)=>node === a) >= 0) return -1;\n    // ðŸ¤·\n    return -1;\n}\nfunction $c5a24bc478652b5f$var$getAncestors(collection, node) {\n    let parents = [];\n    while((node === null || node === void 0 ? void 0 : node.parentKey) != null){\n        node = collection.getItem(node.parentKey);\n        parents.unshift(node);\n    }\n    return parents;\n}\nconst $453cc9f0df89c0a5$var$cache = new WeakMap();\nfunction $453cc9f0df89c0a5$export$77d5aafae4e095b2(collection) {\n    let count = $453cc9f0df89c0a5$var$cache.get(collection);\n    if (count != null) return count;\n    count = 0;\n    let countItems = (items)=>{\n        for (let item of items)if (item.type === \"section\") countItems((0, $c5a24bc478652b5f$export$1005530eda016c13)(item, collection));\n        else count++;\n    };\n    countItems(collection);\n    $453cc9f0df89c0a5$var$cache.set(collection, count);\n    return count;\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvY29sbGVjdGlvbnMvZGlzdC9pbXBvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQThEO0FBRTlEOzs7Ozs7Ozs7O0NBVUMsR0FBRzs7Ozs7Ozs7OztDQVVILEdBQ0QsU0FBU0csMkJBQTJCQyxLQUFLO0lBQ3JDLE9BQU87QUFDWDtBQUNBRCwyQkFBMkJFLGlCQUFpQixHQUFHLFVBQVVBLGtCQUFrQkQsS0FBSyxFQUFFRSxPQUFPO0lBQ3JGLElBQUksRUFBRUMsWUFBWUEsVUFBVSxFQUFFQyxPQUFPQSxLQUFLLEVBQUVDLFVBQVVBLFFBQVEsRUFBRSxHQUFHTDtJQUNuRSxJQUFJTSxXQUFXTixNQUFNSSxLQUFLLElBQUlKLE1BQU1LLFFBQVE7SUFDNUMsSUFBSUUsWUFBWVAsTUFBTU8sU0FBUyxJQUFLLFFBQU9ELGFBQWEsV0FBV0EsV0FBVyxFQUFDLEtBQU1OLEtBQUssQ0FBQyxhQUFhLElBQUk7SUFDNUcscUdBQXFHO0lBQ3JHLElBQUksQ0FBQ08sYUFBYSxDQUFFTCxDQUFBQSxZQUFZLFFBQVFBLFlBQVksS0FBSyxJQUFJLEtBQUssSUFBSUEsUUFBUU0sd0JBQXdCLEdBQUdDLFFBQVFDLElBQUksQ0FBQztJQUN0SCxNQUFNO1FBQ0ZDLE1BQU07UUFDTlgsT0FBT0E7UUFDUE0sVUFBVUE7UUFDVkMsV0FBV0E7UUFDWCxjQUFjUCxLQUFLLENBQUMsYUFBYTtRQUNqQ1ksZUFBZUMsb0NBQW9DYjtRQUNuRCxDQUFDYztZQUNHLElBQUlYLFlBQVksS0FBSyxJQUFJWSxTQUFTWixXQUFXLE1BQU07Z0JBQy9DUSxNQUFNO2dCQUNOSyxPQUFPRDtZQUNYO2lCQUNLLElBQUlYLE9BQU87Z0JBQ1osSUFBSWEsUUFBUSxFQUFFO2dCQUNiLElBQUdyQixrQ0FBVyxFQUFHc0IsUUFBUSxDQUFDQyxPQUFPLENBQUNkLFVBQVUsQ0FBQ1U7b0JBQzFDRSxNQUFNRyxJQUFJLENBQUM7d0JBQ1BULE1B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d2VicGFjazovL2RhbmFtb25uZXh0X3VpLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC1zdGF0ZWx5L2NvbGxlY3Rpb25zL2Rpc3QvaW1wb3J0Lm1qcz8xZTA2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAkdHlXNkEkcmVhY3QsIHt1c2VNZW1vIGFzICR0eVc2QSR1c2VNZW1vfSBmcm9tIFwicmVhY3RcIjtcclxuXHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XHJcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXHJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xyXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcclxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovIC8qXHJcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XHJcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXHJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xyXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcclxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovIFxyXG5mdW5jdGlvbiAkYzFkN2ZiMmVjOTFiYWU3MSR2YXIkSXRlbShwcm9wcykge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuJGMxZDdmYjJlYzkxYmFlNzEkdmFyJEl0ZW0uZ2V0Q29sbGVjdGlvbk5vZGUgPSBmdW5jdGlvbiogZ2V0Q29sbGVjdGlvbk5vZGUocHJvcHMsIGNvbnRleHQpIHtcclxuICAgIGxldCB7IGNoaWxkSXRlbXM6IGNoaWxkSXRlbXMsIHRpdGxlOiB0aXRsZSwgY2hpbGRyZW46IGNoaWxkcmVuIH0gPSBwcm9wcztcclxuICAgIGxldCByZW5kZXJlZCA9IHByb3BzLnRpdGxlIHx8IHByb3BzLmNoaWxkcmVuO1xyXG4gICAgbGV0IHRleHRWYWx1ZSA9IHByb3BzLnRleHRWYWx1ZSB8fCAodHlwZW9mIHJlbmRlcmVkID09PSBcInN0cmluZ1wiID8gcmVuZGVyZWQgOiBcIlwiKSB8fCBwcm9wc1tcImFyaWEtbGFiZWxcIl0gfHwgXCJcIjtcclxuICAgIC8vIHN1cHByZXNzVGV4dFZhbHVlV2FybmluZyBpcyB1c2VkIGluIGNvbXBvbmVudHMgbGlrZSBUYWJzLCB3aGljaCBkb24ndCBoYXZlIHR5cGUgdG8gc2VsZWN0IHN1cHBvcnQuXHJcbiAgICBpZiAoIXRleHRWYWx1ZSAmJiAhKGNvbnRleHQgPT09IG51bGwgfHwgY29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29udGV4dC5zdXBwcmVzc1RleHRWYWx1ZVdhcm5pbmcpKSBjb25zb2xlLndhcm4oXCI8SXRlbT4gd2l0aCBub24tcGxhaW4gdGV4dCBjb250ZW50cyBpcyB1bnN1cHBvcnRlZCBieSB0eXBlIHRvIHNlbGVjdCBmb3IgYWNjZXNzaWJpbGl0eS4gUGxlYXNlIGFkZCBhIGB0ZXh0VmFsdWVgIHByb3AuXCIpO1xyXG4gICAgeWllbGQge1xyXG4gICAgICAgIHR5cGU6IFwiaXRlbVwiLFxyXG4gICAgICAgIHByb3BzOiBwcm9wcyxcclxuICAgICAgICByZW5kZXJlZDogcmVuZGVyZWQsXHJcbiAgICAgICAgdGV4dFZhbHVlOiB0ZXh0VmFsdWUsXHJcbiAgICAgICAgXCJhcmlhLWxhYmVsXCI6IHByb3BzW1wiYXJpYS1sYWJlbFwiXSxcclxuICAgICAgICBoYXNDaGlsZE5vZGVzOiAkYzFkN2ZiMmVjOTFiYWU3MSR2YXIkaGFzQ2hpbGRJdGVtcyhwcm9wcyksXHJcbiAgICAgICAgKmNoaWxkTm9kZXMgKCkge1xyXG4gICAgICAgICAgICBpZiAoY2hpbGRJdGVtcykgZm9yIChsZXQgY2hpbGQgb2YgY2hpbGRJdGVtcyl5aWVsZCB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcIml0ZW1cIixcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBjaGlsZFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBlbHNlIGlmICh0aXRsZSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGl0ZW1zID0gW107XHJcbiAgICAgICAgICAgICAgICAoMCwgJHR5VzZBJHJlYWN0KS5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCAoY2hpbGQpPT57XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlbXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiaXRlbVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiBjaGlsZFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB5aWVsZCogaXRlbXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59O1xyXG5mdW5jdGlvbiAkYzFkN2ZiMmVjOTFiYWU3MSR2YXIkaGFzQ2hpbGRJdGVtcyhwcm9wcykge1xyXG4gICAgaWYgKHByb3BzLmhhc0NoaWxkSXRlbXMgIT0gbnVsbCkgcmV0dXJuIHByb3BzLmhhc0NoaWxkSXRlbXM7XHJcbiAgICBpZiAocHJvcHMuY2hpbGRJdGVtcykgcmV0dXJuIHRydWU7XHJcbiAgICBpZiAocHJvcHMudGl0bGUgJiYgKDAsICR0eVc2QSRyZWFjdCkuQ2hpbGRyZW4uY291bnQocHJvcHMuY2hpbGRyZW4pID4gMCkgcmV0dXJuIHRydWU7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuLy8gV2UgZG9uJ3Qgd2FudCBnZXRDb2xsZWN0aW9uTm9kZSB0byBzaG93IHVwIGluIHRoZSB0eXBlIGRlZmluaXRpb25cclxubGV0ICRjMWQ3ZmIyZWM5MWJhZTcxJGV4cG9ydCQ2ZDA4NzczZDJlNjZmOGYyID0gJGMxZDdmYjJlYzkxYmFlNzEkdmFyJEl0ZW07XHJcblxyXG5cclxuLypcclxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcclxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXHJcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxyXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi8gXHJcbmZ1bmN0aW9uICQ5ZmM0ODUyNzcxZDA3OWViJHZhciRTZWN0aW9uKHByb3BzKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG4kOWZjNDg1Mjc3MWQwNzllYiR2YXIkU2VjdGlvbi5nZXRDb2xsZWN0aW9uTm9kZSA9IGZ1bmN0aW9uKiBnZXRDb2xsZWN0aW9uTm9kZShwcm9wcykge1xyXG4gICAgbGV0IHsgY2hpbGRyZW46IGNoaWxkcmVuLCB0aXRsZTogdGl0bGUsIGl0ZW1zOiBpdGVtcyB9ID0gcHJvcHM7XHJcbiAgICB5aWVsZCB7XHJcbiAgICAgICAgdHlwZTogXCJzZWN0aW9uXCIsXHJcbiAgICAgICAgcHJvcHM6IHByb3BzLFxyXG4gICAgICAgIGhhc0NoaWxkTm9kZXM6IHRydWUsXHJcbiAgICAgICAgcmVuZGVyZWQ6IHRpdGxlLFxyXG4gICAgICAgIFwiYXJpYS1sYWJlbFwiOiBwcm9wc1tcImFyaWEtbGFiZWxcIl0sXHJcbiAgICAgICAgKmNoaWxkTm9kZXMgKCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNoaWxkcmVuID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgIGlmICghaXRlbXMpIHRocm93IG5ldyBFcnJvcihcInByb3BzLmNoaWxkcmVuIHdhcyBhIGZ1bmN0aW9uIGJ1dCBwcm9wcy5pdGVtcyBpcyBtaXNzaW5nXCIpO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaXRlbSBvZiBpdGVtcyl5aWVsZCB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJpdGVtXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGl0ZW0sXHJcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZXI6IGNoaWxkcmVuXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbGV0IGl0ZW1zID0gW107XHJcbiAgICAgICAgICAgICAgICAoMCwgJHR5VzZBJHJlYWN0KS5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCAoY2hpbGQpPT57XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlbXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiaXRlbVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiBjaGlsZFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB5aWVsZCogaXRlbXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59O1xyXG4vLyBXZSBkb24ndCB3YW50IGdldENvbGxlY3Rpb25Ob2RlIHRvIHNob3cgdXAgaW4gdGhlIHR5cGUgZGVmaW5pdGlvblxyXG5sZXQgJDlmYzQ4NTI3NzFkMDc5ZWIkZXhwb3J0JDZlMmM4ZjA4MTFhNDc0Y2UgPSAkOWZjNDg1Mjc3MWQwNzllYiR2YXIkU2VjdGlvbjtcclxuXHJcblxyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxyXG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcclxuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXHJcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqLyAvKlxyXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxyXG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcclxuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXHJcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqLyBcclxuY2xhc3MgJGViMjI0MGZjMzlhNTdmYTUkZXhwb3J0JGJmNzg4ZGQzNTVlM2E0MDEge1xyXG4gICAgYnVpbGQocHJvcHMsIGNvbnRleHQpIHtcclxuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xyXG4gICAgICAgIHJldHVybiAkZWIyMjQwZmMzOWE1N2ZhNSR2YXIkaXRlcmFibGUoKCk9PnRoaXMuaXRlcmF0ZUNvbGxlY3Rpb24ocHJvcHMpKTtcclxuICAgIH1cclxuICAgICppdGVyYXRlQ29sbGVjdGlvbihwcm9wcykge1xyXG4gICAgICAgIGxldCB7IGNoaWxkcmVuOiBjaGlsZHJlbiwgaXRlbXM6IGl0ZW1zIH0gPSBwcm9wcztcclxuICAgICAgICBpZiAodHlwZW9mIGNoaWxkcmVuID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgaWYgKCFpdGVtcykgdGhyb3cgbmV3IEVycm9yKFwicHJvcHMuY2hpbGRyZW4gd2FzIGEgZnVuY3Rpb24gYnV0IHByb3BzLml0ZW1zIGlzIG1pc3NpbmdcIik7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGl0ZW0gb2YgcHJvcHMuaXRlbXMpeWllbGQqIHRoaXMuZ2V0RnVsbE5vZGUoe1xyXG4gICAgICAgICAgICAgICAgdmFsdWU6IGl0ZW1cclxuICAgICAgICAgICAgfSwge1xyXG4gICAgICAgICAgICAgICAgcmVuZGVyZXI6IGNoaWxkcmVuXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGxldCBpdGVtcyA9IFtdO1xyXG4gICAgICAgICAgICAoMCwgJHR5VzZBJHJlYWN0KS5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCAoY2hpbGQpPT57XHJcbiAgICAgICAgICAgICAgICBpdGVtcy5wdXNoKGNoaWxkKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGxldCBpbmRleCA9IDA7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGl0ZW0gb2YgaXRlbXMpe1xyXG4gICAgICAgICAgICAgICAgbGV0IG5vZGVzID0gdGhpcy5nZXRGdWxsTm9kZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogaXRlbSxcclxuICAgICAgICAgICAgICAgICAgICBpbmRleDogaW5kZXhcclxuICAgICAgICAgICAgICAgIH0sIHt9KTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IG5vZGUgb2Ygbm9kZXMpe1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgbm9kZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldEtleShpdGVtLCBwYXJ0aWFsTm9kZSwgc3RhdGUsIHBhcmVudEtleSkge1xyXG4gICAgICAgIGlmIChpdGVtLmtleSAhPSBudWxsKSByZXR1cm4gaXRlbS5rZXk7XHJcbiAgICAgICAgaWYgKHBhcnRpYWxOb2RlLnR5cGUgPT09IFwiY2VsbFwiICYmIHBhcnRpYWxOb2RlLmtleSAhPSBudWxsKSByZXR1cm4gYCR7cGFyZW50S2V5fSR7cGFydGlhbE5vZGUua2V5fWA7XHJcbiAgICAgICAgbGV0IHYgPSBwYXJ0aWFsTm9kZS52YWx1ZTtcclxuICAgICAgICBpZiAodiAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHZhciBfdl9rZXk7XHJcbiAgICAgICAgICAgIGxldCBrZXkgPSAoX3Zfa2V5ID0gdi5rZXkpICE9PSBudWxsICYmIF92X2tleSAhPT0gdm9pZCAwID8gX3Zfa2V5IDogdi5pZDtcclxuICAgICAgICAgICAgaWYgKGtleSA9PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBrZXkgZm91bmQgZm9yIGl0ZW1cIik7XHJcbiAgICAgICAgICAgIHJldHVybiBrZXk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwYXJlbnRLZXkgPyBgJHtwYXJlbnRLZXl9LiR7cGFydGlhbE5vZGUuaW5kZXh9YCA6IGAkLiR7cGFydGlhbE5vZGUuaW5kZXh9YDtcclxuICAgIH1cclxuICAgIGdldENoaWxkU3RhdGUoc3RhdGUsIHBhcnRpYWxOb2RlKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcmVuZGVyZXI6IHBhcnRpYWxOb2RlLnJlbmRlcmVyIHx8IHN0YXRlLnJlbmRlcmVyXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgICpnZXRGdWxsTm9kZShwYXJ0aWFsTm9kZSwgc3RhdGUsIHBhcmVudEtleSwgcGFyZW50Tm9kZSkge1xyXG4gICAgICAgIC8vIElmIHRoZXJlJ3MgYSB2YWx1ZSBpbnN0ZWFkIG9mIGFuIGVsZW1lbnQgb24gdGhlIG5vZGUsIGFuZCBhIHBhcmVudCByZW5kZXJlciBmdW5jdGlvbiBpcyBhdmFpbGFibGUsXHJcbiAgICAgICAgLy8gdXNlIGl0IHRvIHJlbmRlciBhbiBlbGVtZW50IGZvciB0aGUgdmFsdWUuXHJcbiAgICAgICAgbGV0IGVsZW1lbnQgPSBwYXJ0aWFsTm9kZS5lbGVtZW50O1xyXG4gICAgICAgIGlmICghZWxlbWVudCAmJiBwYXJ0aWFsTm9kZS52YWx1ZSAmJiBzdGF0ZSAmJiBzdGF0ZS5yZW5kZXJlcikge1xyXG4gICAgICAgICAgICBsZXQgY2FjaGVkID0gdGhpcy5jYWNoZS5nZXQocGFydGlhbE5vZGUudmFsdWUpO1xyXG4gICAgICAgICAgICBpZiAoY2FjaGVkICYmICghY2FjaGVkLnNob3VsZEludmFsaWRhdGUgfHwgIWNhY2hlZC5zaG91bGRJbnZhbGlkYXRlKHRoaXMuY29udGV4dCkpKSB7XHJcbiAgICAgICAgICAgICAgICBjYWNoZWQuaW5kZXggPSBwYXJ0aWFsTm9kZS5pbmRleDtcclxuICAgICAgICAgICAgICAgIGNhY2hlZC5wYXJlbnRLZXkgPSBwYXJlbnROb2RlID8gcGFyZW50Tm9kZS5rZXkgOiBudWxsO1xyXG4gICAgICAgICAgICAgICAgeWllbGQgY2FjaGVkO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsZW1lbnQgPSBzdGF0ZS5yZW5kZXJlcihwYXJ0aWFsTm9kZS52YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIHRoZXJlJ3MgYW4gZWxlbWVudCB3aXRoIGEgZ2V0Q29sbGVjdGlvbk5vZGUgZnVuY3Rpb24gb24gaXRzIHR5cGUsIHRoZW4gaXQncyBhIHN1cHBvcnRlZCBjb21wb25lbnQuXHJcbiAgICAgICAgLy8gQ2FsbCB0aGlzIGZ1bmN0aW9uIHRvIGdldCBhIHBhcnRpYWwgbm9kZSwgYW5kIHJlY3Vyc2l2ZWx5IGJ1aWxkIGEgZnVsbCBub2RlIGZyb20gdGhlcmUuXHJcbiAgICAgICAgaWYgKCgwLCAkdHlXNkEkcmVhY3QpLmlzVmFsaWRFbGVtZW50KGVsZW1lbnQpKSB7XHJcbiAgICAgICAgICAgIGxldCB0eXBlID0gZWxlbWVudC50eXBlO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHR5cGUgIT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgdHlwZS5nZXRDb2xsZWN0aW9uTm9kZSAhPT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgbmFtZSA9IHR5cGVvZiBlbGVtZW50LnR5cGUgPT09IFwiZnVuY3Rpb25cIiA/IGVsZW1lbnQudHlwZS5uYW1lIDogZWxlbWVudC50eXBlO1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGVsZW1lbnQgPCR7bmFtZX0+IGluIGNvbGxlY3Rpb24uYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IGNoaWxkTm9kZXMgPSB0eXBlLmdldENvbGxlY3Rpb25Ob2RlKGVsZW1lbnQucHJvcHMsIHRoaXMuY29udGV4dCk7XHJcbiAgICAgICAgICAgIGxldCBpbmRleCA9IHBhcnRpYWxOb2RlLmluZGV4O1xyXG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gY2hpbGROb2Rlcy5uZXh0KCk7XHJcbiAgICAgICAgICAgIHdoaWxlKCFyZXN1bHQuZG9uZSAmJiByZXN1bHQudmFsdWUpe1xyXG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkTm9kZSA9IHJlc3VsdC52YWx1ZTtcclxuICAgICAgICAgICAgICAgIHBhcnRpYWxOb2RlLmluZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgICAgICAgICBsZXQgbm9kZUtleSA9IGNoaWxkTm9kZS5rZXk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGVLZXkpIG5vZGVLZXkgPSBjaGlsZE5vZGUuZWxlbWVudCA/IG51bGwgOiB0aGlzLmdldEtleShlbGVtZW50LCBwYXJ0aWFsTm9kZSwgc3RhdGUsIHBhcmVudEtleSk7XHJcbiAgICAgICAgICAgICAgICBsZXQgbm9kZXMgPSB0aGlzLmdldEZ1bGxOb2RlKHtcclxuICAgICAgICAgICAgICAgICAgICAuLi5jaGlsZE5vZGUsXHJcbiAgICAgICAgICAgICAgICAgICAga2V5OiBub2RlS2V5LFxyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCxcclxuICAgICAgICAgICAgICAgICAgICB3cmFwcGVyOiAkZWIyMjQwZmMzOWE1N2ZhNSR2YXIkY29tcG9zZShwYXJ0aWFsTm9kZS53cmFwcGVyLCBjaGlsZE5vZGUud3JhcHBlcilcclxuICAgICAgICAgICAgICAgIH0sIHRoaXMuZ2V0Q2hpbGRTdGF0ZShzdGF0ZSwgY2hpbGROb2RlKSwgcGFyZW50S2V5ID8gYCR7cGFyZW50S2V5fSR7ZWxlbWVudC5rZXl9YCA6IGVsZW1lbnQua2V5LCBwYXJlbnROb2RlKTtcclxuICAgICAgICAgICAgICAgIGxldCBjaGlsZHJlbiA9IFtcclxuICAgICAgICAgICAgICAgICAgICAuLi5ub2Rlc1xyXG4gICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IG5vZGUgb2YgY2hpbGRyZW4pe1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIENhY2hlIHRoZSBub2RlIGJhc2VkIG9uIGl0cyB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUudmFsdWUgPSBjaGlsZE5vZGUudmFsdWUgfHwgcGFydGlhbE5vZGUudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUudmFsdWUpIHRoaXMuY2FjaGUuc2V0KG5vZGUudmFsdWUsIG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBwYXJ0aWFsIG5vZGUgbWF5IGhhdmUgc3BlY2lmaWVkIGEgdHlwZSBmb3IgdGhlIGNoaWxkIGluIG9yZGVyIHRvIHNwZWNpZnkgYSBjb25zdHJhaW50LlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFZlcmlmeSB0aGF0IHRoZSBmdWxsIG5vZGUgdGhhdCB3YXMgYnVpbHQgcmVjdXJzaXZlbHkgbWF0Y2hlcyB0aGlzIHR5cGUuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnRpYWxOb2RlLnR5cGUgJiYgbm9kZS50eXBlICE9PSBwYXJ0aWFsTm9kZS50eXBlKSB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHR5cGUgPCR7JGViMjI0MGZjMzlhNTdmYTUkdmFyJGNhcGl0YWxpemUobm9kZS50eXBlKX0+IGluIDwkeyRlYjIyNDBmYzM5YTU3ZmE1JHZhciRjYXBpdGFsaXplKHBhcmVudE5vZGUudHlwZSl9Pi4gT25seSA8JHskZWIyMjQwZmMzOWE1N2ZhNSR2YXIkY2FwaXRhbGl6ZShwYXJ0aWFsTm9kZS50eXBlKX0+IGlzIHN1cHBvcnRlZC5gKTtcclxuICAgICAgICAgICAgICAgICAgICBpbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIG5vZGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBjaGlsZE5vZGVzLm5leHQoY2hpbGRyZW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSWdub3JlIGludmFsaWQgZWxlbWVudHNcclxuICAgICAgICBpZiAocGFydGlhbE5vZGUua2V5ID09IG51bGwpIHJldHVybjtcclxuICAgICAgICAvLyBDcmVhdGUgZnVsbCBub2RlXHJcbiAgICAgICAgbGV0IGJ1aWxkZXIgPSB0aGlzO1xyXG4gICAgICAgIGxldCBub2RlID0ge1xyXG4gICAgICAgICAgICB0eXBlOiBwYXJ0aWFsTm9kZS50eXBlLFxyXG4gICAgICAgICAgICBwcm9wczogcGFydGlhbE5vZGUucHJvcHMsXHJcbiAgICAgICAgICAgIGtleTogcGFydGlhbE5vZGUua2V5LFxyXG4gICAgICAgICAgICBwYXJlbnRLZXk6IHBhcmVudE5vZGUgPyBwYXJlbnROb2RlLmtleSA6IG51bGwsXHJcbiAgICAgICAgICAgIHZhbHVlOiBwYXJ0aWFsTm9kZS52YWx1ZSxcclxuICAgICAgICAgICAgbGV2ZWw6IHBhcmVudE5vZGUgPyBwYXJlbnROb2RlLmxldmVsICsgMSA6IDAsXHJcbiAgICAgICAgICAgIGluZGV4OiBwYXJ0aWFsTm9kZS5pbmRleCxcclxuICAgICAgICAgICAgcmVuZGVyZWQ6IHBhcnRpYWxOb2RlLnJlbmRlcmVkLFxyXG4gICAgICAgICAgICB0ZXh0VmFsdWU6IHBhcnRpYWxOb2RlLnRleHRWYWx1ZSxcclxuICAgICAgICAgICAgXCJhcmlhLWxhYmVsXCI6IHBhcnRpYWxOb2RlW1wiYXJpYS1sYWJlbFwiXSxcclxuICAgICAgICAgICAgd3JhcHBlcjogcGFydGlhbE5vZGUud3JhcHBlcixcclxuICAgICAgICAgICAgc2hvdWxkSW52YWxpZGF0ZTogcGFydGlhbE5vZGUuc2hvdWxkSW52YWxpZGF0ZSxcclxuICAgICAgICAgICAgaGFzQ2hpbGROb2RlczogcGFydGlhbE5vZGUuaGFzQ2hpbGROb2RlcyxcclxuICAgICAgICAgICAgY2hpbGROb2RlczogJGViMjI0MGZjMzlhNTdmYTUkdmFyJGl0ZXJhYmxlKGZ1bmN0aW9uKigpIHtcclxuICAgICAgICAgICAgICAgIGlmICghcGFydGlhbE5vZGUuaGFzQ2hpbGROb2RlcykgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgbGV0IGluZGV4ID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGNoaWxkIG9mIHBhcnRpYWxOb2RlLmNoaWxkTm9kZXMoKSl7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRW5zdXJlIGNoaWxkIGtleXMgYXJlIGdsb2JhbGx5IHVuaXF1ZSBieSBwcmVwZW5kaW5nIHRoZSBwYXJlbnQgbm9kZSdzIGtleVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC5rZXkgIT0gbnVsbCkgLy8gVE9ETzogUmVtb3ZlIHRoaXMgbGluZSBlbnRpcmVseSBhbmQgZW5mb3JjZSB0aGF0IHVzZXJzIGFsd2F5cyBwcm92aWRlIHVuaXF1ZSBrZXlzLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEN1cnJlbnRseSB0aGlzIGxpbmUgd2lsbCBoYXZlIGlzc3VlcyB3aGVuIGEgcGFyZW50IGhhcyBhIGtleSBgYWAgYW5kIGEgY2hpbGQgd2l0aCBrZXkgYGJjYFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1dCBhbm90aGVyIHBhcmVudCBoYXMga2V5IGBhYmAgYW5kIGl0cyBjaGlsZCBoYXMgYSBrZXkgYGNgLiBUaGUgY29tYmluZWQga2V5cyB3b3VsZCByZXN1bHQgaW4gYm90aFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNoaWxkcmVuIGhhdmluZyBhIGtleSBvZiBgYWJjYC5cclxuICAgICAgICAgICAgICAgICAgICBjaGlsZC5rZXkgPSBgJHtub2RlLmtleX0ke2NoaWxkLmtleX1gO1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmluZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5vZGVzID0gYnVpbGRlci5nZXRGdWxsTm9kZShjaGlsZCwgYnVpbGRlci5nZXRDaGlsZFN0YXRlKHN0YXRlLCBjaGlsZCksIG5vZGUua2V5LCBub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBub2RlIG9mIG5vZGVzKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgbm9kZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfTtcclxuICAgICAgICB5aWVsZCBub2RlO1xyXG4gICAgfVxyXG4gICAgY29uc3RydWN0b3IoKXtcclxuICAgICAgICB0aGlzLmNhY2hlID0gbmV3IFdlYWtNYXAoKTtcclxuICAgIH1cclxufVxyXG4vLyBXcmFwcyBhbiBpdGVyYXRvciBmdW5jdGlvbiBhcyBhbiBpdGVyYWJsZSBvYmplY3QsIGFuZCBjYWNoZXMgdGhlIHJlc3VsdHMuXHJcbmZ1bmN0aW9uICRlYjIyNDBmYzM5YTU3ZmE1JHZhciRpdGVyYWJsZShpdGVyYXRvcikge1xyXG4gICAgbGV0IGNhY2hlID0gW107XHJcbiAgICBsZXQgaXRlcmFibGUgPSBudWxsO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICAqW1N5bWJvbC5pdGVyYXRvcl0gKCkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpdGVtIG9mIGNhY2hlKXlpZWxkIGl0ZW07XHJcbiAgICAgICAgICAgIGlmICghaXRlcmFibGUpIGl0ZXJhYmxlID0gaXRlcmF0b3IoKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaXRlbSBvZiBpdGVyYWJsZSl7XHJcbiAgICAgICAgICAgICAgICBjYWNoZS5wdXNoKGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgeWllbGQgaXRlbTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gJGViMjI0MGZjMzlhNTdmYTUkdmFyJGNvbXBvc2Uob3V0ZXIsIGlubmVyKSB7XHJcbiAgICBpZiAob3V0ZXIgJiYgaW5uZXIpIHJldHVybiAoZWxlbWVudCk9Pm91dGVyKGlubmVyKGVsZW1lbnQpKTtcclxuICAgIGlmIChvdXRlcikgcmV0dXJuIG91dGVyO1xyXG4gICAgaWYgKGlubmVyKSByZXR1cm4gaW5uZXI7XHJcbn1cclxuZnVuY3Rpb24gJGViMjI0MGZjMzlhNTdmYTUkdmFyJGNhcGl0YWxpemUoc3RyKSB7XHJcbiAgICByZXR1cm4gc3RyWzBdLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XHJcbn1cclxuXHJcblxyXG5cclxuZnVuY3Rpb24gJDc2MTNiMTU5MmQ0MWIwOTIkZXhwb3J0JDZjZDI4ODE0ZDkyZmE5YzkocHJvcHMsIGZhY3RvcnksIGNvbnRleHQpIHtcclxuICAgIGxldCBidWlsZGVyID0gKDAsICR0eVc2QSR1c2VNZW1vKSgoKT0+bmV3ICgwLCAkZWIyMjQwZmMzOWE1N2ZhNSRleHBvcnQkYmY3ODhkZDM1NWUzYTQwMSkoKSwgW10pO1xyXG4gICAgbGV0IHsgY2hpbGRyZW46IGNoaWxkcmVuLCBpdGVtczogaXRlbXMsIGNvbGxlY3Rpb246IGNvbGxlY3Rpb24gfSA9IHByb3BzO1xyXG4gICAgbGV0IHJlc3VsdCA9ICgwLCAkdHlXNkEkdXNlTWVtbykoKCk9PntcclxuICAgICAgICBpZiAoY29sbGVjdGlvbikgcmV0dXJuIGNvbGxlY3Rpb247XHJcbiAgICAgICAgbGV0IG5vZGVzID0gYnVpbGRlci5idWlsZCh7XHJcbiAgICAgICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcclxuICAgICAgICAgICAgaXRlbXM6IGl0ZW1zXHJcbiAgICAgICAgfSwgY29udGV4dCk7XHJcbiAgICAgICAgcmV0dXJuIGZhY3Rvcnkobm9kZXMpO1xyXG4gICAgfSwgW1xyXG4gICAgICAgIGJ1aWxkZXIsXHJcbiAgICAgICAgY2hpbGRyZW4sXHJcbiAgICAgICAgaXRlbXMsXHJcbiAgICAgICAgY29sbGVjdGlvbixcclxuICAgICAgICBjb250ZXh0LFxyXG4gICAgICAgIGZhY3RvcnlcclxuICAgIF0pO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XHJcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXHJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xyXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcclxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovIC8qXHJcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XHJcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXHJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xyXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcclxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovIGZ1bmN0aW9uICRjNWEyNGJjNDc4NjUyYjVmJGV4cG9ydCQxMDA1NTMwZWRhMDE2YzEzKG5vZGUsIGNvbGxlY3Rpb24pIHtcclxuICAgIC8vIE5ldyBBUEk6IGNhbGwgY29sbGVjdGlvbi5nZXRDaGlsZHJlbiB3aXRoIHRoZSBub2RlIGtleS5cclxuICAgIGlmICh0eXBlb2YgY29sbGVjdGlvbi5nZXRDaGlsZHJlbiA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gY29sbGVjdGlvbi5nZXRDaGlsZHJlbihub2RlLmtleSk7XHJcbiAgICAvLyBPbGQgQVBJOiBhY2Nlc3MgY2hpbGROb2RlcyBkaXJlY3RseS5cclxuICAgIHJldHVybiBub2RlLmNoaWxkTm9kZXM7XHJcbn1cclxuZnVuY3Rpb24gJGM1YTI0YmM0Nzg2NTJiNWYkZXhwb3J0JGZiZGVhYTZhNzY2OTRmNzEoaXRlcmFibGUpIHtcclxuICAgIHJldHVybiAkYzVhMjRiYzQ3ODY1MmI1ZiRleHBvcnQkNWYzMzk4Zjg3MzNmOTBlMihpdGVyYWJsZSwgMCk7XHJcbn1cclxuZnVuY3Rpb24gJGM1YTI0YmM0Nzg2NTJiNWYkZXhwb3J0JDVmMzM5OGY4NzMzZjkwZTIoaXRlcmFibGUsIGluZGV4KSB7XHJcbiAgICBpZiAoaW5kZXggPCAwKSByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgbGV0IGkgPSAwO1xyXG4gICAgZm9yIChsZXQgaXRlbSBvZiBpdGVyYWJsZSl7XHJcbiAgICAgICAgaWYgKGkgPT09IGluZGV4KSByZXR1cm4gaXRlbTtcclxuICAgICAgICBpKys7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gJGM1YTI0YmM0Nzg2NTJiNWYkZXhwb3J0JDc0NzViMmM2NDUzOWU0Y2YoaXRlcmFibGUpIHtcclxuICAgIGxldCBsYXN0SXRlbSA9IHVuZGVmaW5lZDtcclxuICAgIGZvciAobGV0IHZhbHVlIG9mIGl0ZXJhYmxlKWxhc3RJdGVtID0gdmFsdWU7XHJcbiAgICByZXR1cm4gbGFzdEl0ZW07XHJcbn1cclxuZnVuY3Rpb24gJGM1YTI0YmM0Nzg2NTJiNWYkZXhwb3J0JDhjNDM0YjNhN2E0ZGFkNihjb2xsZWN0aW9uLCBhLCBiKSB7XHJcbiAgICAvLyBJZiB0aGUgdHdvIG5vZGVzIGhhdmUgdGhlIHNhbWUgcGFyZW50LCBjb21wYXJlIHRoZWlyIGluZGljZXMuXHJcbiAgICBpZiAoYS5wYXJlbnRLZXkgPT09IGIucGFyZW50S2V5KSByZXR1cm4gYS5pbmRleCAtIGIuaW5kZXg7XHJcbiAgICAvLyBPdGhlcndpc2UsIGNvbGxlY3QgYWxsIG9mIHRoZSBhbmNlc3RvcnMgZnJvbSBlYWNoIG5vZGUsIGFuZCBmaW5kIHRoZSBmaXJzdCBvbmUgdGhhdCBkb2Vzbid0IG1hdGNoIHN0YXJ0aW5nIGZyb20gdGhlIHJvb3QuXHJcbiAgICAvLyBJbmNsdWRlIHRoZSBiYXNlIG5vZGVzIGluIGNhc2Ugd2UgYXJlIGNvbXBhcmluZyBub2RlcyBvZiBkaWZmZXJlbnQgbGV2ZWxzIHNvIHRoYXQgd2UgY2FuIGNvbXBhcmUgdGhlIGhpZ2hlciBub2RlIHRvIHRoZSBsb3dlciBsZXZlbCBub2RlJ3NcclxuICAgIC8vIGFuY2VzdG9yIG9mIHRoZSBzYW1lIGxldmVsXHJcbiAgICBsZXQgYUFuY2VzdG9ycyA9IFtcclxuICAgICAgICAuLi4kYzVhMjRiYzQ3ODY1MmI1ZiR2YXIkZ2V0QW5jZXN0b3JzKGNvbGxlY3Rpb24sIGEpLFxyXG4gICAgICAgIGFcclxuICAgIF07XHJcbiAgICBsZXQgYkFuY2VzdG9ycyA9IFtcclxuICAgICAgICAuLi4kYzVhMjRiYzQ3ODY1MmI1ZiR2YXIkZ2V0QW5jZXN0b3JzKGNvbGxlY3Rpb24sIGIpLFxyXG4gICAgICAgIGJcclxuICAgIF07XHJcbiAgICBsZXQgZmlyc3ROb25NYXRjaGluZ0FuY2VzdG9yID0gYUFuY2VzdG9ycy5zbGljZSgwLCBiQW5jZXN0b3JzLmxlbmd0aCkuZmluZEluZGV4KChhLCBpKT0+YSAhPT0gYkFuY2VzdG9yc1tpXSk7XHJcbiAgICBpZiAoZmlyc3ROb25NYXRjaGluZ0FuY2VzdG9yICE9PSAtMSkge1xyXG4gICAgICAgIC8vIENvbXBhcmUgdGhlIGluZGljZXMgb2YgdHdvIGNoaWxkcmVuIHdpdGhpbiB0aGUgY29tbW9uIGFuY2VzdG9yLlxyXG4gICAgICAgIGEgPSBhQW5jZXN0b3JzW2ZpcnN0Tm9uTWF0Y2hpbmdBbmNlc3Rvcl07XHJcbiAgICAgICAgYiA9IGJBbmNlc3RvcnNbZmlyc3ROb25NYXRjaGluZ0FuY2VzdG9yXTtcclxuICAgICAgICByZXR1cm4gYS5pbmRleCAtIGIuaW5kZXg7XHJcbiAgICB9XHJcbiAgICAvLyBJZiB0aGVyZSBpc24ndCBhIG5vbiBtYXRjaGluZyBhbmNlc3Rvciwgd2UgbWlnaHQgYmUgaW4gYSBjYXNlIHdoZXJlIG9uZSBvZiB0aGUgbm9kZXMgaXMgdGhlIGFuY2VzdG9yIG9mIHRoZSBvdGhlci5cclxuICAgIGlmIChhQW5jZXN0b3JzLmZpbmRJbmRleCgobm9kZSk9Pm5vZGUgPT09IGIpID49IDApIHJldHVybiAxO1xyXG4gICAgZWxzZSBpZiAoYkFuY2VzdG9ycy5maW5kSW5kZXgoKG5vZGUpPT5ub2RlID09PSBhKSA+PSAwKSByZXR1cm4gLTE7XHJcbiAgICAvLyDwn6S3XHJcbiAgICByZXR1cm4gLTE7XHJcbn1cclxuZnVuY3Rpb24gJGM1YTI0YmM0Nzg2NTJiNWYkdmFyJGdldEFuY2VzdG9ycyhjb2xsZWN0aW9uLCBub2RlKSB7XHJcbiAgICBsZXQgcGFyZW50cyA9IFtdO1xyXG4gICAgd2hpbGUoKG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm9kZS5wYXJlbnRLZXkpICE9IG51bGwpe1xyXG4gICAgICAgIG5vZGUgPSBjb2xsZWN0aW9uLmdldEl0ZW0obm9kZS5wYXJlbnRLZXkpO1xyXG4gICAgICAgIHBhcmVudHMudW5zaGlmdChub2RlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBwYXJlbnRzO1xyXG59XHJcblxyXG5cclxuY29uc3QgJDQ1M2NjOWYwZGY4OWMwYTUkdmFyJGNhY2hlID0gbmV3IFdlYWtNYXAoKTtcclxuZnVuY3Rpb24gJDQ1M2NjOWYwZGY4OWMwYTUkZXhwb3J0JDc3ZDVhYWZhZTRlMDk1YjIoY29sbGVjdGlvbikge1xyXG4gICAgbGV0IGNvdW50ID0gJDQ1M2NjOWYwZGY4OWMwYTUkdmFyJGNhY2hlLmdldChjb2xsZWN0aW9uKTtcclxuICAgIGlmIChjb3VudCAhPSBudWxsKSByZXR1cm4gY291bnQ7XHJcbiAgICBjb3VudCA9IDA7XHJcbiAgICBsZXQgY291bnRJdGVtcyA9IChpdGVtcyk9PntcclxuICAgICAgICBmb3IgKGxldCBpdGVtIG9mIGl0ZW1zKWlmIChpdGVtLnR5cGUgPT09IFwic2VjdGlvblwiKSBjb3VudEl0ZW1zKCgwLCAkYzVhMjRiYzQ3ODY1MmI1ZiRleHBvcnQkMTAwNTUzMGVkYTAxNmMxMykoaXRlbSwgY29sbGVjdGlvbikpO1xyXG4gICAgICAgIGVsc2UgY291bnQrKztcclxuICAgIH07XHJcbiAgICBjb3VudEl0ZW1zKGNvbGxlY3Rpb24pO1xyXG4gICAgJDQ1M2NjOWYwZGY4OWMwYTUkdmFyJGNhY2hlLnNldChjb2xsZWN0aW9uLCBjb3VudCk7XHJcbiAgICByZXR1cm4gY291bnQ7XHJcbn1cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuZXhwb3J0IHskYzFkN2ZiMmVjOTFiYWU3MSRleHBvcnQkNmQwODc3M2QyZTY2ZjhmMiBhcyBJdGVtLCAkOWZjNDg1Mjc3MWQwNzllYiRleHBvcnQkNmUyYzhmMDgxMWE0NzRjZSBhcyBTZWN0aW9uLCAkNzYxM2IxNTkyZDQxYjA5MiRleHBvcnQkNmNkMjg4MTRkOTJmYTljOSBhcyB1c2VDb2xsZWN0aW9uLCAkNDUzY2M5ZjBkZjg5YzBhNSRleHBvcnQkNzdkNWFhZmFlNGUwOTViMiBhcyBnZXRJdGVtQ291bnQsICRjNWEyNGJjNDc4NjUyYjVmJGV4cG9ydCQxMDA1NTMwZWRhMDE2YzEzIGFzIGdldENoaWxkTm9kZXMsICRjNWEyNGJjNDc4NjUyYjVmJGV4cG9ydCRmYmRlYWE2YTc2Njk0ZjcxIGFzIGdldEZpcnN0SXRlbSwgJGM1YTI0YmM0Nzg2NTJiNWYkZXhwb3J0JDc0NzViMmM2NDUzOWU0Y2YgYXMgZ2V0TGFzdEl0ZW0sICRjNWEyNGJjNDc4NjUyYjVmJGV4cG9ydCQ1ZjMzOThmODczM2Y5MGUyIGFzIGdldE50aEl0ZW0sICRjNWEyNGJjNDc4NjUyYjVmJGV4cG9ydCQ4YzQzNGIzYTdhNGRhZDYgYXMgY29tcGFyZU5vZGVPcmRlciwgJGViMjI0MGZjMzlhNTdmYTUkZXhwb3J0JGJmNzg4ZGQzNTVlM2E0MDEgYXMgQ29sbGVjdGlvbkJ1aWxkZXJ9O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGUuanMubWFwXHJcbiJdLCJuYW1lcyI6WyIkdHlXNkEkcmVhY3QiLCJ1c2VNZW1vIiwiJHR5VzZBJHVzZU1lbW8iLCIkYzFkN2ZiMmVjOTFiYWU3MSR2YXIkSXRlbSIsInByb3BzIiwiZ2V0Q29sbGVjdGlvbk5vZGUiLCJjb250ZXh0IiwiY2hpbGRJdGVtcyIsInRpdGxlIiwiY2hpbGRyZW4iLCJyZW5kZXJlZCIsInRleHRWYWx1ZSIsInN1cHByZXNzVGV4dFZhbHVlV2FybmluZyIsImNvbnNvbGUiLCJ3YXJuIiwidHlwZSIsImhhc0NoaWxkTm9kZXMiLCIkYzFkN2ZiMmVjOTFiYWU3MSR2YXIkaGFzQ2hpbGRJdGVtcyIsImNoaWxkTm9kZXMiLCJjaGlsZCIsInZhbHVlIiwiaXRlbXMiLCJDaGlsZHJlbiIsImZvckVhY2giLCJwdXNoIiwiZWxlbWVudCIsImhhc0NoaWxkSXRlbXMiLCJjb3VudCIsIiRjMWQ3ZmIyZWM5MWJhZTcxJGV4cG9ydCQ2ZDA4NzczZDJlNjZmOGYyIiwiJDlmYzQ4NTI3NzFkMDc5ZWIkdmFyJFNlY3Rpb24iLCJFcnJvciIsIml0ZW0iLCJyZW5kZXJlciIsIiQ5ZmM0ODUyNzcxZDA3OWViJGV4cG9ydCQ2ZTJjOGYwODExYTQ3NGNlIiwiJGViMjI0MGZjMzlhNTdmYTUkZXhwb3J0JGJmNzg4ZGQzNTVlM2E0MDEiLCJidWlsZCIsIiRlYjIyNDBmYzM5YTU3ZmE1JHZhciRpdGVyYWJsZSIsIml0ZXJhdGVDb2xsZWN0aW9uIiwiZ2V0RnVsbE5vZGUiLCJpbmRleCIsIm5vZGVzIiwibm9kZSIsImdldEtleSIsInBhcnRpYWxOb2RlIiwic3RhdGUiLCJwYXJlbnRLZXkiLCJrZXkiLCJ2IiwiX3Zfa2V5IiwiaWQiLCJnZXRDaGlsZFN0YXRlIiwicGFyZW50Tm9kZSIsImNhY2hlZCIsImNhY2hlIiwiZ2V0Iiwic2hvdWxkSW52YWxpZGF0ZSIsImlzVmFsaWRFbGVtZW50IiwibmFtZSIsInJlc3VsdCIsIm5leHQiLCJkb25lIiwiY2hpbGROb2RlIiwibm9kZUtleSIsIndyYXBwZXIiLCIkZWIyMjQwZmMzOWE1N2ZhNSR2YXIkY29tcG9zZSIsInNldCIsIiRlYjIyNDBmYzM5YTU3ZmE1JHZhciRjYXBpdGFsaXplIiwiYnVpbGRlciIsImxldmVsIiwiY29uc3RydWN0b3IiLCJXZWFrTWFwIiwiaXRlcmF0b3IiLCJpdGVyYWJsZSIsIlN5bWJvbCIsIm91dGVyIiwiaW5uZXIiLCJzdHIiLCJ0b1VwcGVyQ2FzZSIsInNsaWNlIiwiJDc2MTNiMTU5MmQ0MWIwOTIkZXhwb3J0JDZjZDI4ODE0ZDkyZmE5YzkiLCJmYWN0b3J5IiwiY29sbGVjdGlvbiIsIiRjNWEyNGJjNDc4NjUyYjVmJGV4cG9ydCQxMDA1NTMwZWRhMDE2YzEzIiwiZ2V0Q2hpbGRyZW4iLCIkYzVhMjRiYzQ3ODY1MmI1ZiRleHBvcnQkZmJkZWFhNmE3NjY5NGY3MSIsIiRjNWEyNGJjNDc4NjUyYjVmJGV4cG9ydCQ1ZjMzOThmODczM2Y5MGUyIiwidW5kZWZpbmVkIiwiaSIsIiRjNWEyNGJjNDc4NjUyYjVmJGV4cG9ydCQ3NDc1YjJjNjQ1MzllNGNmIiwibGFzdEl0ZW0iLCIkYzVhMjRiYzQ3ODY1MmI1ZiRleHBvcnQkOGM0MzRiM2E3YTRkYWQ2IiwiYSIsImIiLCJhQW5jZXN0b3JzIiwiJGM1YTI0YmM0Nzg2NTJiNWYkdmFyJGdldEFuY2VzdG9ycyIsImJBbmNlc3RvcnMiLCJmaXJzdE5vbk1hdGNoaW5nQW5jZXN0b3IiLCJsZW5ndGgiLCJmaW5kSW5kZXgiLCJwYXJlbnRzIiwiZ2V0SXRlbSIsInVuc2hpZnQiLCIkNDUzY2M5ZjBkZjg5YzBhNSR2YXIkY2FjaGUiLCIkNDUzY2M5ZjBkZjg5YzBhNSRleHBvcnQkNzdkNWFhZmFlNGUwOTViMiIsImNvdW50SXRlbXMiLCJJdGVtIiwiU2VjdGlvbiIsInVzZUNvbGxlY3Rpb24iLCJnZXRJdGVtQ291bnQiLCJnZXRDaGlsZE5vZGVzIiwiZ2V0Rmlyc3RJdGVtIiwiZ2V0TGFzdEl0ZW0iLCJnZXROdGhJdGVtIiwiY29tcGFyZU5vZGVPcmRlciIsIkNvbGxlY3Rpb25CdWlsZGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/collections/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/combobox/dist/import.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@react-stately/combobox/dist/import.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useComboBoxState: () => (/* binding */ $a9e7382a7d111cb5$export$b453a3bfd4a5fa9e)\n/* harmony export */ });\n/* harmony import */ var _react_stately_form__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @react-stately/form */ \"(ssr)/./node_modules/@react-stately/form/dist/import.mjs\");\n/* harmony import */ var _react_stately_collections__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @react-stately/collections */ \"(ssr)/./node_modules/@react-stately/collections/dist/import.mjs\");\n/* harmony import */ var _react_stately_list__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/list */ \"(ssr)/./node_modules/@react-stately/list/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\");\n/* harmony import */ var _react_stately_overlays__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @react-stately/overlays */ \"(ssr)/./node_modules/@react-stately/overlays/dist/import.mjs\");\n\n\n\n\n\n\n/*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n * \r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ /*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ function $a9e7382a7d111cb5$export$b453a3bfd4a5fa9e(props) {\n    var _collection_getItem, _collection_getItem1;\n    let { defaultFilter: defaultFilter, menuTrigger: menuTrigger = \"input\", allowsEmptyCollection: allowsEmptyCollection = false, allowsCustomValue: allowsCustomValue, shouldCloseOnBlur: shouldCloseOnBlur = true } = props;\n    let [showAllItems, setShowAllItems] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    let [isFocused, setFocusedState] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    let [focusStrategy, setFocusStrategy] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    let onSelectionChange = (key)=>{\n        if (props.onSelectionChange) props.onSelectionChange(key);\n        // If key is the same, reset the inputValue and close the menu\n        // (scenario: user clicks on already selected option)\n        if (key === selectedKey) {\n            resetInputValue();\n            closeMenu();\n        }\n    };\n    var _props_items;\n    let { collection: collection, selectionManager: selectionManager, selectedKey: selectedKey, setSelectedKey: setSelectedKey, selectedItem: selectedItem, disabledKeys: disabledKeys } = (0, _react_stately_list__WEBPACK_IMPORTED_MODULE_1__.useSingleSelectListState)({\n        ...props,\n        onSelectionChange: onSelectionChange,\n        items: (_props_items = props.items) !== null && _props_items !== void 0 ? _props_items : props.defaultItems\n    });\n    var _props_defaultInputValue, _ref;\n    let [inputValue, setInputValue] = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_2__.useControlledState)(props.inputValue, (_ref = (_props_defaultInputValue = props.defaultInputValue) !== null && _props_defaultInputValue !== void 0 ? _props_defaultInputValue : (_collection_getItem = collection.getItem(selectedKey)) === null || _collection_getItem === void 0 ? void 0 : _collection_getItem.textValue) !== null && _ref !== void 0 ? _ref : \"\", props.onInputChange);\n    // Preserve original collection so we can show all items on demand\n    let originalCollection = collection;\n    let filteredCollection = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>props.items != null || !defaultFilter ? collection : $a9e7382a7d111cb5$var$filterCollection(collection, inputValue, defaultFilter), [\n        collection,\n        inputValue,\n        defaultFilter,\n        props.items\n    ]);\n    let [lastCollection, setLastCollection] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(filteredCollection);\n    // Track what action is attempting to open the menu\n    let menuOpenTrigger = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(\"focus\");\n    let onOpenChange = (open)=>{\n        if (props.onOpenChange) props.onOpenChange(open, open ? menuOpenTrigger.current : undefined);\n        selectionManager.setFocused(open);\n        if (!open) selectionManager.setFocusedKey(null);\n    };\n    let triggerState = (0, _react_stately_overlays__WEBPACK_IMPORTED_MODULE_3__.useOverlayTriggerState)({\n        ...props,\n        onOpenChange: onOpenChange,\n        isOpen: undefined,\n        defaultOpen: undefined\n    });\n    let open = (focusStrategy = null, trigger)=>{\n        let displayAllItems = trigger === \"manual\" || trigger === \"focus\" && menuTrigger === \"focus\";\n        // Prevent open operations from triggering if there is nothing to display\n        // Also prevent open operations from triggering if items are uncontrolled but defaultItems is empty, even if displayAllItems is true.\n        // This is to prevent comboboxes with empty defaultItems from opening but allow controlled items comboboxes to open even if the inital list is empty (assumption is user will provide swap the empty list with a base list via onOpenChange returning `menuTrigger` manual)\n        if (allowsEmptyCollection || filteredCollection.size > 0 || displayAllItems && originalCollection.size > 0 || props.items) {\n            if (displayAllItems && !triggerState.isOpen && props.items === undefined) setShowAllItems(true);\n            menuOpenTrigger.current = trigger;\n            setFocusStrategy(focusStrategy);\n            triggerState.open();\n        }\n    };\n    let toggle = (focusStrategy = null, trigger)=>{\n        let displayAllItems = trigger === \"manual\" || trigger === \"focus\" && menuTrigger === \"focus\";\n        // If the menu is closed and there is nothing to display, early return so toggle isn't called to prevent extraneous onOpenChange\n        if (!(allowsEmptyCollection || filteredCollection.size > 0 || displayAllItems && originalCollection.size > 0 || props.items) && !triggerState.isOpen) return;\n        if (displayAllItems && !triggerState.isOpen && props.items === undefined) setShowAllItems(true);\n        // Only update the menuOpenTrigger if menu is currently closed\n        if (!triggerState.isOpen) menuOpenTrigger.current = trigger;\n        toggleMenu(focusStrategy);\n    };\n    let updateLastCollection = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setLastCollection(showAllItems ? originalCollection : filteredCollection);\n    }, [\n        showAllItems,\n        originalCollection,\n        filteredCollection\n    ]);\n    // If menu is going to close, save the current collection so we can freeze the displayed collection when the\n    // user clicks outside the popover to close the menu. Prevents the menu contents from updating as the menu closes.\n    let toggleMenu = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((focusStrategy = null)=>{\n        if (triggerState.isOpen) updateLastCollection();\n        setFocusStrategy(focusStrategy);\n        triggerState.toggle();\n    }, [\n        triggerState,\n        updateLastCollection\n    ]);\n    let closeMenu = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (triggerState.isOpen) {\n            updateLastCollection();\n            triggerState.close();\n        }\n    }, [\n        triggerState,\n        updateLastCollection\n    ]);\n    let [lastValue, setLastValue] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(inputValue);\n    let resetInputValue = ()=>{\n        var _collection_getItem;\n        var _collection_getItem_textValue;\n        let itemText = (_collection_getItem_textValue = (_collection_getItem = collection.getItem(selectedKey)) === null || _collection_getItem === void 0 ? void 0 : _collection_getItem.textValue) !== null && _collection_getItem_textValue !== void 0 ? _collection_getItem_textValue : \"\";\n        setLastValue(itemText);\n        setInputValue(itemText);\n    };\n    var _props_selectedKey, _ref1;\n    let lastSelectedKey = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)((_ref1 = (_props_selectedKey = props.selectedKey) !== null && _props_selectedKey !== void 0 ? _props_selectedKey : props.defaultSelectedKey) !== null && _ref1 !== void 0 ? _ref1 : null);\n    var _collection_getItem_textValue;\n    let lastSelectedKeyText = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)((_collection_getItem_textValue = (_collection_getItem1 = collection.getItem(selectedKey)) === null || _collection_getItem1 === void 0 ? void 0 : _collection_getItem1.textValue) !== null && _collection_getItem_textValue !== void 0 ? _collection_getItem_textValue : \"\");\n    // intentional omit dependency array, want this to happen on every render\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        var _collection_getItem;\n        // Open and close menu automatically when the input value changes if the input is focused,\n        // and there are items in the collection or allowEmptyCollection is true.\n        if (isFocused && (filteredCollection.size > 0 || allowsEmptyCollection) && !triggerState.isOpen && inputValue !== lastValue && menuTrigger !== \"manual\") open(null, \"input\");\n        // Close the menu if the collection is empty. Don't close menu if filtered collection size is 0\n        // but we are currently showing all items via button press\n        if (!showAllItems && !allowsEmptyCollection && triggerState.isOpen && filteredCollection.size === 0) closeMenu();\n        // Close when an item is selected.\n        if (selectedKey != null && selectedKey !== lastSelectedKey.current) closeMenu();\n        // Clear focused key when input value changes and display filtered collection again.\n        if (inputValue !== lastValue) {\n            selectionManager.setFocusedKey(null);\n            setShowAllItems(false);\n            // Set selectedKey to null when the user clears the input.\n            // If controlled, this is the application developer's responsibility.\n            if (inputValue === \"\" && (props.inputValue === undefined || props.selectedKey === undefined)) setSelectedKey(null);\n        }\n        // If the selectedKey changed, update the input value.\n        // Do nothing if both inputValue and selectedKey are controlled.\n        // In this case, it's the user's responsibility to update inputValue in onSelectionChange.\n        if (selectedKey !== lastSelectedKey.current && (props.inputValue === undefined || props.selectedKey === undefined)) resetInputValue();\n        else if (lastValue !== inputValue) setLastValue(inputValue);\n        var _collection_getItem_textValue;\n        // Update the inputValue if the selected item's text changes from its last tracked value.\n        // This is to handle cases where a selectedKey is specified but the items aren't available (async loading) or the selected item's text value updates.\n        // Only reset if the user isn't currently within the field so we don't erroneously modify user input.\n        // If inputValue is controlled, it is the user's responsibility to update the inputValue when items change.\n        let selectedItemText = (_collection_getItem_textValue = (_collection_getItem = collection.getItem(selectedKey)) === null || _collection_getItem === void 0 ? void 0 : _collection_getItem.textValue) !== null && _collection_getItem_textValue !== void 0 ? _collection_getItem_textValue : \"\";\n        if (!isFocused && selectedKey != null && props.inputValue === undefined && selectedKey === lastSelectedKey.current) {\n            if (lastSelectedKeyText.current !== selectedItemText) {\n                setLastValue(selectedItemText);\n                setInputValue(selectedItemText);\n            }\n        }\n        lastSelectedKey.current = selectedKey;\n        lastSelectedKeyText.current = selectedItemText;\n    });\n    let validation = (0, _react_stately_form__WEBPACK_IMPORTED_MODULE_4__.useFormValidationState)({\n        ...props,\n        value: (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n                inputValue: inputValue,\n                selectedKey: selectedKey\n            }), [\n            inputValue,\n            selectedKey\n        ])\n    });\n    // Revert input value and close menu\n    let revert = ()=>{\n        if (allowsCustomValue && selectedKey == null) commitCustomValue();\n        else commitSelection();\n    };\n    let commitCustomValue = ()=>{\n        lastSelectedKey.current = null;\n        setSelectedKey(null);\n        closeMenu();\n    };\n    let commitSelection = ()=>{\n        // If multiple things are controlled, call onSelectionChange\n        if (props.selectedKey !== undefined && props.inputValue !== undefined) {\n            var _collection_getItem;\n            props.onSelectionChange(selectedKey);\n            var _collection_getItem_textValue;\n            // Stop menu from reopening from useEffect\n            let itemText = (_collection_getItem_textValue = (_collection_getItem = collection.getItem(selectedKey)) === null || _collection_getItem === void 0 ? void 0 : _collection_getItem.textValue) !== null && _collection_getItem_textValue !== void 0 ? _collection_getItem_textValue : \"\";\n            setLastValue(itemText);\n            closeMenu();\n        } else {\n            // If only a single aspect of combobox is controlled, reset input value and close menu for the user\n            resetInputValue();\n            closeMenu();\n        }\n    };\n    const commitValue = ()=>{\n        if (allowsCustomValue) {\n            var _collection_getItem;\n            var _collection_getItem_textValue;\n            const itemText = (_collection_getItem_textValue = (_collection_getItem = collection.getItem(selectedKey)) === null || _collection_getItem === void 0 ? void 0 : _collection_getItem.textValue) !== null && _collection_getItem_textValue !== void 0 ? _collection_getItem_textValue : \"\";\n            inputValue === itemText ? commitSelection() : commitCustomValue();\n        } else commitSelection();\n    };\n    let commit = ()=>{\n        if (triggerState.isOpen && selectionManager.focusedKey != null) {\n            // Reset inputValue and close menu here if the selected key is already the focused key. Otherwise\n            // fire onSelectionChange to allow the application to control the closing.\n            if (selectedKey === selectionManager.focusedKey) commitSelection();\n            else setSelectedKey(selectionManager.focusedKey);\n        } else commitValue();\n    };\n    let valueOnFocus = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(inputValue);\n    let setFocused = (isFocused)=>{\n        if (isFocused) {\n            valueOnFocus.current = inputValue;\n            if (menuTrigger === \"focus\") open(null, \"focus\");\n        } else {\n            if (shouldCloseOnBlur) commitValue();\n            if (inputValue !== valueOnFocus.current) validation.commitValidation();\n        }\n        setFocusedState(isFocused);\n    };\n    let displayedCollection = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (triggerState.isOpen) {\n            if (showAllItems) return originalCollection;\n            else return filteredCollection;\n        } else return lastCollection;\n    }, [\n        triggerState.isOpen,\n        originalCollection,\n        filteredCollection,\n        showAllItems,\n        lastCollection\n    ]);\n    return {\n        ...validation,\n        ...triggerState,\n        focusStrategy: focusStrategy,\n        toggle: toggle,\n        open: open,\n        close: commitValue,\n        selectionManager: selectionManager,\n        selectedKey: selectedKey,\n        setSelectedKey: setSelectedKey,\n        disabledKeys: disabledKeys,\n        isFocused: isFocused,\n        setFocused: setFocused,\n        selectedItem: selectedItem,\n        collection: displayedCollection,\n        inputValue: inputValue,\n        setInputValue: setInputValue,\n        commit: commit,\n        revert: revert\n    };\n}\nfunction $a9e7382a7d111cb5$var$filterCollection(collection, inputValue, filter) {\n    return new (0, _react_stately_list__WEBPACK_IMPORTED_MODULE_1__.ListCollection)($a9e7382a7d111cb5$var$filterNodes(collection, collection, inputValue, filter));\n}\nfunction $a9e7382a7d111cb5$var$filterNodes(collection, nodes, inputValue, filter) {\n    let filteredNode = [];\n    for (let node of nodes){\n        if (node.type === \"section\" && node.hasChildNodes) {\n            let filtered = $a9e7382a7d111cb5$var$filterNodes(collection, (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_5__.getChildNodes)(node, collection), inputValue, filter);\n            if ([\n                ...filtered\n            ].some((node)=>node.type === \"item\")) filteredNode.push({\n                ...node,\n                childNodes: filtered\n            });\n        } else if (node.type === \"item\" && filter(node.textValue, inputValue)) filteredNode.push({\n            ...node\n        });\n        else if (node.type !== \"item\") filteredNode.push({\n            ...node\n        });\n    }\n    return filteredNode;\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvY29tYm9ib3gvZGlzdC9pbXBvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBNEY7QUFDWDtBQUN3RDtBQUMrQjtBQUNuRjtBQUNXO0FBRWhHOzs7Ozs7Ozs7O0NBVUMsR0FBRzs7Ozs7Ozs7OztDQVVILEdBTUQsU0FBU3NCLDBDQUEwQ0MsS0FBSztJQUNwRCxJQUFJQyxxQkFBcUJDO0lBQ3pCLElBQUksRUFBRUMsZUFBZUEsYUFBYSxFQUFFQyxhQUFhQSxjQUFjLE9BQU8sRUFBRUMsdUJBQXVCQSx3QkFBd0IsS0FBSyxFQUFFQyxtQkFBbUJBLGlCQUFpQixFQUFFQyxtQkFBbUJBLG9CQUFvQixJQUFJLEVBQUUsR0FBR1A7SUFDcE4sSUFBSSxDQUFDUSxjQUFjQyxnQkFBZ0IsR0FBRyxDQUFDLEdBQUd2QiwyQ0FBYyxFQUFHO0lBQzNELElBQUksQ0FBQ3dCLFdBQVdDLGdCQUFnQixHQUFHLENBQUMsR0FBR3pCLDJDQUFjLEVBQUc7SUFDeEQsSUFBSSxDQUFDMEIsZUFBZUMsaUJBQWlCLEdBQUcsQ0FBQyxHQUFHM0IsMkNBQWMsRUFBRztJQUM3RCxJQUFJNEIsb0JBQW9CLENBQUNDO1FBQ3JCLElBQUlmLE1BQU1jLGlCQUFpQixFQUFFZCxNQUFNYyxpQkFBaUIsQ0FBQ0M7UUFDckQsOERBQThEO1FBQzlELHFEQUFxRDtRQUNyRCxJQUFJQSxRQUFRQyxhQUFhO1lBQ3JCQztZQUNBQztRQUNKO0lBQ0o7SUFDQSxJQUFJQztJQUNKLElBQUksRUFBRUMsWUFBWUEsVUFBVSxFQUFFQyxrQkFBa0JBLGdCQUFnQixFQUFFTCxhQUFhQSxXQUFXLEVBQUVNLGdCQUFnQkEsY0FBYyxFQUFFQyxjQUFjQSxZQUFZLEVBQUVDLGNBQWNBLFlBQVksRUFBRSxHQUFHLENBQUMsR0FBRzFDLHlFQUE4QixFQUFHO1FBQ3hOLEdBQUdrQixLQUFLO1FBQ1JjLG1CQUFtQkE7UUFDbkJXLE9BQU8sQ0FBQ04sZUFBZW5C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QUMsQ0FBQ0osT0FBT0EsS0FBS0MsSUFBSSxLQUFLLFNBQVNGLGFBQWFNLElBQUksQ0FBQztnQkFDcEQsR0FBR0wsSUFBSTtnQkFDUE0sWUFBWUg7WUFDaEI7UUFDSixPQUFPLElBQUlILEtBQUtDLElBQUksS0FBSyxVQUFVTCxPQUFPSSxLQUFLakQsU0FBUyxFQUFFSixhQUFhb0QsYUFBYU0sSUFBSSxDQUFDO1lBQ3JGLEdBQUdMLElBQUk7UUFDWDthQUNLLElBQUlBLEtBQUtDLElBQUksS0FBSyxRQUFRRixhQUFhTSxJQUFJLENBQUM7WUFDN0MsR0FBR0wsSUFBSTtRQUNYO0lBQ0o7SUFDQSxPQUFPRDtBQUNYO0FBS3VFLENBQ3ZFLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL2RhbmFtb25uZXh0X3VpLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC1zdGF0ZWx5L2NvbWJvYm94L2Rpc3QvaW1wb3J0Lm1qcz9jYjgwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7dXNlRm9ybVZhbGlkYXRpb25TdGF0ZSBhcyAkazZQcHUkdXNlRm9ybVZhbGlkYXRpb25TdGF0ZX0gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L2Zvcm1cIjtcclxuaW1wb3J0IHtnZXRDaGlsZE5vZGVzIGFzICRrNlBwdSRnZXRDaGlsZE5vZGVzfSBmcm9tIFwiQHJlYWN0LXN0YXRlbHkvY29sbGVjdGlvbnNcIjtcclxuaW1wb3J0IHt1c2VTaW5nbGVTZWxlY3RMaXN0U3RhdGUgYXMgJGs2UHB1JHVzZVNpbmdsZVNlbGVjdExpc3RTdGF0ZSwgTGlzdENvbGxlY3Rpb24gYXMgJGs2UHB1JExpc3RDb2xsZWN0aW9ufSBmcm9tIFwiQHJlYWN0LXN0YXRlbHkvbGlzdFwiO1xyXG5pbXBvcnQge3VzZVN0YXRlIGFzICRrNlBwdSR1c2VTdGF0ZSwgdXNlTWVtbyBhcyAkazZQcHUkdXNlTWVtbywgdXNlUmVmIGFzICRrNlBwdSR1c2VSZWYsIHVzZUNhbGxiYWNrIGFzICRrNlBwdSR1c2VDYWxsYmFjaywgdXNlRWZmZWN0IGFzICRrNlBwdSR1c2VFZmZlY3R9IGZyb20gXCJyZWFjdFwiO1xyXG5pbXBvcnQge3VzZUNvbnRyb2xsZWRTdGF0ZSBhcyAkazZQcHUkdXNlQ29udHJvbGxlZFN0YXRlfSBmcm9tIFwiQHJlYWN0LXN0YXRlbHkvdXRpbHNcIjtcclxuaW1wb3J0IHt1c2VPdmVybGF5VHJpZ2dlclN0YXRlIGFzICRrNlBwdSR1c2VPdmVybGF5VHJpZ2dlclN0YXRlfSBmcm9tIFwiQHJlYWN0LXN0YXRlbHkvb3ZlcmxheXNcIjtcclxuXHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XHJcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKiBcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcclxuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXHJcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqLyAvKlxyXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxyXG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcclxuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXHJcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqLyBcclxuXHJcblxyXG5cclxuXHJcblxyXG5mdW5jdGlvbiAkYTllNzM4MmE3ZDExMWNiNSRleHBvcnQkYjQ1M2EzYmZkNGE1ZmE5ZShwcm9wcykge1xyXG4gICAgdmFyIF9jb2xsZWN0aW9uX2dldEl0ZW0sIF9jb2xsZWN0aW9uX2dldEl0ZW0xO1xyXG4gICAgbGV0IHsgZGVmYXVsdEZpbHRlcjogZGVmYXVsdEZpbHRlciwgbWVudVRyaWdnZXI6IG1lbnVUcmlnZ2VyID0gXCJpbnB1dFwiLCBhbGxvd3NFbXB0eUNvbGxlY3Rpb246IGFsbG93c0VtcHR5Q29sbGVjdGlvbiA9IGZhbHNlLCBhbGxvd3NDdXN0b21WYWx1ZTogYWxsb3dzQ3VzdG9tVmFsdWUsIHNob3VsZENsb3NlT25CbHVyOiBzaG91bGRDbG9zZU9uQmx1ciA9IHRydWUgfSA9IHByb3BzO1xyXG4gICAgbGV0IFtzaG93QWxsSXRlbXMsIHNldFNob3dBbGxJdGVtc10gPSAoMCwgJGs2UHB1JHVzZVN0YXRlKShmYWxzZSk7XHJcbiAgICBsZXQgW2lzRm9jdXNlZCwgc2V0Rm9jdXNlZFN0YXRlXSA9ICgwLCAkazZQcHUkdXNlU3RhdGUpKGZhbHNlKTtcclxuICAgIGxldCBbZm9jdXNTdHJhdGVneSwgc2V0Rm9jdXNTdHJhdGVneV0gPSAoMCwgJGs2UHB1JHVzZVN0YXRlKShudWxsKTtcclxuICAgIGxldCBvblNlbGVjdGlvbkNoYW5nZSA9IChrZXkpPT57XHJcbiAgICAgICAgaWYgKHByb3BzLm9uU2VsZWN0aW9uQ2hhbmdlKSBwcm9wcy5vblNlbGVjdGlvbkNoYW5nZShrZXkpO1xyXG4gICAgICAgIC8vIElmIGtleSBpcyB0aGUgc2FtZSwgcmVzZXQgdGhlIGlucHV0VmFsdWUgYW5kIGNsb3NlIHRoZSBtZW51XHJcbiAgICAgICAgLy8gKHNjZW5hcmlvOiB1c2VyIGNsaWNrcyBvbiBhbHJlYWR5IHNlbGVjdGVkIG9wdGlvbilcclxuICAgICAgICBpZiAoa2V5ID09PSBzZWxlY3RlZEtleSkge1xyXG4gICAgICAgICAgICByZXNldElucHV0VmFsdWUoKTtcclxuICAgICAgICAgICAgY2xvc2VNZW51KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHZhciBfcHJvcHNfaXRlbXM7XHJcbiAgICBsZXQgeyBjb2xsZWN0aW9uOiBjb2xsZWN0aW9uLCBzZWxlY3Rpb25NYW5hZ2VyOiBzZWxlY3Rpb25NYW5hZ2VyLCBzZWxlY3RlZEtleTogc2VsZWN0ZWRLZXksIHNldFNlbGVjdGVkS2V5OiBzZXRTZWxlY3RlZEtleSwgc2VsZWN0ZWRJdGVtOiBzZWxlY3RlZEl0ZW0sIGRpc2FibGVkS2V5czogZGlzYWJsZWRLZXlzIH0gPSAoMCwgJGs2UHB1JHVzZVNpbmdsZVNlbGVjdExpc3RTdGF0ZSkoe1xyXG4gICAgICAgIC4uLnByb3BzLFxyXG4gICAgICAgIG9uU2VsZWN0aW9uQ2hhbmdlOiBvblNlbGVjdGlvbkNoYW5nZSxcclxuICAgICAgICBpdGVtczogKF9wcm9wc19pdGVtcyA9IHByb3BzLml0ZW1zKSAhPT0gbnVsbCAmJiBfcHJvcHNfaXRlbXMgIT09IHZvaWQgMCA/IF9wcm9wc19pdGVtcyA6IHByb3BzLmRlZmF1bHRJdGVtc1xyXG4gICAgfSk7XHJcbiAgICB2YXIgX3Byb3BzX2RlZmF1bHRJbnB1dFZhbHVlLCBfcmVmO1xyXG4gICAgbGV0IFtpbnB1dFZhbHVlLCBzZXRJbnB1dFZhbHVlXSA9ICgwLCAkazZQcHUkdXNlQ29udHJvbGxlZFN0YXRlKShwcm9wcy5pbnB1dFZhbHVlLCAoX3JlZiA9IChfcHJvcHNfZGVmYXVsdElucHV0VmFsdWUgPSBwcm9wcy5kZWZhdWx0SW5wdXRWYWx1ZSkgIT09IG51bGwgJiYgX3Byb3BzX2RlZmF1bHRJbnB1dFZhbHVlICE9PSB2b2lkIDAgPyBfcHJvcHNfZGVmYXVsdElucHV0VmFsdWUgOiAoX2NvbGxlY3Rpb25fZ2V0SXRlbSA9IGNvbGxlY3Rpb24uZ2V0SXRlbShzZWxlY3RlZEtleSkpID09PSBudWxsIHx8IF9jb2xsZWN0aW9uX2dldEl0ZW0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jb2xsZWN0aW9uX2dldEl0ZW0udGV4dFZhbHVlKSAhPT0gbnVsbCAmJiBfcmVmICE9PSB2b2lkIDAgPyBfcmVmIDogXCJcIiwgcHJvcHMub25JbnB1dENoYW5nZSk7XHJcbiAgICAvLyBQcmVzZXJ2ZSBvcmlnaW5hbCBjb2xsZWN0aW9uIHNvIHdlIGNhbiBzaG93IGFsbCBpdGVtcyBvbiBkZW1hbmRcclxuICAgIGxldCBvcmlnaW5hbENvbGxlY3Rpb24gPSBjb2xsZWN0aW9uO1xyXG4gICAgbGV0IGZpbHRlcmVkQ29sbGVjdGlvbiA9ICgwLCAkazZQcHUkdXNlTWVtbykoKCk9Pi8vIE5vIGRlZmF1bHQgZmlsdGVyIGlmIGl0ZW1zIGFyZSBjb250cm9sbGVkLlxyXG4gICAgICAgIHByb3BzLml0ZW1zICE9IG51bGwgfHwgIWRlZmF1bHRGaWx0ZXIgPyBjb2xsZWN0aW9uIDogJGE5ZTczODJhN2QxMTFjYjUkdmFyJGZpbHRlckNvbGxlY3Rpb24oY29sbGVjdGlvbiwgaW5wdXRWYWx1ZSwgZGVmYXVsdEZpbHRlciksIFtcclxuICAgICAgICBjb2xsZWN0aW9uLFxyXG4gICAgICAgIGlucHV0VmFsdWUsXHJcbiAgICAgICAgZGVmYXVsdEZpbHRlcixcclxuICAgICAgICBwcm9wcy5pdGVtc1xyXG4gICAgXSk7XHJcbiAgICBsZXQgW2xhc3RDb2xsZWN0aW9uLCBzZXRMYXN0Q29sbGVjdGlvbl0gPSAoMCwgJGs2UHB1JHVzZVN0YXRlKShmaWx0ZXJlZENvbGxlY3Rpb24pO1xyXG4gICAgLy8gVHJhY2sgd2hhdCBhY3Rpb24gaXMgYXR0ZW1wdGluZyB0byBvcGVuIHRoZSBtZW51XHJcbiAgICBsZXQgbWVudU9wZW5UcmlnZ2VyID0gKDAsICRrNlBwdSR1c2VSZWYpKFwiZm9jdXNcIik7XHJcbiAgICBsZXQgb25PcGVuQ2hhbmdlID0gKG9wZW4pPT57XHJcbiAgICAgICAgaWYgKHByb3BzLm9uT3BlbkNoYW5nZSkgcHJvcHMub25PcGVuQ2hhbmdlKG9wZW4sIG9wZW4gPyBtZW51T3BlblRyaWdnZXIuY3VycmVudCA6IHVuZGVmaW5lZCk7XHJcbiAgICAgICAgc2VsZWN0aW9uTWFuYWdlci5zZXRGb2N1c2VkKG9wZW4pO1xyXG4gICAgICAgIGlmICghb3Blbikgc2VsZWN0aW9uTWFuYWdlci5zZXRGb2N1c2VkS2V5KG51bGwpO1xyXG4gICAgfTtcclxuICAgIGxldCB0cmlnZ2VyU3RhdGUgPSAoMCwgJGs2UHB1JHVzZU92ZXJsYXlUcmlnZ2VyU3RhdGUpKHtcclxuICAgICAgICAuLi5wcm9wcyxcclxuICAgICAgICBvbk9wZW5DaGFuZ2U6IG9uT3BlbkNoYW5nZSxcclxuICAgICAgICBpc09wZW46IHVuZGVmaW5lZCxcclxuICAgICAgICBkZWZhdWx0T3BlbjogdW5kZWZpbmVkXHJcbiAgICB9KTtcclxuICAgIGxldCBvcGVuID0gKGZvY3VzU3RyYXRlZ3kgPSBudWxsLCB0cmlnZ2VyKT0+e1xyXG4gICAgICAgIGxldCBkaXNwbGF5QWxsSXRlbXMgPSB0cmlnZ2VyID09PSBcIm1hbnVhbFwiIHx8IHRyaWdnZXIgPT09IFwiZm9jdXNcIiAmJiBtZW51VHJpZ2dlciA9PT0gXCJmb2N1c1wiO1xyXG4gICAgICAgIC8vIFByZXZlbnQgb3BlbiBvcGVyYXRpb25zIGZyb20gdHJpZ2dlcmluZyBpZiB0aGVyZSBpcyBub3RoaW5nIHRvIGRpc3BsYXlcclxuICAgICAgICAvLyBBbHNvIHByZXZlbnQgb3BlbiBvcGVyYXRpb25zIGZyb20gdHJpZ2dlcmluZyBpZiBpdGVtcyBhcmUgdW5jb250cm9sbGVkIGJ1dCBkZWZhdWx0SXRlbXMgaXMgZW1wdHksIGV2ZW4gaWYgZGlzcGxheUFsbEl0ZW1zIGlzIHRydWUuXHJcbiAgICAgICAgLy8gVGhpcyBpcyB0byBwcmV2ZW50IGNvbWJvYm94ZXMgd2l0aCBlbXB0eSBkZWZhdWx0SXRlbXMgZnJvbSBvcGVuaW5nIGJ1dCBhbGxvdyBjb250cm9sbGVkIGl0ZW1zIGNvbWJvYm94ZXMgdG8gb3BlbiBldmVuIGlmIHRoZSBpbml0YWwgbGlzdCBpcyBlbXB0eSAoYXNzdW1wdGlvbiBpcyB1c2VyIHdpbGwgcHJvdmlkZSBzd2FwIHRoZSBlbXB0eSBsaXN0IHdpdGggYSBiYXNlIGxpc3QgdmlhIG9uT3BlbkNoYW5nZSByZXR1cm5pbmcgYG1lbnVUcmlnZ2VyYCBtYW51YWwpXHJcbiAgICAgICAgaWYgKGFsbG93c0VtcHR5Q29sbGVjdGlvbiB8fCBmaWx0ZXJlZENvbGxlY3Rpb24uc2l6ZSA+IDAgfHwgZGlzcGxheUFsbEl0ZW1zICYmIG9yaWdpbmFsQ29sbGVjdGlvbi5zaXplID4gMCB8fCBwcm9wcy5pdGVtcykge1xyXG4gICAgICAgICAgICBpZiAoZGlzcGxheUFsbEl0ZW1zICYmICF0cmlnZ2VyU3RhdGUuaXNPcGVuICYmIHByb3BzLml0ZW1zID09PSB1bmRlZmluZWQpIC8vIFNob3cgYWxsIGl0ZW1zIGlmIG1lbnUgaXMgbWFudWFsbHkgb3BlbmVkLiBPbmx5IGNhcmUgYWJvdXQgdGhpcyBpZiBpdGVtcyBhcmUgdW5kZWZpbmVkXHJcbiAgICAgICAgICAgIHNldFNob3dBbGxJdGVtcyh0cnVlKTtcclxuICAgICAgICAgICAgbWVudU9wZW5UcmlnZ2VyLmN1cnJlbnQgPSB0cmlnZ2VyO1xyXG4gICAgICAgICAgICBzZXRGb2N1c1N0cmF0ZWd5KGZvY3VzU3RyYXRlZ3kpO1xyXG4gICAgICAgICAgICB0cmlnZ2VyU3RhdGUub3BlbigpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBsZXQgdG9nZ2xlID0gKGZvY3VzU3RyYXRlZ3kgPSBudWxsLCB0cmlnZ2VyKT0+e1xyXG4gICAgICAgIGxldCBkaXNwbGF5QWxsSXRlbXMgPSB0cmlnZ2VyID09PSBcIm1hbnVhbFwiIHx8IHRyaWdnZXIgPT09IFwiZm9jdXNcIiAmJiBtZW51VHJpZ2dlciA9PT0gXCJmb2N1c1wiO1xyXG4gICAgICAgIC8vIElmIHRoZSBtZW51IGlzIGNsb3NlZCBhbmQgdGhlcmUgaXMgbm90aGluZyB0byBkaXNwbGF5LCBlYXJseSByZXR1cm4gc28gdG9nZ2xlIGlzbid0IGNhbGxlZCB0byBwcmV2ZW50IGV4dHJhbmVvdXMgb25PcGVuQ2hhbmdlXHJcbiAgICAgICAgaWYgKCEoYWxsb3dzRW1wdHlDb2xsZWN0aW9uIHx8IGZpbHRlcmVkQ29sbGVjdGlvbi5zaXplID4gMCB8fCBkaXNwbGF5QWxsSXRlbXMgJiYgb3JpZ2luYWxDb2xsZWN0aW9uLnNpemUgPiAwIHx8IHByb3BzLml0ZW1zKSAmJiAhdHJpZ2dlclN0YXRlLmlzT3BlbikgcmV0dXJuO1xyXG4gICAgICAgIGlmIChkaXNwbGF5QWxsSXRlbXMgJiYgIXRyaWdnZXJTdGF0ZS5pc09wZW4gJiYgcHJvcHMuaXRlbXMgPT09IHVuZGVmaW5lZCkgLy8gU2hvdyBhbGwgaXRlbXMgaWYgbWVudSBpcyB0b2dnbGVkIG9wZW4uIE9ubHkgY2FyZSBhYm91dCB0aGlzIGlmIGl0ZW1zIGFyZSB1bmRlZmluZWRcclxuICAgICAgICBzZXRTaG93QWxsSXRlbXModHJ1ZSk7XHJcbiAgICAgICAgLy8gT25seSB1cGRhdGUgdGhlIG1lbnVPcGVuVHJpZ2dlciBpZiBtZW51IGlzIGN1cnJlbnRseSBjbG9zZWRcclxuICAgICAgICBpZiAoIXRyaWdnZXJTdGF0ZS5pc09wZW4pIG1lbnVPcGVuVHJpZ2dlci5jdXJyZW50ID0gdHJpZ2dlcjtcclxuICAgICAgICB0b2dnbGVNZW51KGZvY3VzU3RyYXRlZ3kpO1xyXG4gICAgfTtcclxuICAgIGxldCB1cGRhdGVMYXN0Q29sbGVjdGlvbiA9ICgwLCAkazZQcHUkdXNlQ2FsbGJhY2spKCgpPT57XHJcbiAgICAgICAgc2V0TGFzdENvbGxlY3Rpb24oc2hvd0FsbEl0ZW1zID8gb3JpZ2luYWxDb2xsZWN0aW9uIDogZmlsdGVyZWRDb2xsZWN0aW9uKTtcclxuICAgIH0sIFtcclxuICAgICAgICBzaG93QWxsSXRlbXMsXHJcbiAgICAgICAgb3JpZ2luYWxDb2xsZWN0aW9uLFxyXG4gICAgICAgIGZpbHRlcmVkQ29sbGVjdGlvblxyXG4gICAgXSk7XHJcbiAgICAvLyBJZiBtZW51IGlzIGdvaW5nIHRvIGNsb3NlLCBzYXZlIHRoZSBjdXJyZW50IGNvbGxlY3Rpb24gc28gd2UgY2FuIGZyZWV6ZSB0aGUgZGlzcGxheWVkIGNvbGxlY3Rpb24gd2hlbiB0aGVcclxuICAgIC8vIHVzZXIgY2xpY2tzIG91dHNpZGUgdGhlIHBvcG92ZXIgdG8gY2xvc2UgdGhlIG1lbnUuIFByZXZlbnRzIHRoZSBtZW51IGNvbnRlbnRzIGZyb20gdXBkYXRpbmcgYXMgdGhlIG1lbnUgY2xvc2VzLlxyXG4gICAgbGV0IHRvZ2dsZU1lbnUgPSAoMCwgJGs2UHB1JHVzZUNhbGxiYWNrKSgoZm9jdXNTdHJhdGVneSA9IG51bGwpPT57XHJcbiAgICAgICAgaWYgKHRyaWdnZXJTdGF0ZS5pc09wZW4pIHVwZGF0ZUxhc3RDb2xsZWN0aW9uKCk7XHJcbiAgICAgICAgc2V0Rm9jdXNTdHJhdGVneShmb2N1c1N0cmF0ZWd5KTtcclxuICAgICAgICB0cmlnZ2VyU3RhdGUudG9nZ2xlKCk7XHJcbiAgICB9LCBbXHJcbiAgICAgICAgdHJpZ2dlclN0YXRlLFxyXG4gICAgICAgIHVwZGF0ZUxhc3RDb2xsZWN0aW9uXHJcbiAgICBdKTtcclxuICAgIGxldCBjbG9zZU1lbnUgPSAoMCwgJGs2UHB1JHVzZUNhbGxiYWNrKSgoKT0+e1xyXG4gICAgICAgIGlmICh0cmlnZ2VyU3RhdGUuaXNPcGVuKSB7XHJcbiAgICAgICAgICAgIHVwZGF0ZUxhc3RDb2xsZWN0aW9uKCk7XHJcbiAgICAgICAgICAgIHRyaWdnZXJTdGF0ZS5jbG9zZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFtcclxuICAgICAgICB0cmlnZ2VyU3RhdGUsXHJcbiAgICAgICAgdXBkYXRlTGFzdENvbGxlY3Rpb25cclxuICAgIF0pO1xyXG4gICAgbGV0IFtsYXN0VmFsdWUsIHNldExhc3RWYWx1ZV0gPSAoMCwgJGs2UHB1JHVzZVN0YXRlKShpbnB1dFZhbHVlKTtcclxuICAgIGxldCByZXNldElucHV0VmFsdWUgPSAoKT0+e1xyXG4gICAgICAgIHZhciBfY29sbGVjdGlvbl9nZXRJdGVtO1xyXG4gICAgICAgIHZhciBfY29sbGVjdGlvbl9nZXRJdGVtX3RleHRWYWx1ZTtcclxuICAgICAgICBsZXQgaXRlbVRleHQgPSAoX2NvbGxlY3Rpb25fZ2V0SXRlbV90ZXh0VmFsdWUgPSAoX2NvbGxlY3Rpb25fZ2V0SXRlbSA9IGNvbGxlY3Rpb24uZ2V0SXRlbShzZWxlY3RlZEtleSkpID09PSBudWxsIHx8IF9jb2xsZWN0aW9uX2dldEl0ZW0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jb2xsZWN0aW9uX2dldEl0ZW0udGV4dFZhbHVlKSAhPT0gbnVsbCAmJiBfY29sbGVjdGlvbl9nZXRJdGVtX3RleHRWYWx1ZSAhPT0gdm9pZCAwID8gX2NvbGxlY3Rpb25fZ2V0SXRlbV90ZXh0VmFsdWUgOiBcIlwiO1xyXG4gICAgICAgIHNldExhc3RWYWx1ZShpdGVtVGV4dCk7XHJcbiAgICAgICAgc2V0SW5wdXRWYWx1ZShpdGVtVGV4dCk7XHJcbiAgICB9O1xyXG4gICAgdmFyIF9wcm9wc19zZWxlY3RlZEtleSwgX3JlZjE7XHJcbiAgICBsZXQgbGFzdFNlbGVjdGVkS2V5ID0gKDAsICRrNlBwdSR1c2VSZWYpKChfcmVmMSA9IChfcHJvcHNfc2VsZWN0ZWRLZXkgPSBwcm9wcy5zZWxlY3RlZEtleSkgIT09IG51bGwgJiYgX3Byb3BzX3NlbGVjdGVkS2V5ICE9PSB2b2lkIDAgPyBfcHJvcHNfc2VsZWN0ZWRLZXkgOiBwcm9wcy5kZWZhdWx0U2VsZWN0ZWRLZXkpICE9PSBudWxsICYmIF9yZWYxICE9PSB2b2lkIDAgPyBfcmVmMSA6IG51bGwpO1xyXG4gICAgdmFyIF9jb2xsZWN0aW9uX2dldEl0ZW1fdGV4dFZhbHVlO1xyXG4gICAgbGV0IGxhc3RTZWxlY3RlZEtleVRleHQgPSAoMCwgJGs2UHB1JHVzZVJlZikoKF9jb2xsZWN0aW9uX2dldEl0ZW1fdGV4dFZhbHVlID0gKF9jb2xsZWN0aW9uX2dldEl0ZW0xID0gY29sbGVjdGlvbi5nZXRJdGVtKHNlbGVjdGVkS2V5KSkgPT09IG51bGwgfHwgX2NvbGxlY3Rpb25fZ2V0SXRlbTEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jb2xsZWN0aW9uX2dldEl0ZW0xLnRleHRWYWx1ZSkgIT09IG51bGwgJiYgX2NvbGxlY3Rpb25fZ2V0SXRlbV90ZXh0VmFsdWUgIT09IHZvaWQgMCA/IF9jb2xsZWN0aW9uX2dldEl0ZW1fdGV4dFZhbHVlIDogXCJcIik7XHJcbiAgICAvLyBpbnRlbnRpb25hbCBvbWl0IGRlcGVuZGVuY3kgYXJyYXksIHdhbnQgdGhpcyB0byBoYXBwZW4gb24gZXZlcnkgcmVuZGVyXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXHJcbiAgICAoMCwgJGs2UHB1JHVzZUVmZmVjdCkoKCk9PntcclxuICAgICAgICB2YXIgX2NvbGxlY3Rpb25fZ2V0SXRlbTtcclxuICAgICAgICAvLyBPcGVuIGFuZCBjbG9zZSBtZW51IGF1dG9tYXRpY2FsbHkgd2hlbiB0aGUgaW5wdXQgdmFsdWUgY2hhbmdlcyBpZiB0aGUgaW5wdXQgaXMgZm9jdXNlZCxcclxuICAgICAgICAvLyBhbmQgdGhlcmUgYXJlIGl0ZW1zIGluIHRoZSBjb2xsZWN0aW9uIG9yIGFsbG93RW1wdHlDb2xsZWN0aW9uIGlzIHRydWUuXHJcbiAgICAgICAgaWYgKGlzRm9jdXNlZCAmJiAoZmlsdGVyZWRDb2xsZWN0aW9uLnNpemUgPiAwIHx8IGFsbG93c0VtcHR5Q29sbGVjdGlvbikgJiYgIXRyaWdnZXJTdGF0ZS5pc09wZW4gJiYgaW5wdXRWYWx1ZSAhPT0gbGFzdFZhbHVlICYmIG1lbnVUcmlnZ2VyICE9PSBcIm1hbnVhbFwiKSBvcGVuKG51bGwsIFwiaW5wdXRcIik7XHJcbiAgICAgICAgLy8gQ2xvc2UgdGhlIG1lbnUgaWYgdGhlIGNvbGxlY3Rpb24gaXMgZW1wdHkuIERvbid0IGNsb3NlIG1lbnUgaWYgZmlsdGVyZWQgY29sbGVjdGlvbiBzaXplIGlzIDBcclxuICAgICAgICAvLyBidXQgd2UgYXJlIGN1cnJlbnRseSBzaG93aW5nIGFsbCBpdGVtcyB2aWEgYnV0dG9uIHByZXNzXHJcbiAgICAgICAgaWYgKCFzaG93QWxsSXRlbXMgJiYgIWFsbG93c0VtcHR5Q29sbGVjdGlvbiAmJiB0cmlnZ2VyU3RhdGUuaXNPcGVuICYmIGZpbHRlcmVkQ29sbGVjdGlvbi5zaXplID09PSAwKSBjbG9zZU1lbnUoKTtcclxuICAgICAgICAvLyBDbG9zZSB3aGVuIGFuIGl0ZW0gaXMgc2VsZWN0ZWQuXHJcbiAgICAgICAgaWYgKHNlbGVjdGVkS2V5ICE9IG51bGwgJiYgc2VsZWN0ZWRLZXkgIT09IGxhc3RTZWxlY3RlZEtleS5jdXJyZW50KSBjbG9zZU1lbnUoKTtcclxuICAgICAgICAvLyBDbGVhciBmb2N1c2VkIGtleSB3aGVuIGlucHV0IHZhbHVlIGNoYW5nZXMgYW5kIGRpc3BsYXkgZmlsdGVyZWQgY29sbGVjdGlvbiBhZ2Fpbi5cclxuICAgICAgICBpZiAoaW5wdXRWYWx1ZSAhPT0gbGFzdFZhbHVlKSB7XHJcbiAgICAgICAgICAgIHNlbGVjdGlvbk1hbmFnZXIuc2V0Rm9jdXNlZEtleShudWxsKTtcclxuICAgICAgICAgICAgc2V0U2hvd0FsbEl0ZW1zKGZhbHNlKTtcclxuICAgICAgICAgICAgLy8gU2V0IHNlbGVjdGVkS2V5IHRvIG51bGwgd2hlbiB0aGUgdXNlciBjbGVhcnMgdGhlIGlucHV0LlxyXG4gICAgICAgICAgICAvLyBJZiBjb250cm9sbGVkLCB0aGlzIGlzIHRoZSBhcHBsaWNhdGlvbiBkZXZlbG9wZXIncyByZXNwb25zaWJpbGl0eS5cclxuICAgICAgICAgICAgaWYgKGlucHV0VmFsdWUgPT09IFwiXCIgJiYgKHByb3BzLmlucHV0VmFsdWUgPT09IHVuZGVmaW5lZCB8fCBwcm9wcy5zZWxlY3RlZEtleSA9PT0gdW5kZWZpbmVkKSkgc2V0U2VsZWN0ZWRLZXkobnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIHRoZSBzZWxlY3RlZEtleSBjaGFuZ2VkLCB1cGRhdGUgdGhlIGlucHV0IHZhbHVlLlxyXG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgYm90aCBpbnB1dFZhbHVlIGFuZCBzZWxlY3RlZEtleSBhcmUgY29udHJvbGxlZC5cclxuICAgICAgICAvLyBJbiB0aGlzIGNhc2UsIGl0J3MgdGhlIHVzZXIncyByZXNwb25zaWJpbGl0eSB0byB1cGRhdGUgaW5wdXRWYWx1ZSBpbiBvblNlbGVjdGlvbkNoYW5nZS5cclxuICAgICAgICBpZiAoc2VsZWN0ZWRLZXkgIT09IGxhc3RTZWxlY3RlZEtleS5jdXJyZW50ICYmIChwcm9wcy5pbnB1dFZhbHVlID09PSB1bmRlZmluZWQgfHwgcHJvcHMuc2VsZWN0ZWRLZXkgPT09IHVuZGVmaW5lZCkpIHJlc2V0SW5wdXRWYWx1ZSgpO1xyXG4gICAgICAgIGVsc2UgaWYgKGxhc3RWYWx1ZSAhPT0gaW5wdXRWYWx1ZSkgc2V0TGFzdFZhbHVlKGlucHV0VmFsdWUpO1xyXG4gICAgICAgIHZhciBfY29sbGVjdGlvbl9nZXRJdGVtX3RleHRWYWx1ZTtcclxuICAgICAgICAvLyBVcGRhdGUgdGhlIGlucHV0VmFsdWUgaWYgdGhlIHNlbGVjdGVkIGl0ZW0ncyB0ZXh0IGNoYW5nZXMgZnJvbSBpdHMgbGFzdCB0cmFja2VkIHZhbHVlLlxyXG4gICAgICAgIC8vIFRoaXMgaXMgdG8gaGFuZGxlIGNhc2VzIHdoZXJlIGEgc2VsZWN0ZWRLZXkgaXMgc3BlY2lmaWVkIGJ1dCB0aGUgaXRlbXMgYXJlbid0IGF2YWlsYWJsZSAoYXN5bmMgbG9hZGluZykgb3IgdGhlIHNlbGVjdGVkIGl0ZW0ncyB0ZXh0IHZhbHVlIHVwZGF0ZXMuXHJcbiAgICAgICAgLy8gT25seSByZXNldCBpZiB0aGUgdXNlciBpc24ndCBjdXJyZW50bHkgd2l0aGluIHRoZSBmaWVsZCBzbyB3ZSBkb24ndCBlcnJvbmVvdXNseSBtb2RpZnkgdXNlciBpbnB1dC5cclxuICAgICAgICAvLyBJZiBpbnB1dFZhbHVlIGlzIGNvbnRyb2xsZWQsIGl0IGlzIHRoZSB1c2VyJ3MgcmVzcG9uc2liaWxpdHkgdG8gdXBkYXRlIHRoZSBpbnB1dFZhbHVlIHdoZW4gaXRlbXMgY2hhbmdlLlxyXG4gICAgICAgIGxldCBzZWxlY3RlZEl0ZW1UZXh0ID0gKF9jb2xsZWN0aW9uX2dldEl0ZW1fdGV4dFZhbHVlID0gKF9jb2xsZWN0aW9uX2dldEl0ZW0gPSBjb2xsZWN0aW9uLmdldEl0ZW0oc2VsZWN0ZWRLZXkpKSA9PT0gbnVsbCB8fCBfY29sbGVjdGlvbl9nZXRJdGVtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfY29sbGVjdGlvbl9nZXRJdGVtLnRleHRWYWx1ZSkgIT09IG51bGwgJiYgX2NvbGxlY3Rpb25fZ2V0SXRlbV90ZXh0VmFsdWUgIT09IHZvaWQgMCA/IF9jb2xsZWN0aW9uX2dldEl0ZW1fdGV4dFZhbHVlIDogXCJcIjtcclxuICAgICAgICBpZiAoIWlzRm9jdXNlZCAmJiBzZWxlY3RlZEtleSAhPSBudWxsICYmIHByb3BzLmlucHV0VmFsdWUgPT09IHVuZGVmaW5lZCAmJiBzZWxlY3RlZEtleSA9PT0gbGFzdFNlbGVjdGVkS2V5LmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgaWYgKGxhc3RTZWxlY3RlZEtleVRleHQuY3VycmVudCAhPT0gc2VsZWN0ZWRJdGVtVGV4dCkge1xyXG4gICAgICAgICAgICAgICAgc2V0TGFzdFZhbHVlKHNlbGVjdGVkSXRlbVRleHQpO1xyXG4gICAgICAgICAgICAgICAgc2V0SW5wdXRWYWx1ZShzZWxlY3RlZEl0ZW1UZXh0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBsYXN0U2VsZWN0ZWRLZXkuY3VycmVudCA9IHNlbGVjdGVkS2V5O1xyXG4gICAgICAgIGxhc3RTZWxlY3RlZEtleVRleHQuY3VycmVudCA9IHNlbGVjdGVkSXRlbVRleHQ7XHJcbiAgICB9KTtcclxuICAgIGxldCB2YWxpZGF0aW9uID0gKDAsICRrNlBwdSR1c2VGb3JtVmFsaWRhdGlvblN0YXRlKSh7XHJcbiAgICAgICAgLi4ucHJvcHMsXHJcbiAgICAgICAgdmFsdWU6ICgwLCAkazZQcHUkdXNlTWVtbykoKCk9Pih7XHJcbiAgICAgICAgICAgICAgICBpbnB1dFZhbHVlOiBpbnB1dFZhbHVlLFxyXG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRLZXk6IHNlbGVjdGVkS2V5XHJcbiAgICAgICAgICAgIH0pLCBbXHJcbiAgICAgICAgICAgIGlucHV0VmFsdWUsXHJcbiAgICAgICAgICAgIHNlbGVjdGVkS2V5XHJcbiAgICAgICAgXSlcclxuICAgIH0pO1xyXG4gICAgLy8gUmV2ZXJ0IGlucHV0IHZhbHVlIGFuZCBjbG9zZSBtZW51XHJcbiAgICBsZXQgcmV2ZXJ0ID0gKCk9PntcclxuICAgICAgICBpZiAoYWxsb3dzQ3VzdG9tVmFsdWUgJiYgc2VsZWN0ZWRLZXkgPT0gbnVsbCkgY29tbWl0Q3VzdG9tVmFsdWUoKTtcclxuICAgICAgICBlbHNlIGNvbW1pdFNlbGVjdGlvbigpO1xyXG4gICAgfTtcclxuICAgIGxldCBjb21taXRDdXN0b21WYWx1ZSA9ICgpPT57XHJcbiAgICAgICAgbGFzdFNlbGVjdGVkS2V5LmN1cnJlbnQgPSBudWxsO1xyXG4gICAgICAgIHNldFNlbGVjdGVkS2V5KG51bGwpO1xyXG4gICAgICAgIGNsb3NlTWVudSgpO1xyXG4gICAgfTtcclxuICAgIGxldCBjb21taXRTZWxlY3Rpb24gPSAoKT0+e1xyXG4gICAgICAgIC8vIElmIG11bHRpcGxlIHRoaW5ncyBhcmUgY29udHJvbGxlZCwgY2FsbCBvblNlbGVjdGlvbkNoYW5nZVxyXG4gICAgICAgIGlmIChwcm9wcy5zZWxlY3RlZEtleSAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmlucHV0VmFsdWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB2YXIgX2NvbGxlY3Rpb25fZ2V0SXRlbTtcclxuICAgICAgICAgICAgcHJvcHMub25TZWxlY3Rpb25DaGFuZ2Uoc2VsZWN0ZWRLZXkpO1xyXG4gICAgICAgICAgICB2YXIgX2NvbGxlY3Rpb25fZ2V0SXRlbV90ZXh0VmFsdWU7XHJcbiAgICAgICAgICAgIC8vIFN0b3AgbWVudSBmcm9tIHJlb3BlbmluZyBmcm9tIHVzZUVmZmVjdFxyXG4gICAgICAgICAgICBsZXQgaXRlbVRleHQgPSAoX2NvbGxlY3Rpb25fZ2V0SXRlbV90ZXh0VmFsdWUgPSAoX2NvbGxlY3Rpb25fZ2V0SXRlbSA9IGNvbGxlY3Rpb24uZ2V0SXRlbShzZWxlY3RlZEtleSkpID09PSBudWxsIHx8IF9jb2xsZWN0aW9uX2dldEl0ZW0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jb2xsZWN0aW9uX2dldEl0ZW0udGV4dFZhbHVlKSAhPT0gbnVsbCAmJiBfY29sbGVjdGlvbl9nZXRJdGVtX3RleHRWYWx1ZSAhPT0gdm9pZCAwID8gX2NvbGxlY3Rpb25fZ2V0SXRlbV90ZXh0VmFsdWUgOiBcIlwiO1xyXG4gICAgICAgICAgICBzZXRMYXN0VmFsdWUoaXRlbVRleHQpO1xyXG4gICAgICAgICAgICBjbG9zZU1lbnUoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBJZiBvbmx5IGEgc2luZ2xlIGFzcGVjdCBvZiBjb21ib2JveCBpcyBjb250cm9sbGVkLCByZXNldCBpbnB1dCB2YWx1ZSBhbmQgY2xvc2UgbWVudSBmb3IgdGhlIHVzZXJcclxuICAgICAgICAgICAgcmVzZXRJbnB1dFZhbHVlKCk7XHJcbiAgICAgICAgICAgIGNsb3NlTWVudSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBjb21taXRWYWx1ZSA9ICgpPT57XHJcbiAgICAgICAgaWYgKGFsbG93c0N1c3RvbVZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhciBfY29sbGVjdGlvbl9nZXRJdGVtO1xyXG4gICAgICAgICAgICB2YXIgX2NvbGxlY3Rpb25fZ2V0SXRlbV90ZXh0VmFsdWU7XHJcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1UZXh0ID0gKF9jb2xsZWN0aW9uX2dldEl0ZW1fdGV4dFZhbHVlID0gKF9jb2xsZWN0aW9uX2dldEl0ZW0gPSBjb2xsZWN0aW9uLmdldEl0ZW0oc2VsZWN0ZWRLZXkpKSA9PT0gbnVsbCB8fCBfY29sbGVjdGlvbl9nZXRJdGVtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfY29sbGVjdGlvbl9nZXRJdGVtLnRleHRWYWx1ZSkgIT09IG51bGwgJiYgX2NvbGxlY3Rpb25fZ2V0SXRlbV90ZXh0VmFsdWUgIT09IHZvaWQgMCA/IF9jb2xsZWN0aW9uX2dldEl0ZW1fdGV4dFZhbHVlIDogXCJcIjtcclxuICAgICAgICAgICAgaW5wdXRWYWx1ZSA9PT0gaXRlbVRleHQgPyBjb21taXRTZWxlY3Rpb24oKSA6IGNvbW1pdEN1c3RvbVZhbHVlKCk7XHJcbiAgICAgICAgfSBlbHNlIC8vIFJlc2V0IGlucHV0VmFsdWUgYW5kIGNsb3NlIG1lbnVcclxuICAgICAgICBjb21taXRTZWxlY3Rpb24oKTtcclxuICAgIH07XHJcbiAgICBsZXQgY29tbWl0ID0gKCk9PntcclxuICAgICAgICBpZiAodHJpZ2dlclN0YXRlLmlzT3BlbiAmJiBzZWxlY3Rpb25NYW5hZ2VyLmZvY3VzZWRLZXkgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAvLyBSZXNldCBpbnB1dFZhbHVlIGFuZCBjbG9zZSBtZW51IGhlcmUgaWYgdGhlIHNlbGVjdGVkIGtleSBpcyBhbHJlYWR5IHRoZSBmb2N1c2VkIGtleS4gT3RoZXJ3aXNlXHJcbiAgICAgICAgICAgIC8vIGZpcmUgb25TZWxlY3Rpb25DaGFuZ2UgdG8gYWxsb3cgdGhlIGFwcGxpY2F0aW9uIHRvIGNvbnRyb2wgdGhlIGNsb3NpbmcuXHJcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZEtleSA9PT0gc2VsZWN0aW9uTWFuYWdlci5mb2N1c2VkS2V5KSBjb21taXRTZWxlY3Rpb24oKTtcclxuICAgICAgICAgICAgZWxzZSBzZXRTZWxlY3RlZEtleShzZWxlY3Rpb25NYW5hZ2VyLmZvY3VzZWRLZXkpO1xyXG4gICAgICAgIH0gZWxzZSBjb21taXRWYWx1ZSgpO1xyXG4gICAgfTtcclxuICAgIGxldCB2YWx1ZU9uRm9jdXMgPSAoMCwgJGs2UHB1JHVzZVJlZikoaW5wdXRWYWx1ZSk7XHJcbiAgICBsZXQgc2V0Rm9jdXNlZCA9IChpc0ZvY3VzZWQpPT57XHJcbiAgICAgICAgaWYgKGlzRm9jdXNlZCkge1xyXG4gICAgICAgICAgICB2YWx1ZU9uRm9jdXMuY3VycmVudCA9IGlucHV0VmFsdWU7XHJcbiAgICAgICAgICAgIGlmIChtZW51VHJpZ2dlciA9PT0gXCJmb2N1c1wiKSBvcGVuKG51bGwsIFwiZm9jdXNcIik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHNob3VsZENsb3NlT25CbHVyKSBjb21taXRWYWx1ZSgpO1xyXG4gICAgICAgICAgICBpZiAoaW5wdXRWYWx1ZSAhPT0gdmFsdWVPbkZvY3VzLmN1cnJlbnQpIHZhbGlkYXRpb24uY29tbWl0VmFsaWRhdGlvbigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZXRGb2N1c2VkU3RhdGUoaXNGb2N1c2VkKTtcclxuICAgIH07XHJcbiAgICBsZXQgZGlzcGxheWVkQ29sbGVjdGlvbiA9ICgwLCAkazZQcHUkdXNlTWVtbykoKCk9PntcclxuICAgICAgICBpZiAodHJpZ2dlclN0YXRlLmlzT3Blbikge1xyXG4gICAgICAgICAgICBpZiAoc2hvd0FsbEl0ZW1zKSByZXR1cm4gb3JpZ2luYWxDb2xsZWN0aW9uO1xyXG4gICAgICAgICAgICBlbHNlIHJldHVybiBmaWx0ZXJlZENvbGxlY3Rpb247XHJcbiAgICAgICAgfSBlbHNlIHJldHVybiBsYXN0Q29sbGVjdGlvbjtcclxuICAgIH0sIFtcclxuICAgICAgICB0cmlnZ2VyU3RhdGUuaXNPcGVuLFxyXG4gICAgICAgIG9yaWdpbmFsQ29sbGVjdGlvbixcclxuICAgICAgICBmaWx0ZXJlZENvbGxlY3Rpb24sXHJcbiAgICAgICAgc2hvd0FsbEl0ZW1zLFxyXG4gICAgICAgIGxhc3RDb2xsZWN0aW9uXHJcbiAgICBdKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgLi4udmFsaWRhdGlvbixcclxuICAgICAgICAuLi50cmlnZ2VyU3RhdGUsXHJcbiAgICAgICAgZm9jdXNTdHJhdGVneTogZm9jdXNTdHJhdGVneSxcclxuICAgICAgICB0b2dnbGU6IHRvZ2dsZSxcclxuICAgICAgICBvcGVuOiBvcGVuLFxyXG4gICAgICAgIGNsb3NlOiBjb21taXRWYWx1ZSxcclxuICAgICAgICBzZWxlY3Rpb25NYW5hZ2VyOiBzZWxlY3Rpb25NYW5hZ2VyLFxyXG4gICAgICAgIHNlbGVjdGVkS2V5OiBzZWxlY3RlZEtleSxcclxuICAgICAgICBzZXRTZWxlY3RlZEtleTogc2V0U2VsZWN0ZWRLZXksXHJcbiAgICAgICAgZGlzYWJsZWRLZXlzOiBkaXNhYmxlZEtleXMsXHJcbiAgICAgICAgaXNGb2N1c2VkOiBpc0ZvY3VzZWQsXHJcbiAgICAgICAgc2V0Rm9jdXNlZDogc2V0Rm9jdXNlZCxcclxuICAgICAgICBzZWxlY3RlZEl0ZW06IHNlbGVjdGVkSXRlbSxcclxuICAgICAgICBjb2xsZWN0aW9uOiBkaXNwbGF5ZWRDb2xsZWN0aW9uLFxyXG4gICAgICAgIGlucHV0VmFsdWU6IGlucHV0VmFsdWUsXHJcbiAgICAgICAgc2V0SW5wdXRWYWx1ZTogc2V0SW5wdXRWYWx1ZSxcclxuICAgICAgICBjb21taXQ6IGNvbW1pdCxcclxuICAgICAgICByZXZlcnQ6IHJldmVydFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiAkYTllNzM4MmE3ZDExMWNiNSR2YXIkZmlsdGVyQ29sbGVjdGlvbihjb2xsZWN0aW9uLCBpbnB1dFZhbHVlLCBmaWx0ZXIpIHtcclxuICAgIHJldHVybiBuZXcgKDAsICRrNlBwdSRMaXN0Q29sbGVjdGlvbikoJGE5ZTczODJhN2QxMTFjYjUkdmFyJGZpbHRlck5vZGVzKGNvbGxlY3Rpb24sIGNvbGxlY3Rpb24sIGlucHV0VmFsdWUsIGZpbHRlcikpO1xyXG59XHJcbmZ1bmN0aW9uICRhOWU3MzgyYTdkMTExY2I1JHZhciRmaWx0ZXJOb2Rlcyhjb2xsZWN0aW9uLCBub2RlcywgaW5wdXRWYWx1ZSwgZmlsdGVyKSB7XHJcbiAgICBsZXQgZmlsdGVyZWROb2RlID0gW107XHJcbiAgICBmb3IgKGxldCBub2RlIG9mIG5vZGVzKXtcclxuICAgICAgICBpZiAobm9kZS50eXBlID09PSBcInNlY3Rpb25cIiAmJiBub2RlLmhhc0NoaWxkTm9kZXMpIHtcclxuICAgICAgICAgICAgbGV0IGZpbHRlcmVkID0gJGE5ZTczODJhN2QxMTFjYjUkdmFyJGZpbHRlck5vZGVzKGNvbGxlY3Rpb24sICgwLCAkazZQcHUkZ2V0Q2hpbGROb2Rlcykobm9kZSwgY29sbGVjdGlvbiksIGlucHV0VmFsdWUsIGZpbHRlcik7XHJcbiAgICAgICAgICAgIGlmIChbXHJcbiAgICAgICAgICAgICAgICAuLi5maWx0ZXJlZFxyXG4gICAgICAgICAgICBdLnNvbWUoKG5vZGUpPT5ub2RlLnR5cGUgPT09IFwiaXRlbVwiKSkgZmlsdGVyZWROb2RlLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgLi4ubm9kZSxcclxuICAgICAgICAgICAgICAgIGNoaWxkTm9kZXM6IGZpbHRlcmVkXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSBcIml0ZW1cIiAmJiBmaWx0ZXIobm9kZS50ZXh0VmFsdWUsIGlucHV0VmFsdWUpKSBmaWx0ZXJlZE5vZGUucHVzaCh7XHJcbiAgICAgICAgICAgIC4uLm5vZGVcclxuICAgICAgICB9KTtcclxuICAgICAgICBlbHNlIGlmIChub2RlLnR5cGUgIT09IFwiaXRlbVwiKSBmaWx0ZXJlZE5vZGUucHVzaCh7XHJcbiAgICAgICAgICAgIC4uLm5vZGVcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiBmaWx0ZXJlZE5vZGU7XHJcbn1cclxuXHJcblxyXG5cclxuXHJcbmV4cG9ydCB7JGE5ZTczODJhN2QxMTFjYjUkZXhwb3J0JGI0NTNhM2JmZDRhNWZhOWUgYXMgdXNlQ29tYm9Cb3hTdGF0ZX07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsZS5qcy5tYXBcclxuIl0sIm5hbWVzIjpbInVzZUZvcm1WYWxpZGF0aW9uU3RhdGUiLCIkazZQcHUkdXNlRm9ybVZhbGlkYXRpb25TdGF0ZSIsImdldENoaWxkTm9kZXMiLCIkazZQcHUkZ2V0Q2hpbGROb2RlcyIsInVzZVNpbmdsZVNlbGVjdExpc3RTdGF0ZSIsIiRrNlBwdSR1c2VTaW5nbGVTZWxlY3RMaXN0U3RhdGUiLCJMaXN0Q29sbGVjdGlvbiIsIiRrNlBwdSRMaXN0Q29sbGVjdGlvbiIsInVzZVN0YXRlIiwiJGs2UHB1JHVzZVN0YXRlIiwidXNlTWVtbyIsIiRrNlBwdSR1c2VNZW1vIiwidXNlUmVmIiwiJGs2UHB1JHVzZVJlZiIsInVzZUNhbGxiYWNrIiwiJGs2UHB1JHVzZUNhbGxiYWNrIiwidXNlRWZmZWN0IiwiJGs2UHB1JHVzZUVmZmVjdCIsInVzZUNvbnRyb2xsZWRTdGF0ZSIsIiRrNlBwdSR1c2VDb250cm9sbGVkU3RhdGUiLCJ1c2VPdmVybGF5VHJpZ2dlclN0YXRlIiwiJGs2UHB1JHVzZU92ZXJsYXlUcmlnZ2VyU3RhdGUiLCIkYTllNzM4MmE3ZDExMWNiNSRleHBvcnQkYjQ1M2EzYmZkNGE1ZmE5ZSIsInByb3BzIiwiX2NvbGxlY3Rpb25fZ2V0SXRlbSIsIl9jb2xsZWN0aW9uX2dldEl0ZW0xIiwiZGVmYXVsdEZpbHRlciIsIm1lbnVUcmlnZ2VyIiwiYWxsb3dzRW1wdHlDb2xsZWN0aW9uIiwiYWxsb3dzQ3VzdG9tVmFsdWUiLCJzaG91bGRDbG9zZU9uQmx1ciIsInNob3dBbGxJdGVtcyIsInNldFNob3dBbGxJdGVtcyIsImlzRm9jdXNlZCIsInNldEZvY3VzZWRTdGF0ZSIsImZvY3VzU3RyYXRlZ3kiLCJzZXRGb2N1c1N0cmF0ZWd5Iiwib25TZWxlY3Rpb25DaGFuZ2UiLCJrZXkiLCJzZWxlY3RlZEtleSIsInJlc2V0SW5wdXRWYWx1ZSIsImNsb3NlTWVudSIsIl9wcm9wc19pdGVtcyIsImNvbGxlY3Rpb24iLCJzZWxlY3Rpb25NYW5hZ2VyIiwic2V0U2VsZWN0ZWRLZXkiLCJzZWxlY3RlZEl0ZW0iLCJkaXNhYmxlZEtleXMiLCJpdGVtcyIsImRlZmF1bHRJdGVtcyIsIl9wcm9wc19kZWZhdWx0SW5wdXRWYWx1ZSIsIl9yZWYiLCJpbnB1dFZhbHVlIiwic2V0SW5wdXRWYWx1ZSIsImRlZmF1bHRJbnB1dFZhbHVlIiwiZ2V0SXRlbSIsInRleHRWYWx1ZSIsIm9uSW5wdXRDaGFuZ2UiLCJvcmlnaW5hbENvbGxlY3Rpb24iLCJmaWx0ZXJlZENvbGxlY3Rpb24iLCIkYTllNzM4MmE3ZDExMWNiNSR2YXIkZmlsdGVyQ29sbGVjdGlvbiIsImxhc3RDb2xsZWN0aW9uIiwic2V0TGFzdENvbGxlY3Rpb24iLCJtZW51T3BlblRyaWdnZXIiLCJvbk9wZW5DaGFuZ2UiLCJvcGVuIiwiY3VycmVudCIsInVuZGVmaW5lZCIsInNldEZvY3VzZWQiLCJzZXRGb2N1c2VkS2V5IiwidHJpZ2dlclN0YXRlIiwiaXNPcGVuIiwiZGVmYXVsdE9wZW4iLCJ0cmlnZ2VyIiwiZGlzcGxheUFsbEl0ZW1zIiwic2l6ZSIsInRvZ2dsZSIsInRvZ2dsZU1lbnUiLCJ1cGRhdGVMYXN0Q29sbGVjdGlvbiIsImNsb3NlIiwibGFzdFZhbHVlIiwic2V0TGFzdFZhbHVlIiwiX2NvbGxlY3Rpb25fZ2V0SXRlbV90ZXh0VmFsdWUiLCJpdGVtVGV4dCIsIl9wcm9wc19zZWxlY3RlZEtleSIsIl9yZWYxIiwibGFzdFNlbGVjdGVkS2V5IiwiZGVmYXVsdFNlbGVjdGVkS2V5IiwibGFzdFNlbGVjdGVkS2V5VGV4dCIsInNlbGVjdGVkSXRlbVRleHQiLCJ2YWxpZGF0aW9uIiwidmFsdWUiLCJyZXZlcnQiLCJjb21taXRDdXN0b21WYWx1ZSIsImNvbW1pdFNlbGVjdGlvbiIsImNvbW1pdFZhbHVlIiwiY29tbWl0IiwiZm9jdXNlZEtleSIsInZhbHVlT25Gb2N1cyIsImNvbW1pdFZhbGlkYXRpb24iLCJkaXNwbGF5ZWRDb2xsZWN0aW9uIiwiZmlsdGVyIiwiJGE5ZTczODJhN2QxMTFjYjUkdmFyJGZpbHRlck5vZGVzIiwibm9kZXMiLCJmaWx0ZXJlZE5vZGUiLCJub2RlIiwidHlwZSIsImhhc0NoaWxkTm9kZXMiLCJmaWx0ZXJlZCIsInNvbWUiLCJwdXNoIiwiY2hpbGROb2RlcyIsInVzZUNvbWJvQm94U3RhdGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/combobox/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/flags/dist/import.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@react-stately/flags/dist/import.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   enableTableNestedRows: () => (/* binding */ $f4e2df6bd15f8569$export$d9d8a0f82de49530),\n/* harmony export */   tableNestedRows: () => (/* binding */ $f4e2df6bd15f8569$export$1b00cb14a96194e6)\n/* harmony export */ });\n/*\r\n * Copyright 2023 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ let $f4e2df6bd15f8569$var$_tableNestedRows = false;\nfunction $f4e2df6bd15f8569$export$d9d8a0f82de49530() {\n    $f4e2df6bd15f8569$var$_tableNestedRows = true;\n}\nfunction $f4e2df6bd15f8569$export$1b00cb14a96194e6() {\n    return $f4e2df6bd15f8569$var$_tableNestedRows;\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvZmxhZ3MvZGlzdC9pbXBvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Q0FVQyxHQUFHLElBQUlBLHlDQUF5QztBQUNqRCxTQUFTQztJQUNMRCx5Q0FBeUM7QUFDN0M7QUFDQSxTQUFTRTtJQUNMLE9BQU9GO0FBQ1g7QUFHMEksQ0FDMUksa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGFuYW1vbm5leHRfdWkvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvZmxhZ3MvZGlzdC9pbXBvcnQubWpzP2E4MDAiXSwic291cmNlc0NvbnRlbnQiOlsiLypcclxuICogQ29weXJpZ2h0IDIwMjMgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcclxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXHJcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxyXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi8gbGV0ICRmNGUyZGY2YmQxNWY4NTY5JHZhciRfdGFibGVOZXN0ZWRSb3dzID0gZmFsc2U7XHJcbmZ1bmN0aW9uICRmNGUyZGY2YmQxNWY4NTY5JGV4cG9ydCRkOWQ4YTBmODJkZTQ5NTMwKCkge1xyXG4gICAgJGY0ZTJkZjZiZDE1Zjg1NjkkdmFyJF90YWJsZU5lc3RlZFJvd3MgPSB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uICRmNGUyZGY2YmQxNWY4NTY5JGV4cG9ydCQxYjAwY2IxNGE5NjE5NGU2KCkge1xyXG4gICAgcmV0dXJuICRmNGUyZGY2YmQxNWY4NTY5JHZhciRfdGFibGVOZXN0ZWRSb3dzO1xyXG59XHJcblxyXG5cclxuZXhwb3J0IHskZjRlMmRmNmJkMTVmODU2OSRleHBvcnQkZDlkOGEwZjgyZGU0OTUzMCBhcyBlbmFibGVUYWJsZU5lc3RlZFJvd3MsICRmNGUyZGY2YmQxNWY4NTY5JGV4cG9ydCQxYjAwY2IxNGE5NjE5NGU2IGFzIHRhYmxlTmVzdGVkUm93c307XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsZS5qcy5tYXBcclxuIl0sIm5hbWVzIjpbIiRmNGUyZGY2YmQxNWY4NTY5JHZhciRfdGFibGVOZXN0ZWRSb3dzIiwiJGY0ZTJkZjZiZDE1Zjg1NjkkZXhwb3J0JGQ5ZDhhMGY4MmRlNDk1MzAiLCIkZjRlMmRmNmJkMTVmODU2OSRleHBvcnQkMWIwMGNiMTRhOTYxOTRlNiIsImVuYWJsZVRhYmxlTmVzdGVkUm93cyIsInRhYmxlTmVzdGVkUm93cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/flags/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/form/dist/import.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@react-stately/form/dist/import.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_VALIDATION_RESULT: () => (/* binding */ $e5be200c675c3b3a$export$dad6ae84456c676a),\n/* harmony export */   FormValidationContext: () => (/* binding */ $e5be200c675c3b3a$export$571b5131b7e65c11),\n/* harmony export */   VALID_VALIDITY_STATE: () => (/* binding */ $e5be200c675c3b3a$export$aca958c65c314e6c),\n/* harmony export */   mergeValidation: () => (/* binding */ $e5be200c675c3b3a$export$75ee7c75d68f5b0e),\n/* harmony export */   privateValidationStateProp: () => (/* binding */ $e5be200c675c3b3a$export$a763b9476acd3eb),\n/* harmony export */   useFormValidationState: () => (/* binding */ $e5be200c675c3b3a$export$fc1a364ae1f3ff10)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n/*\r\n * Copyright 2023 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ /*\r\n * Copyright 2023 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ const $e5be200c675c3b3a$export$aca958c65c314e6c = {\n    badInput: false,\n    customError: false,\n    patternMismatch: false,\n    rangeOverflow: false,\n    rangeUnderflow: false,\n    stepMismatch: false,\n    tooLong: false,\n    tooShort: false,\n    typeMismatch: false,\n    valueMissing: false,\n    valid: true\n};\nconst $e5be200c675c3b3a$var$CUSTOM_VALIDITY_STATE = {\n    ...$e5be200c675c3b3a$export$aca958c65c314e6c,\n    customError: true,\n    valid: false\n};\nconst $e5be200c675c3b3a$export$dad6ae84456c676a = {\n    isInvalid: false,\n    validationDetails: $e5be200c675c3b3a$export$aca958c65c314e6c,\n    validationErrors: []\n};\nconst $e5be200c675c3b3a$export$571b5131b7e65c11 = (0, react__WEBPACK_IMPORTED_MODULE_0__.createContext)({});\nconst $e5be200c675c3b3a$export$a763b9476acd3eb = \"__formValidationState\" + Date.now();\nfunction $e5be200c675c3b3a$export$fc1a364ae1f3ff10(props) {\n    // Private prop for parent components to pass state to children.\n    if (props[$e5be200c675c3b3a$export$a763b9476acd3eb]) {\n        let { realtimeValidation: realtimeValidation, displayValidation: displayValidation, updateValidation: updateValidation, resetValidation: resetValidation, commitValidation: commitValidation } = props[$e5be200c675c3b3a$export$a763b9476acd3eb];\n        return {\n            realtimeValidation: realtimeValidation,\n            displayValidation: displayValidation,\n            updateValidation: updateValidation,\n            resetValidation: resetValidation,\n            commitValidation: commitValidation\n        };\n    }\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    return $e5be200c675c3b3a$var$useFormValidationStateImpl(props);\n}\nfunction $e5be200c675c3b3a$var$useFormValidationStateImpl(props) {\n    let { isInvalid: isInvalid, validationState: validationState, name: name, value: value, builtinValidation: builtinValidation, validate: validate, validationBehavior: validationBehavior = \"aria\" } = props;\n    // backward compatibility.\n    if (validationState) isInvalid || (isInvalid = validationState === \"invalid\");\n    // If the isInvalid prop is true, update validation result in realtime (controlled).\n    let controlledError = isInvalid ? {\n        isInvalid: true,\n        validationErrors: [],\n        validationDetails: $e5be200c675c3b3a$var$CUSTOM_VALIDITY_STATE\n    } : null;\n    // Perform custom client side validation.\n    let clientError = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>$e5be200c675c3b3a$var$getValidationResult($e5be200c675c3b3a$var$runValidate(validate, value)), [\n        validate,\n        value\n    ]);\n    if (builtinValidation === null || builtinValidation === void 0 ? void 0 : builtinValidation.validationDetails.valid) builtinValidation = null;\n    // Get relevant server errors from the form.\n    let serverErrors = (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)($e5be200c675c3b3a$export$571b5131b7e65c11);\n    let serverErrorMessages = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (name) return Array.isArray(name) ? name.flatMap((name)=>$e5be200c675c3b3a$var$asArray(serverErrors[name])) : $e5be200c675c3b3a$var$asArray(serverErrors[name]);\n        return [];\n    }, [\n        serverErrors,\n        name\n    ]);\n    // Show server errors when the form gets a new value, and clear when the user changes the value.\n    let [lastServerErrors, setLastServerErrors] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(serverErrors);\n    let [isServerErrorCleared, setServerErrorCleared] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    if (serverErrors !== lastServerErrors) {\n        setLastServerErrors(serverErrors);\n        setServerErrorCleared(false);\n    }\n    let serverError = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>$e5be200c675c3b3a$var$getValidationResult(isServerErrorCleared ? [] : serverErrorMessages), [\n        isServerErrorCleared,\n        serverErrorMessages\n    ]);\n    // Track the next validation state in a ref until commitValidation is called.\n    let nextValidation = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)($e5be200c675c3b3a$export$dad6ae84456c676a);\n    let [currentValidity, setCurrentValidity] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)($e5be200c675c3b3a$export$dad6ae84456c676a);\n    let lastError = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)($e5be200c675c3b3a$export$dad6ae84456c676a);\n    let commitValidation = ()=>{\n        if (!commitQueued) return;\n        setCommitQueued(false);\n        let error = clientError || builtinValidation || nextValidation.current;\n        if (!$e5be200c675c3b3a$var$isEqualValidation(error, lastError.current)) {\n            lastError.current = error;\n            setCurrentValidity(error);\n        }\n    };\n    let [commitQueued, setCommitQueued] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(commitValidation);\n    // realtimeValidation is used to update the native input element's state based on custom validation logic.\n    // displayValidation is the currently displayed validation state that the user sees (e.g. on input change/form submit).\n    // With validationBehavior=\"aria\", all errors are displayed in realtime rather than on submit.\n    let realtimeValidation = controlledError || serverError || clientError || builtinValidation || $e5be200c675c3b3a$export$dad6ae84456c676a;\n    let displayValidation = validationBehavior === \"native\" ? controlledError || serverError || currentValidity : controlledError || serverError || clientError || builtinValidation || currentValidity;\n    return {\n        realtimeValidation: realtimeValidation,\n        displayValidation: displayValidation,\n        updateValidation (value) {\n            // If validationBehavior is 'aria', update in realtime. Otherwise, store in a ref until commit.\n            if (validationBehavior === \"aria\" && !$e5be200c675c3b3a$var$isEqualValidation(currentValidity, value)) setCurrentValidity(value);\n            else nextValidation.current = value;\n        },\n        resetValidation () {\n            // Update the currently displayed validation state to valid on form reset,\n            // even if the native validity says it isn't. It'll show again on the next form submit.\n            let error = $e5be200c675c3b3a$export$dad6ae84456c676a;\n            if (!$e5be200c675c3b3a$var$isEqualValidation(error, lastError.current)) {\n                lastError.current = error;\n                setCurrentValidity(error);\n            }\n            // Do not commit validation after the next render. This avoids a condition where\n            // useSelect calls commitValidation inside an onReset handler.\n            if (validationBehavior === \"native\") setCommitQueued(false);\n            setServerErrorCleared(true);\n        },\n        commitValidation () {\n            // Commit validation state so the user sees it on blur/change/submit. Also clear any server errors.\n            // Wait until after the next render to commit so that the latest value has been validated.\n            if (validationBehavior === \"native\") setCommitQueued(true);\n            setServerErrorCleared(true);\n        }\n    };\n}\nfunction $e5be200c675c3b3a$var$asArray(v) {\n    if (!v) return [];\n    return Array.isArray(v) ? v : [\n        v\n    ];\n}\nfunction $e5be200c675c3b3a$var$runValidate(validate, value) {\n    if (typeof validate === \"function\") {\n        let e = validate(value);\n        if (e && typeof e !== \"boolean\") return $e5be200c675c3b3a$var$asArray(e);\n    }\n    return [];\n}\nfunction $e5be200c675c3b3a$var$getValidationResult(errors) {\n    return errors.length ? {\n        isInvalid: true,\n        validationErrors: errors,\n        validationDetails: $e5be200c675c3b3a$var$CUSTOM_VALIDITY_STATE\n    } : null;\n}\nfunction $e5be200c675c3b3a$var$isEqualValidation(a, b) {\n    if (a === b) return true;\n    return a && b && a.isInvalid === b.isInvalid && a.validationErrors.length === b.validationErrors.length && a.validationErrors.every((a, i)=>a === b.validationErrors[i]) && Object.entries(a.validationDetails).every(([k, v])=>b.validationDetails[k] === v);\n}\nfunction $e5be200c675c3b3a$export$75ee7c75d68f5b0e(...results) {\n    let errors = new Set();\n    let isInvalid = false;\n    let validationDetails = {\n        ...$e5be200c675c3b3a$export$aca958c65c314e6c\n    };\n    for (let v of results){\n        var _validationDetails, _key;\n        for (let e of v.validationErrors)errors.add(e);\n        // Only these properties apply for checkboxes.\n        isInvalid || (isInvalid = v.isInvalid);\n        for(let key in validationDetails)(_validationDetails = validationDetails)[_key = key] || (_validationDetails[_key] = v.validationDetails[key]);\n    }\n    validationDetails.valid = !isInvalid;\n    return {\n        isInvalid: isInvalid,\n        validationErrors: [\n            ...errors\n        ],\n        validationDetails: validationDetails\n    };\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvZm9ybS9kaXN0L2ltcG9ydC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUE2TTtBQUU3TTs7Ozs7Ozs7OztDQVVDLEdBQUc7Ozs7Ozs7Ozs7Q0FVSCxHQUNELE1BQU1ZLDRDQUE0QztJQUM5Q0MsVUFBVTtJQUNWQyxhQUFhO0lBQ2JDLGlCQUFpQjtJQUNqQkMsZUFBZTtJQUNmQyxnQkFBZ0I7SUFDaEJDLGNBQWM7SUFDZEMsU0FBUztJQUNUQyxVQUFVO0lBQ1ZDLGNBQWM7SUFDZEMsY0FBYztJQUNkQyxPQUFPO0FBQ1g7QUFDQSxNQUFNQyw4Q0FBOEM7SUFDaEQsR0FBR1oseUNBQXlDO0lBQzVDRSxhQUFhO0lBQ2JTLE9BQU87QUFDWDtBQUNBLE1BQU1FLDRDQUE0QztJQUM5Q0MsV0FBVztJQUNYQyxtQkFBbUJmO0lBQ25CZ0Isa0JBQWtCLEVBQUU7QUFDeEI7QUFDQSxNQUFNQyw0Q0FBNEMsQ0FBQyxHQUFHNUIsZ0RBQW1CLEVBQUcsQ0FBQztBQUM3RSxNQUFNNkIsMkNBQTJDLDBCQUEwQkMsS0FBS0MsR0FBRztBQUNuRixTQUFTQywwQ0FBMENDLEtBQUs7SUFDcEQsZ0VBQWdFO0lBQ2hFLElBQUlBLEtBQUssQ0FBQ0oseUNBQXlDLEVBQUU7UUFDakQsSUFBSSxFQUFFSyxvQkFBb0JBLGtCQUFrQixFQUFFQyxtQkFBbUJBLGlCQUFpQixFQUFFQyxrQkFBa0JBLGdCQUFnQixFQUFFQyxpQkFBaUJBLGVBQWUsRUFBRUMsa0JBQWtCQSxnQkFBZ0IsRUFBRSxHQUFHTCxLQUFLLENBQUNKLHlDQUF5QztRQUNoUCxPQUFPO1lBQ0hLLG9CQUFvQkE7WUFDcEJDLG1CQUFtQkE7WUFDbkJDLGtCQUFrQkE7WUFDbEJDLGlCQUFpQkE7WUFDakJDLGtCQUFrQkE7UUFDdEI7SUFDSjtJQUNBLHNEQUFzRDtJQUN0RCxPQUFPQyxpREFBaUROO0FBQzVEO0FBQ0EsU0FBU00saURBQWlETixLQUFLO0lBQzNELElB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LGdCQUFnQixDQUFDOEMsTUFBTSxLQUFLRSxFQUFFaEQsZ0JBQWdCLENBQUM4QyxNQUFNLElBQUlDLEVBQUUvQyxnQkFBZ0IsQ0FBQ2lELEtBQUssQ0FBQyxDQUFDRixHQUFHRyxJQUFJSCxNQUFNQyxFQUFFaEQsZ0JBQWdCLENBQUNrRCxFQUFFLEtBQUtDLE9BQU9DLE9BQU8sQ0FBQ0wsRUFBRWhELGlCQUFpQixFQUFFa0QsS0FBSyxDQUFDLENBQUMsQ0FBQ0ksR0FBR1YsRUFBRSxHQUFHSyxFQUFFakQsaUJBQWlCLENBQUNzRCxFQUFFLEtBQUtWO0FBQy9QO0FBQ0EsU0FBU1csMENBQTBDLEdBQUdDLE9BQU87SUFDekQsSUFBSVYsU0FBUyxJQUFJVztJQUNqQixJQUFJMUQsWUFBWTtJQUNoQixJQUFJQyxvQkFBb0I7UUFDcEIsR0FBR2YseUNBQXlDO0lBQ2hEO0lBQ0EsS0FBSyxJQUFJMkQsS0FBS1ksUUFBUTtRQUNsQixJQUFJRSxvQkFBb0JDO1FBQ3hCLEtBQUssSUFBSWQsS0FBS0QsRUFBRTNDLGdCQUFnQixDQUFDNkMsT0FBT2MsR0FBRyxDQUFDZjtRQUM1Qyw4Q0FBOEM7UUFDOUM5QyxhQUFjQSxDQUFBQSxZQUFZNkMsRUFBRTdDLFNBQVM7UUFDckMsSUFBSSxJQUFJOEQsT0FBTzdELGtCQUFrQixDQUFDMEQscUJBQXFCMUQsaUJBQWdCLENBQUUsQ0FBQzJELE9BQU9FLElBQUksSUFBS0gsQ0FBQUEsa0JBQWtCLENBQUNDLEtBQUssR0FBR2YsRUFBRTVDLGlCQUFpQixDQUFDNkQsSUFBSTtJQUNqSjtJQUNBN0Qsa0JBQWtCSixLQUFLLEdBQUcsQ0FBQ0c7SUFDM0IsT0FBTztRQUNIQSxXQUFXQTtRQUNYRSxrQkFBa0I7ZUFDWDZDO1NBQ047UUFDRDlDLG1CQUFtQkE7SUFDdkI7QUFDSjtBQUtrYSxDQUNsYSxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYW5hbW9ubmV4dF91aS8uL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3RhdGVseS9mb3JtL2Rpc3QvaW1wb3J0Lm1qcz9mNTAwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7Y3JlYXRlQ29udGV4dCBhcyAkamNJT3ckY3JlYXRlQ29udGV4dCwgdXNlTWVtbyBhcyAkamNJT3ckdXNlTWVtbywgdXNlQ29udGV4dCBhcyAkamNJT3ckdXNlQ29udGV4dCwgdXNlU3RhdGUgYXMgJGpjSU93JHVzZVN0YXRlLCB1c2VSZWYgYXMgJGpjSU93JHVzZVJlZiwgdXNlRWZmZWN0IGFzICRqY0lPdyR1c2VFZmZlY3R9IGZyb20gXCJyZWFjdFwiO1xyXG5cclxuLypcclxuICogQ29weXJpZ2h0IDIwMjMgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcclxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXHJcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxyXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi8gLypcclxuICogQ29weXJpZ2h0IDIwMjMgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcclxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXHJcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxyXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi8gXHJcbmNvbnN0ICRlNWJlMjAwYzY3NWMzYjNhJGV4cG9ydCRhY2E5NThjNjVjMzE0ZTZjID0ge1xyXG4gICAgYmFkSW5wdXQ6IGZhbHNlLFxyXG4gICAgY3VzdG9tRXJyb3I6IGZhbHNlLFxyXG4gICAgcGF0dGVybk1pc21hdGNoOiBmYWxzZSxcclxuICAgIHJhbmdlT3ZlcmZsb3c6IGZhbHNlLFxyXG4gICAgcmFuZ2VVbmRlcmZsb3c6IGZhbHNlLFxyXG4gICAgc3RlcE1pc21hdGNoOiBmYWxzZSxcclxuICAgIHRvb0xvbmc6IGZhbHNlLFxyXG4gICAgdG9vU2hvcnQ6IGZhbHNlLFxyXG4gICAgdHlwZU1pc21hdGNoOiBmYWxzZSxcclxuICAgIHZhbHVlTWlzc2luZzogZmFsc2UsXHJcbiAgICB2YWxpZDogdHJ1ZVxyXG59O1xyXG5jb25zdCAkZTViZTIwMGM2NzVjM2IzYSR2YXIkQ1VTVE9NX1ZBTElESVRZX1NUQVRFID0ge1xyXG4gICAgLi4uJGU1YmUyMDBjNjc1YzNiM2EkZXhwb3J0JGFjYTk1OGM2NWMzMTRlNmMsXHJcbiAgICBjdXN0b21FcnJvcjogdHJ1ZSxcclxuICAgIHZhbGlkOiBmYWxzZVxyXG59O1xyXG5jb25zdCAkZTViZTIwMGM2NzVjM2IzYSRleHBvcnQkZGFkNmFlODQ0NTZjNjc2YSA9IHtcclxuICAgIGlzSW52YWxpZDogZmFsc2UsXHJcbiAgICB2YWxpZGF0aW9uRGV0YWlsczogJGU1YmUyMDBjNjc1YzNiM2EkZXhwb3J0JGFjYTk1OGM2NWMzMTRlNmMsXHJcbiAgICB2YWxpZGF0aW9uRXJyb3JzOiBbXVxyXG59O1xyXG5jb25zdCAkZTViZTIwMGM2NzVjM2IzYSRleHBvcnQkNTcxYjUxMzFiN2U2NWMxMSA9ICgwLCAkamNJT3ckY3JlYXRlQ29udGV4dCkoe30pO1xyXG5jb25zdCAkZTViZTIwMGM2NzVjM2IzYSRleHBvcnQkYTc2M2I5NDc2YWNkM2ViID0gXCJfX2Zvcm1WYWxpZGF0aW9uU3RhdGVcIiArIERhdGUubm93KCk7XHJcbmZ1bmN0aW9uICRlNWJlMjAwYzY3NWMzYjNhJGV4cG9ydCRmYzFhMzY0YWUxZjNmZjEwKHByb3BzKSB7XHJcbiAgICAvLyBQcml2YXRlIHByb3AgZm9yIHBhcmVudCBjb21wb25lbnRzIHRvIHBhc3Mgc3RhdGUgdG8gY2hpbGRyZW4uXHJcbiAgICBpZiAocHJvcHNbJGU1YmUyMDBjNjc1YzNiM2EkZXhwb3J0JGE3NjNiOTQ3NmFjZDNlYl0pIHtcclxuICAgICAgICBsZXQgeyByZWFsdGltZVZhbGlkYXRpb246IHJlYWx0aW1lVmFsaWRhdGlvbiwgZGlzcGxheVZhbGlkYXRpb246IGRpc3BsYXlWYWxpZGF0aW9uLCB1cGRhdGVWYWxpZGF0aW9uOiB1cGRhdGVWYWxpZGF0aW9uLCByZXNldFZhbGlkYXRpb246IHJlc2V0VmFsaWRhdGlvbiwgY29tbWl0VmFsaWRhdGlvbjogY29tbWl0VmFsaWRhdGlvbiB9ID0gcHJvcHNbJGU1YmUyMDBjNjc1YzNiM2EkZXhwb3J0JGE3NjNiOTQ3NmFjZDNlYl07XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcmVhbHRpbWVWYWxpZGF0aW9uOiByZWFsdGltZVZhbGlkYXRpb24sXHJcbiAgICAgICAgICAgIGRpc3BsYXlWYWxpZGF0aW9uOiBkaXNwbGF5VmFsaWRhdGlvbixcclxuICAgICAgICAgICAgdXBkYXRlVmFsaWRhdGlvbjogdXBkYXRlVmFsaWRhdGlvbixcclxuICAgICAgICAgICAgcmVzZXRWYWxpZGF0aW9uOiByZXNldFZhbGlkYXRpb24sXHJcbiAgICAgICAgICAgIGNvbW1pdFZhbGlkYXRpb246IGNvbW1pdFZhbGlkYXRpb25cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXHJcbiAgICByZXR1cm4gJGU1YmUyMDBjNjc1YzNiM2EkdmFyJHVzZUZvcm1WYWxpZGF0aW9uU3RhdGVJbXBsKHByb3BzKTtcclxufVxyXG5mdW5jdGlvbiAkZTViZTIwMGM2NzVjM2IzYSR2YXIkdXNlRm9ybVZhbGlkYXRpb25TdGF0ZUltcGwocHJvcHMpIHtcclxuICAgIGxldCB7IGlzSW52YWxpZDogaXNJbnZhbGlkLCB2YWxpZGF0aW9uU3RhdGU6IHZhbGlkYXRpb25TdGF0ZSwgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlLCBidWlsdGluVmFsaWRhdGlvbjogYnVpbHRpblZhbGlkYXRpb24sIHZhbGlkYXRlOiB2YWxpZGF0ZSwgdmFsaWRhdGlvbkJlaGF2aW9yOiB2YWxpZGF0aW9uQmVoYXZpb3IgPSBcImFyaWFcIiB9ID0gcHJvcHM7XHJcbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LlxyXG4gICAgaWYgKHZhbGlkYXRpb25TdGF0ZSkgaXNJbnZhbGlkIHx8IChpc0ludmFsaWQgPSB2YWxpZGF0aW9uU3RhdGUgPT09IFwiaW52YWxpZFwiKTtcclxuICAgIC8vIElmIHRoZSBpc0ludmFsaWQgcHJvcCBpcyB0cnVlLCB1cGRhdGUgdmFsaWRhdGlvbiByZXN1bHQgaW4gcmVhbHRpbWUgKGNvbnRyb2xsZWQpLlxyXG4gICAgbGV0IGNvbnRyb2xsZWRFcnJvciA9IGlzSW52YWxpZCA/IHtcclxuICAgICAgICBpc0ludmFsaWQ6IHRydWUsXHJcbiAgICAgICAgdmFsaWRhdGlvbkVycm9yczogW10sXHJcbiAgICAgICAgdmFsaWRhdGlvbkRldGFpbHM6ICRlNWJlMjAwYzY3NWMzYjNhJHZhciRDVVNUT01fVkFMSURJVFlfU1RBVEVcclxuICAgIH0gOiBudWxsO1xyXG4gICAgLy8gUGVyZm9ybSBjdXN0b20gY2xpZW50IHNpZGUgdmFsaWRhdGlvbi5cclxuICAgIGxldCBjbGllbnRFcnJvciA9ICgwLCAkamNJT3ckdXNlTWVtbykoKCk9PiRlNWJlMjAwYzY3NWMzYjNhJHZhciRnZXRWYWxpZGF0aW9uUmVzdWx0KCRlNWJlMjAwYzY3NWMzYjNhJHZhciRydW5WYWxpZGF0ZSh2YWxpZGF0ZSwgdmFsdWUpKSwgW1xyXG4gICAgICAgIHZhbGlkYXRlLFxyXG4gICAgICAgIHZhbHVlXHJcbiAgICBdKTtcclxuICAgIGlmIChidWlsdGluVmFsaWRhdGlvbiA9PT0gbnVsbCB8fCBidWlsdGluVmFsaWRhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogYnVpbHRpblZhbGlkYXRpb24udmFsaWRhdGlvbkRldGFpbHMudmFsaWQpIGJ1aWx0aW5WYWxpZGF0aW9uID0gbnVsbDtcclxuICAgIC8vIEdldCByZWxldmFudCBzZXJ2ZXIgZXJyb3JzIGZyb20gdGhlIGZvcm0uXHJcbiAgICBsZXQgc2VydmVyRXJyb3JzID0gKDAsICRqY0lPdyR1c2VDb250ZXh0KSgkZTViZTIwMGM2NzVjM2IzYSRleHBvcnQkNTcxYjUxMzFiN2U2NWMxMSk7XHJcbiAgICBsZXQgc2VydmVyRXJyb3JNZXNzYWdlcyA9ICgwLCAkamNJT3ckdXNlTWVtbykoKCk9PntcclxuICAgICAgICBpZiAobmFtZSkgcmV0dXJuIEFycmF5LmlzQXJyYXkobmFtZSkgPyBuYW1lLmZsYXRNYXAoKG5hbWUpPT4kZTViZTIwMGM2NzVjM2IzYSR2YXIkYXNBcnJheShzZXJ2ZXJFcnJvcnNbbmFtZV0pKSA6ICRlNWJlMjAwYzY3NWMzYjNhJHZhciRhc0FycmF5KHNlcnZlckVycm9yc1tuYW1lXSk7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfSwgW1xyXG4gICAgICAgIHNlcnZlckVycm9ycyxcclxuICAgICAgICBuYW1lXHJcbiAgICBdKTtcclxuICAgIC8vIFNob3cgc2VydmVyIGVycm9ycyB3aGVuIHRoZSBmb3JtIGdldHMgYSBuZXcgdmFsdWUsIGFuZCBjbGVhciB3aGVuIHRoZSB1c2VyIGNoYW5nZXMgdGhlIHZhbHVlLlxyXG4gICAgbGV0IFtsYXN0U2VydmVyRXJyb3JzLCBzZXRMYXN0U2VydmVyRXJyb3JzXSA9ICgwLCAkamNJT3ckdXNlU3RhdGUpKHNlcnZlckVycm9ycyk7XHJcbiAgICBsZXQgW2lzU2VydmVyRXJyb3JDbGVhcmVkLCBzZXRTZXJ2ZXJFcnJvckNsZWFyZWRdID0gKDAsICRqY0lPdyR1c2VTdGF0ZSkoZmFsc2UpO1xyXG4gICAgaWYgKHNlcnZlckVycm9ycyAhPT0gbGFzdFNlcnZlckVycm9ycykge1xyXG4gICAgICAgIHNldExhc3RTZXJ2ZXJFcnJvcnMoc2VydmVyRXJyb3JzKTtcclxuICAgICAgICBzZXRTZXJ2ZXJFcnJvckNsZWFyZWQoZmFsc2UpO1xyXG4gICAgfVxyXG4gICAgbGV0IHNlcnZlckVycm9yID0gKDAsICRqY0lPdyR1c2VNZW1vKSgoKT0+JGU1YmUyMDBjNjc1YzNiM2EkdmFyJGdldFZhbGlkYXRpb25SZXN1bHQoaXNTZXJ2ZXJFcnJvckNsZWFyZWQgPyBbXSA6IHNlcnZlckVycm9yTWVzc2FnZXMpLCBbXHJcbiAgICAgICAgaXNTZXJ2ZXJFcnJvckNsZWFyZWQsXHJcbiAgICAgICAgc2VydmVyRXJyb3JNZXNzYWdlc1xyXG4gICAgXSk7XHJcbiAgICAvLyBUcmFjayB0aGUgbmV4dCB2YWxpZGF0aW9uIHN0YXRlIGluIGEgcmVmIHVudGlsIGNvbW1pdFZhbGlkYXRpb24gaXMgY2FsbGVkLlxyXG4gICAgbGV0IG5leHRWYWxpZGF0aW9uID0gKDAsICRqY0lPdyR1c2VSZWYpKCRlNWJlMjAwYzY3NWMzYjNhJGV4cG9ydCRkYWQ2YWU4NDQ1NmM2NzZhKTtcclxuICAgIGxldCBbY3VycmVudFZhbGlkaXR5LCBzZXRDdXJyZW50VmFsaWRpdHldID0gKDAsICRqY0lPdyR1c2VTdGF0ZSkoJGU1YmUyMDBjNjc1YzNiM2EkZXhwb3J0JGRhZDZhZTg0NDU2YzY3NmEpO1xyXG4gICAgbGV0IGxhc3RFcnJvciA9ICgwLCAkamNJT3ckdXNlUmVmKSgkZTViZTIwMGM2NzVjM2IzYSRleHBvcnQkZGFkNmFlODQ0NTZjNjc2YSk7XHJcbiAgICBsZXQgY29tbWl0VmFsaWRhdGlvbiA9ICgpPT57XHJcbiAgICAgICAgaWYgKCFjb21taXRRdWV1ZWQpIHJldHVybjtcclxuICAgICAgICBzZXRDb21taXRRdWV1ZWQoZmFsc2UpO1xyXG4gICAgICAgIGxldCBlcnJvciA9IGNsaWVudEVycm9yIHx8IGJ1aWx0aW5WYWxpZGF0aW9uIHx8IG5leHRWYWxpZGF0aW9uLmN1cnJlbnQ7XHJcbiAgICAgICAgaWYgKCEkZTViZTIwMGM2NzVjM2IzYSR2YXIkaXNFcXVhbFZhbGlkYXRpb24oZXJyb3IsIGxhc3RFcnJvci5jdXJyZW50KSkge1xyXG4gICAgICAgICAgICBsYXN0RXJyb3IuY3VycmVudCA9IGVycm9yO1xyXG4gICAgICAgICAgICBzZXRDdXJyZW50VmFsaWRpdHkoZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBsZXQgW2NvbW1pdFF1ZXVlZCwgc2V0Q29tbWl0UXVldWVkXSA9ICgwLCAkamNJT3ckdXNlU3RhdGUpKGZhbHNlKTtcclxuICAgICgwLCAkamNJT3ckdXNlRWZmZWN0KShjb21taXRWYWxpZGF0aW9uKTtcclxuICAgIC8vIHJlYWx0aW1lVmFsaWRhdGlvbiBpcyB1c2VkIHRvIHVwZGF0ZSB0aGUgbmF0aXZlIGlucHV0IGVsZW1lbnQncyBzdGF0ZSBiYXNlZCBvbiBjdXN0b20gdmFsaWRhdGlvbiBsb2dpYy5cclxuICAgIC8vIGRpc3BsYXlWYWxpZGF0aW9uIGlzIHRoZSBjdXJyZW50bHkgZGlzcGxheWVkIHZhbGlkYXRpb24gc3RhdGUgdGhhdCB0aGUgdXNlciBzZWVzIChlLmcuIG9uIGlucHV0IGNoYW5nZS9mb3JtIHN1Ym1pdCkuXHJcbiAgICAvLyBXaXRoIHZhbGlkYXRpb25CZWhhdmlvcj1cImFyaWFcIiwgYWxsIGVycm9ycyBhcmUgZGlzcGxheWVkIGluIHJlYWx0aW1lIHJhdGhlciB0aGFuIG9uIHN1Ym1pdC5cclxuICAgIGxldCByZWFsdGltZVZhbGlkYXRpb24gPSBjb250cm9sbGVkRXJyb3IgfHwgc2VydmVyRXJyb3IgfHwgY2xpZW50RXJyb3IgfHwgYnVpbHRpblZhbGlkYXRpb24gfHwgJGU1YmUyMDBjNjc1YzNiM2EkZXhwb3J0JGRhZDZhZTg0NDU2YzY3NmE7XHJcbiAgICBsZXQgZGlzcGxheVZhbGlkYXRpb24gPSB2YWxpZGF0aW9uQmVoYXZpb3IgPT09IFwibmF0aXZlXCIgPyBjb250cm9sbGVkRXJyb3IgfHwgc2VydmVyRXJyb3IgfHwgY3VycmVudFZhbGlkaXR5IDogY29udHJvbGxlZEVycm9yIHx8IHNlcnZlckVycm9yIHx8IGNsaWVudEVycm9yIHx8IGJ1aWx0aW5WYWxpZGF0aW9uIHx8IGN1cnJlbnRWYWxpZGl0eTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVhbHRpbWVWYWxpZGF0aW9uOiByZWFsdGltZVZhbGlkYXRpb24sXHJcbiAgICAgICAgZGlzcGxheVZhbGlkYXRpb246IGRpc3BsYXlWYWxpZGF0aW9uLFxyXG4gICAgICAgIHVwZGF0ZVZhbGlkYXRpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIC8vIElmIHZhbGlkYXRpb25CZWhhdmlvciBpcyAnYXJpYScsIHVwZGF0ZSBpbiByZWFsdGltZS4gT3RoZXJ3aXNlLCBzdG9yZSBpbiBhIHJlZiB1bnRpbCBjb21taXQuXHJcbiAgICAgICAgICAgIGlmICh2YWxpZGF0aW9uQmVoYXZpb3IgPT09IFwiYXJpYVwiICYmICEkZTViZTIwMGM2NzVjM2IzYSR2YXIkaXNFcXVhbFZhbGlkYXRpb24oY3VycmVudFZhbGlkaXR5LCB2YWx1ZSkpIHNldEN1cnJlbnRWYWxpZGl0eSh2YWx1ZSk7XHJcbiAgICAgICAgICAgIGVsc2UgbmV4dFZhbGlkYXRpb24uY3VycmVudCA9IHZhbHVlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVzZXRWYWxpZGF0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBjdXJyZW50bHkgZGlzcGxheWVkIHZhbGlkYXRpb24gc3RhdGUgdG8gdmFsaWQgb24gZm9ybSByZXNldCxcclxuICAgICAgICAgICAgLy8gZXZlbiBpZiB0aGUgbmF0aXZlIHZhbGlkaXR5IHNheXMgaXQgaXNuJ3QuIEl0J2xsIHNob3cgYWdhaW4gb24gdGhlIG5leHQgZm9ybSBzdWJtaXQuXHJcbiAgICAgICAgICAgIGxldCBlcnJvciA9ICRlNWJlMjAwYzY3NWMzYjNhJGV4cG9ydCRkYWQ2YWU4NDQ1NmM2NzZhO1xyXG4gICAgICAgICAgICBpZiAoISRlNWJlMjAwYzY3NWMzYjNhJHZhciRpc0VxdWFsVmFsaWRhdGlvbihlcnJvciwgbGFzdEVycm9yLmN1cnJlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICBsYXN0RXJyb3IuY3VycmVudCA9IGVycm9yO1xyXG4gICAgICAgICAgICAgICAgc2V0Q3VycmVudFZhbGlkaXR5KGVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBEbyBub3QgY29tbWl0IHZhbGlkYXRpb24gYWZ0ZXIgdGhlIG5leHQgcmVuZGVyLiBUaGlzIGF2b2lkcyBhIGNvbmRpdGlvbiB3aGVyZVxyXG4gICAgICAgICAgICAvLyB1c2VTZWxlY3QgY2FsbHMgY29tbWl0VmFsaWRhdGlvbiBpbnNpZGUgYW4gb25SZXNldCBoYW5kbGVyLlxyXG4gICAgICAgICAgICBpZiAodmFsaWRhdGlvbkJlaGF2aW9yID09PSBcIm5hdGl2ZVwiKSBzZXRDb21taXRRdWV1ZWQoZmFsc2UpO1xyXG4gICAgICAgICAgICBzZXRTZXJ2ZXJFcnJvckNsZWFyZWQodHJ1ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjb21taXRWYWxpZGF0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8gQ29tbWl0IHZhbGlkYXRpb24gc3RhdGUgc28gdGhlIHVzZXIgc2VlcyBpdCBvbiBibHVyL2NoYW5nZS9zdWJtaXQuIEFsc28gY2xlYXIgYW55IHNlcnZlciBlcnJvcnMuXHJcbiAgICAgICAgICAgIC8vIFdhaXQgdW50aWwgYWZ0ZXIgdGhlIG5leHQgcmVuZGVyIHRvIGNvbW1pdCBzbyB0aGF0IHRoZSBsYXRlc3QgdmFsdWUgaGFzIGJlZW4gdmFsaWRhdGVkLlxyXG4gICAgICAgICAgICBpZiAodmFsaWRhdGlvbkJlaGF2aW9yID09PSBcIm5hdGl2ZVwiKSBzZXRDb21taXRRdWV1ZWQodHJ1ZSk7XHJcbiAgICAgICAgICAgIHNldFNlcnZlckVycm9yQ2xlYXJlZCh0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uICRlNWJlMjAwYzY3NWMzYjNhJHZhciRhc0FycmF5KHYpIHtcclxuICAgIGlmICghdikgcmV0dXJuIFtdO1xyXG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodikgPyB2IDogW1xyXG4gICAgICAgIHZcclxuICAgIF07XHJcbn1cclxuZnVuY3Rpb24gJGU1YmUyMDBjNjc1YzNiM2EkdmFyJHJ1blZhbGlkYXRlKHZhbGlkYXRlLCB2YWx1ZSkge1xyXG4gICAgaWYgKHR5cGVvZiB2YWxpZGF0ZSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgbGV0IGUgPSB2YWxpZGF0ZSh2YWx1ZSk7XHJcbiAgICAgICAgaWYgKGUgJiYgdHlwZW9mIGUgIT09IFwiYm9vbGVhblwiKSByZXR1cm4gJGU1YmUyMDBjNjc1YzNiM2EkdmFyJGFzQXJyYXkoZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gW107XHJcbn1cclxuZnVuY3Rpb24gJGU1YmUyMDBjNjc1YzNiM2EkdmFyJGdldFZhbGlkYXRpb25SZXN1bHQoZXJyb3JzKSB7XHJcbiAgICByZXR1cm4gZXJyb3JzLmxlbmd0aCA/IHtcclxuICAgICAgICBpc0ludmFsaWQ6IHRydWUsXHJcbiAgICAgICAgdmFsaWRhdGlvbkVycm9yczogZXJyb3JzLFxyXG4gICAgICAgIHZhbGlkYXRpb25EZXRhaWxzOiAkZTViZTIwMGM2NzVjM2IzYSR2YXIkQ1VTVE9NX1ZBTElESVRZX1NUQVRFXHJcbiAgICB9IDogbnVsbDtcclxufVxyXG5mdW5jdGlvbiAkZTViZTIwMGM2NzVjM2IzYSR2YXIkaXNFcXVhbFZhbGlkYXRpb24oYSwgYikge1xyXG4gICAgaWYgKGEgPT09IGIpIHJldHVybiB0cnVlO1xyXG4gICAgcmV0dXJuIGEgJiYgYiAmJiBhLmlzSW52YWxpZCA9PT0gYi5pc0ludmFsaWQgJiYgYS52YWxpZGF0aW9uRXJyb3JzLmxlbmd0aCA9PT0gYi52YWxpZGF0aW9uRXJyb3JzLmxlbmd0aCAmJiBhLnZhbGlkYXRpb25FcnJvcnMuZXZlcnkoKGEsIGkpPT5hID09PSBiLnZhbGlkYXRpb25FcnJvcnNbaV0pICYmIE9iamVjdC5lbnRyaWVzKGEudmFsaWRhdGlvbkRldGFpbHMpLmV2ZXJ5KChbaywgdl0pPT5iLnZhbGlkYXRpb25EZXRhaWxzW2tdID09PSB2KTtcclxufVxyXG5mdW5jdGlvbiAkZTViZTIwMGM2NzVjM2IzYSRleHBvcnQkNzVlZTdjNzVkNjhmNWIwZSguLi5yZXN1bHRzKSB7XHJcbiAgICBsZXQgZXJyb3JzID0gbmV3IFNldCgpO1xyXG4gICAgbGV0IGlzSW52YWxpZCA9IGZhbHNlO1xyXG4gICAgbGV0IHZhbGlkYXRpb25EZXRhaWxzID0ge1xyXG4gICAgICAgIC4uLiRlNWJlMjAwYzY3NWMzYjNhJGV4cG9ydCRhY2E5NThjNjVjMzE0ZTZjXHJcbiAgICB9O1xyXG4gICAgZm9yIChsZXQgdiBvZiByZXN1bHRzKXtcclxuICAgICAgICB2YXIgX3ZhbGlkYXRpb25EZXRhaWxzLCBfa2V5O1xyXG4gICAgICAgIGZvciAobGV0IGUgb2Ygdi52YWxpZGF0aW9uRXJyb3JzKWVycm9ycy5hZGQoZSk7XHJcbiAgICAgICAgLy8gT25seSB0aGVzZSBwcm9wZXJ0aWVzIGFwcGx5IGZvciBjaGVja2JveGVzLlxyXG4gICAgICAgIGlzSW52YWxpZCB8fCAoaXNJbnZhbGlkID0gdi5pc0ludmFsaWQpO1xyXG4gICAgICAgIGZvcihsZXQga2V5IGluIHZhbGlkYXRpb25EZXRhaWxzKShfdmFsaWRhdGlvbkRldGFpbHMgPSB2YWxpZGF0aW9uRGV0YWlscylbX2tleSA9IGtleV0gfHwgKF92YWxpZGF0aW9uRGV0YWlsc1tfa2V5XSA9IHYudmFsaWRhdGlvbkRldGFpbHNba2V5XSk7XHJcbiAgICB9XHJcbiAgICB2YWxpZGF0aW9uRGV0YWlscy52YWxpZCA9ICFpc0ludmFsaWQ7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGlzSW52YWxpZDogaXNJbnZhbGlkLFxyXG4gICAgICAgIHZhbGlkYXRpb25FcnJvcnM6IFtcclxuICAgICAgICAgICAgLi4uZXJyb3JzXHJcbiAgICAgICAgXSxcclxuICAgICAgICB2YWxpZGF0aW9uRGV0YWlsczogdmFsaWRhdGlvbkRldGFpbHNcclxuICAgIH07XHJcbn1cclxuXHJcblxyXG5cclxuXHJcbmV4cG9ydCB7JGU1YmUyMDBjNjc1YzNiM2EkZXhwb3J0JDU3MWI1MTMxYjdlNjVjMTEgYXMgRm9ybVZhbGlkYXRpb25Db250ZXh0LCAkZTViZTIwMGM2NzVjM2IzYSRleHBvcnQkZmMxYTM2NGFlMWYzZmYxMCBhcyB1c2VGb3JtVmFsaWRhdGlvblN0YXRlLCAkZTViZTIwMGM2NzVjM2IzYSRleHBvcnQkZGFkNmFlODQ0NTZjNjc2YSBhcyBERUZBVUxUX1ZBTElEQVRJT05fUkVTVUxULCAkZTViZTIwMGM2NzVjM2IzYSRleHBvcnQkYWNhOTU4YzY1YzMxNGU2YyBhcyBWQUxJRF9WQUxJRElUWV9TVEFURSwgJGU1YmUyMDBjNjc1YzNiM2EkZXhwb3J0JGE3NjNiOTQ3NmFjZDNlYiBhcyBwcml2YXRlVmFsaWRhdGlvblN0YXRlUHJvcCwgJGU1YmUyMDBjNjc1YzNiM2EkZXhwb3J0JDc1ZWU3Yzc1ZDY4ZjViMGUgYXMgbWVyZ2VWYWxpZGF0aW9ufTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxlLmpzLm1hcFxyXG4iXSwibmFtZXMiOlsiY3JlYXRlQ29udGV4dCIsIiRqY0lPdyRjcmVhdGVDb250ZXh0IiwidXNlTWVtbyIsIiRqY0lPdyR1c2VNZW1vIiwidXNlQ29udGV4dCIsIiRqY0lPdyR1c2VDb250ZXh0IiwidXNlU3RhdGUiLCIkamNJT3ckdXNlU3RhdGUiLCJ1c2VSZWYiLCIkamNJT3ckdXNlUmVmIiwidXNlRWZmZWN0IiwiJGpjSU93JHVzZUVmZmVjdCIsIiRlNWJlMjAwYzY3NWMzYjNhJGV4cG9ydCRhY2E5NThjNjVjMzE0ZTZjIiwiYmFkSW5wdXQiLCJjdXN0b21FcnJvciIsInBhdHRlcm5NaXNtYXRjaCIsInJhbmdlT3ZlcmZsb3ciLCJyYW5nZVVuZGVyZmxvdyIsInN0ZXBNaXNtYXRjaCIsInRvb0xvbmciLCJ0b29TaG9ydCIsInR5cGVNaXNtYXRjaCIsInZhbHVlTWlzc2luZyIsInZhbGlkIiwiJGU1YmUyMDBjNjc1YzNiM2EkdmFyJENVU1RPTV9WQUxJRElUWV9TVEFURSIsIiRlNWJlMjAwYzY3NWMzYjNhJGV4cG9ydCRkYWQ2YWU4NDQ1NmM2NzZhIiwiaXNJbnZhbGlkIiwidmFsaWRhdGlvbkRldGFpbHMiLCJ2YWxpZGF0aW9uRXJyb3JzIiwiJGU1YmUyMDBjNjc1YzNiM2EkZXhwb3J0JDU3MWI1MTMxYjdlNjVjMTEiLCIkZTViZTIwMGM2NzVjM2IzYSRleHBvcnQkYTc2M2I5NDc2YWNkM2ViIiwiRGF0ZSIsIm5vdyIsIiRlNWJlMjAwYzY3NWMzYjNhJGV4cG9ydCRmYzFhMzY0YWUxZjNmZjEwIiwicHJvcHMiLCJyZWFsdGltZVZhbGlkYXRpb24iLCJkaXNwbGF5VmFsaWRhdGlvbiIsInVwZGF0ZVZhbGlkYXRpb24iLCJyZXNldFZhbGlkYXRpb24iLCJjb21taXRWYWxpZGF0aW9uIiwiJGU1YmUyMDBjNjc1YzNiM2EkdmFyJHVzZUZvcm1WYWxpZGF0aW9uU3RhdGVJbXBsIiwidmFsaWRhdGlvblN0YXRlIiwibmFtZSIsInZhbHVlIiwiYnVpbHRpblZhbGlkYXRpb24iLCJ2YWxpZGF0ZSIsInZhbGlkYXRpb25CZWhhdmlvciIsImNvbnRyb2xsZWRFcnJvciIsImNsaWVudEVycm9yIiwiJGU1YmUyMDBjNjc1YzNiM2EkdmFyJGdldFZhbGlkYXRpb25SZXN1bHQiLCIkZTViZTIwMGM2NzVjM2IzYSR2YXIkcnVuVmFsaWRhdGUiLCJzZXJ2ZXJFcnJvcnMiLCJzZXJ2ZXJFcnJvck1lc3NhZ2VzIiwiQXJyYXkiLCJpc0FycmF5IiwiZmxhdE1hcCIsIiRlNWJlMjAwYzY3NWMzYjNhJHZhciRhc0FycmF5IiwibGFzdFNlcnZlckVycm9ycyIsInNldExhc3RTZXJ2ZXJFcnJvcnMiLCJpc1NlcnZlckVycm9yQ2xlYXJlZCIsInNldFNlcnZlckVycm9yQ2xlYXJlZCIsInNlcnZlckVycm9yIiwibmV4dFZhbGlkYXRpb24iLCJjdXJyZW50VmFsaWRpdHkiLCJzZXRDdXJyZW50VmFsaWRpdHkiLCJsYXN0RXJyb3IiLCJjb21taXRRdWV1ZWQiLCJzZXRDb21taXRRdWV1ZWQiLCJlcnJvciIsImN1cnJlbnQiLCIkZTViZTIwMGM2NzVjM2IzYSR2YXIkaXNFcXVhbFZhbGlkYXRpb24iLCJ2IiwiZSIsImVycm9ycyIsImxlbmd0aCIsImEiLCJiIiwiZXZlcnkiLCJpIiwiT2JqZWN0IiwiZW50cmllcyIsImsiLCIkZTViZTIwMGM2NzVjM2IzYSRleHBvcnQkNzVlZTdjNzVkNjhmNWIwZSIsInJlc3VsdHMiLCJTZXQiLCJfdmFsaWRhdGlvbkRldGFpbHMiLCJfa2V5IiwiYWRkIiwia2V5IiwiRm9ybVZhbGlkYXRpb25Db250ZXh0IiwidXNlRm9ybVZhbGlkYXRpb25TdGF0ZSIsIkRFRkFVTFRfVkFMSURBVElPTl9SRVNVTFQiLCJWQUxJRF9WQUxJRElUWV9TVEFURSIsInByaXZhdGVWYWxpZGF0aW9uU3RhdGVQcm9wIiwibWVyZ2VWYWxpZGF0aW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/form/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/grid/dist/import.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@react-stately/grid/dist/import.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GridCollection: () => (/* binding */ $16805b1b18093c5f$export$de3fdf6493c353d),\n/* harmony export */   useGridState: () => (/* binding */ $62967d126f3aa823$export$4007ac09ff9c68ed)\n/* harmony export */ });\n/* harmony import */ var _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-stately/collections */ \"(ssr)/./node_modules/@react-stately/collections/dist/import.mjs\");\n/* harmony import */ var _react_stately_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/selection */ \"(ssr)/./node_modules/@react-stately/selection/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n\n\n/*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ function $62967d126f3aa823$export$4007ac09ff9c68ed(props) {\n    let { collection: collection, focusMode: focusMode } = props;\n    let selectionState = (0, _react_stately_selection__WEBPACK_IMPORTED_MODULE_1__.useMultipleSelectionState)(props);\n    let disabledKeys = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>props.disabledKeys ? new Set(props.disabledKeys) : new Set(), [\n        props.disabledKeys\n    ]);\n    let setFocusedKey = selectionState.setFocusedKey;\n    selectionState.setFocusedKey = (key, child)=>{\n        // If focusMode is cell and an item is focused, focus a child cell instead.\n        if (focusMode === \"cell\" && key != null) {\n            let item = collection.getItem(key);\n            if ((item === null || item === void 0 ? void 0 : item.type) === \"item\") {\n                var _getLastItem, _getFirstItem;\n                let children = (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.getChildNodes)(item, collection);\n                if (child === \"last\") key = (_getLastItem = (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.getLastItem)(children)) === null || _getLastItem === void 0 ? void 0 : _getLastItem.key;\n                else key = (_getFirstItem = (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.getFirstItem)(children)) === null || _getFirstItem === void 0 ? void 0 : _getFirstItem.key;\n            }\n        }\n        setFocusedKey(key, child);\n    };\n    let selectionManager = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>new (0, _react_stately_selection__WEBPACK_IMPORTED_MODULE_1__.SelectionManager)(collection, selectionState), [\n        collection,\n        selectionState\n    ]);\n    // Reset focused key if that item is deleted from the collection.\n    const cachedCollection = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (selectionState.focusedKey != null && !collection.getItem(selectionState.focusedKey)) {\n            const node = cachedCollection.current.getItem(selectionState.focusedKey);\n            const parentNode = node.parentKey != null && (node.type === \"cell\" || node.type === \"rowheader\" || node.type === \"column\") ? cachedCollection.current.getItem(node.parentKey) : node;\n            const cachedRows = cachedCollection.current.rows;\n            const rows = collection.rows;\n            const diff = cachedRows.length - rows.length;\n            let index = Math.min(diff > 1 ? Math.max(parentNode.index - diff + 1, 0) : parentNode.index, rows.length - 1);\n            let newRow;\n            while(index >= 0){\n                if (!selectionManager.isDisabled(rows[index].key) && rows[index].type !== \"headerrow\") {\n                    newRow = rows[index];\n                    break;\n                }\n                // Find next, not disabled row.\n                if (index < rows.length - 1) index++;\n                else {\n                    if (index > parentNode.index) index = parentNode.index;\n                    index--;\n                }\n            }\n            if (newRow) {\n                const childNodes = newRow.hasChildNodes ? [\n                    ...(0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.getChildNodes)(newRow, collection)\n                ] : [];\n                const keyToFocus = newRow.hasChildNodes && parentNode !== node && node.index < childNodes.length ? childNodes[node.index].key : newRow.key;\n                selectionState.setFocusedKey(keyToFocus);\n            } else selectionState.setFocusedKey(null);\n        }\n        cachedCollection.current = collection;\n    }, [\n        collection,\n        selectionManager,\n        selectionState,\n        selectionState.focusedKey\n    ]);\n    return {\n        collection: collection,\n        disabledKeys: disabledKeys,\n        isKeyboardNavigationDisabled: false,\n        selectionManager: selectionManager\n    };\n}\n/*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ class $16805b1b18093c5f$export$de3fdf6493c353d {\n    *[Symbol.iterator]() {\n        yield* [\n            ...this.rows\n        ];\n    }\n    get size() {\n        return [\n            ...this.rows\n        ].length;\n    }\n    getKeys() {\n        return this.keyMap.keys();\n    }\n    getKeyBefore(key) {\n        let node = this.keyMap.get(key);\n        return node ? node.prevKey : null;\n    }\n    getKeyAfter(key) {\n        let node = this.keyMap.get(key);\n        return node ? node.nextKey : null;\n    }\n    getFirstKey() {\n        var _;\n        return (_ = [\n            ...this.rows\n        ][0]) === null || _ === void 0 ? void 0 : _.key;\n    }\n    getLastKey() {\n        var _rows_;\n        let rows = [\n            ...this.rows\n        ];\n        return (_rows_ = rows[rows.length - 1]) === null || _rows_ === void 0 ? void 0 : _rows_.key;\n    }\n    getItem(key) {\n        return this.keyMap.get(key);\n    }\n    at(idx) {\n        const keys = [\n            ...this.getKeys()\n        ];\n        return this.getItem(keys[idx]);\n    }\n    getChildren(key) {\n        let node = this.keyMap.get(key);\n        return (node === null || node === void 0 ? void 0 : node.childNodes) || [];\n    }\n    constructor(opts){\n        this.keyMap = new Map();\n        this.keyMap = new Map();\n        this.columnCount = opts === null || opts === void 0 ? void 0 : opts.columnCount;\n        this.rows = [];\n        let visit = (node)=>{\n            // If the node is the same object as the previous node for the same key,\n            // we can skip this node and its children. We always visit columns though,\n            // because we depend on order to build the columns array.\n            let prevNode = this.keyMap.get(node.key);\n            if (opts.visitNode) node = opts.visitNode(node);\n            this.keyMap.set(node.key, node);\n            let childKeys = new Set();\n            let last;\n            for (let child of node.childNodes){\n                if (child.type === \"cell\" && child.parentKey == null) child.parentKey = node.key;\n                childKeys.add(child.key);\n                if (last) {\n                    last.nextKey = child.key;\n                    child.prevKey = last.key;\n                } else child.prevKey = null;\n                visit(child);\n                last = child;\n            }\n            if (last) last.nextKey = null;\n            // Remove deleted nodes and their children from the key map\n            if (prevNode) {\n                for (let child of prevNode.childNodes)if (!childKeys.has(child.key)) remove(child);\n            }\n        };\n        let remove = (node)=>{\n            this.keyMap.delete(node.key);\n            for (let child of node.childNodes)if (this.keyMap.get(child.key) === child) remove(child);\n        };\n        let last;\n        opts.items.forEach((node, i)=>{\n            let rowNode = {\n                level: 0,\n                key: \"row-\" + i,\n                type: \"row\",\n                value: undefined,\n                hasChildNodes: true,\n                childNodes: [\n                    ...node.childNodes\n                ],\n                rendered: undefined,\n                textValue: undefined,\n                ...node\n            };\n            if (last) {\n                last.nextKey = rowNode.key;\n                rowNode.prevKey = last.key;\n            } else rowNode.prevKey = null;\n            this.rows.push(rowNode);\n            visit(rowNode);\n            last = rowNode;\n        });\n        if (last) last.nextKey = null;\n    }\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvZ3JpZC9kaXN0L2ltcG9ydC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBeUo7QUFDTDtBQUM1QztBQUV4Rzs7Ozs7Ozs7OztDQVVDLEdBR0QsU0FBU2dCLDBDQUEwQ0MsS0FBSztJQUNwRCxJQUFJLEVBQUVDLFlBQVlBLFVBQVUsRUFBRUMsV0FBV0EsU0FBUyxFQUFFLEdBQUdGO0lBQ3ZELElBQUlHLGlCQUFpQixDQUFDLEdBQUdiLCtFQUErQixFQUFHVTtJQUMzRCxJQUFJSSxlQUFlLENBQUMsR0FBR1YsMENBQWEsRUFBRyxJQUFJTSxNQUFNSSxZQUFZLEdBQUcsSUFBSUMsSUFBSUwsTUFBTUksWUFBWSxJQUFJLElBQUlDLE9BQU87UUFDckdMLE1BQU1JLFlBQVk7S0FDckI7SUFDRCxJQUFJRSxnQkFBZ0JILGVBQWVHLGFBQWE7SUFDaERILGVBQWVHLGFBQWEsR0FBRyxDQUFDQyxLQUFLQztRQUNqQywyRUFBMkU7UUFDM0UsSUFBSU4sY0FBYyxVQUFVSyxPQUFPLE1BQU07WUFDckMsSUFBSUUsT0FBT1IsV0FBV1MsT0FBTyxDQUFDSDtZQUM5QixJQUFJLENBQUNFLFNBQVMsUUFBUUEsU0FBUyxLQUFLLElBQUksS0FBSyxJQUFJQSxLQUFLRSxJQUFJLE1BQU0sUUFBUTtnQkFDcEUsSUFBSUMsY0FBY0M7Z0JBQ2xCLElBQUlDLFdBQVcsQ0FBQyxHQUFHOUIscUVBQW1CLEVBQUd5QixNQUFNUjtnQkFDL0MsSUFBSU8sVUFBVSxRQUFRRCxNQUFNLENBQUNLLGVBQWUsQ0FBQyxHQUFHMUIsbUVBQWlCLEVBQUc0QixTQUFRLE1BQU8sUUFBUUYsaUJBQWlCLEtBQUssSUFBSSxLQUFLLElBQUlBLGFBQWFMLEdBQUc7cUJBQ3pJQSxNQUFNLENBQUNNLGdCQUFnQixDQUFDLEdBQUd6QixvRUFBa0IsRUFBRzBCLFNBQVEsTUFBTyxRQUFRRCxrQkFBa0IsS0FBSyxJQUFJLEtBQUssSUFBSUEsY0FBY04sR0FB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Q0FBQzFELE1BQU1ELEdBQUcsR0FBRzRELE9BQU8zRDtZQUNoRjtRQUNKO1FBQ0EsSUFBSTJELFNBQVMsQ0FBQ2pEO1lBQ1YsSUFBSSxDQUFDdUIsTUFBTSxDQUFDMkIsTUFBTSxDQUFDbEQsS0FBS1gsR0FBRztZQUMzQixLQUFLLElBQUlDLFNBQVNVLEtBQUtjLFVBQVUsQ0FBQyxJQUFJLElBQUksQ0FBQ1MsTUFBTSxDQUFDRyxHQUFHLENBQUNwQyxNQUFNRCxHQUFHLE1BQU1DLE9BQU8yRCxPQUFPM0Q7UUFDdkY7UUFDQSxJQUFJd0Q7UUFDSlIsS0FBS2EsS0FBSyxDQUFDQyxPQUFPLENBQUMsQ0FBQ3BELE1BQU1xRDtZQUN0QixJQUFJQyxVQUFVO2dCQUNWQyxPQUFPO2dCQUNQbEUsS0FBSyxTQUFTZ0U7Z0JBQ2Q1RCxNQUFNO2dCQUNOK0QsT0FBT0M7Z0JBQ1AxQyxlQUFlO2dCQUNmRCxZQUFZO3VCQUNMZCxLQUFLYyxVQUFVO2lCQUNyQjtnQkFDRDRDLFVBQVVEO2dCQUNWRSxXQUFXRjtnQkFDWCxHQUFHekQsSUFBSTtZQUNYO1lBQ0EsSUFBSThDLE1BQU07Z0JBQ05BLEtBQUtqQixPQUFPLEdBQUd5QixRQUFRakUsR0FBRztnQkFDMUJpRSxRQUFRM0IsT0FBTyxHQUFHbUIsS0FBS3pELEdBQUc7WUFDOUIsT0FBT2lFLFFBQVEzQixPQUFPLEdBQUc7WUFDekIsSUFBSSxDQUFDdEIsSUFBSSxDQUFDdUQsSUFBSSxDQUFDTjtZQUNmYixNQUFNYTtZQUNOUixPQUFPUTtRQUNYO1FBQ0EsSUFBSVIsTUFBTUEsS0FBS2pCLE9BQU8sR0FBRztJQUM3QjtBQUNKO0FBSytILENBQy9ILGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL2RhbmFtb25uZXh0X3VpLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC1zdGF0ZWx5L2dyaWQvZGlzdC9pbXBvcnQubWpzP2I2YTMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtnZXRDaGlsZE5vZGVzIGFzICRjQW41ZiRnZXRDaGlsZE5vZGVzLCBnZXRMYXN0SXRlbSBhcyAkY0FuNWYkZ2V0TGFzdEl0ZW0sIGdldEZpcnN0SXRlbSBhcyAkY0FuNWYkZ2V0Rmlyc3RJdGVtfSBmcm9tIFwiQHJlYWN0LXN0YXRlbHkvY29sbGVjdGlvbnNcIjtcclxuaW1wb3J0IHt1c2VNdWx0aXBsZVNlbGVjdGlvblN0YXRlIGFzICRjQW41ZiR1c2VNdWx0aXBsZVNlbGVjdGlvblN0YXRlLCBTZWxlY3Rpb25NYW5hZ2VyIGFzICRjQW41ZiRTZWxlY3Rpb25NYW5hZ2VyfSBmcm9tIFwiQHJlYWN0LXN0YXRlbHkvc2VsZWN0aW9uXCI7XHJcbmltcG9ydCB7dXNlTWVtbyBhcyAkY0FuNWYkdXNlTWVtbywgdXNlUmVmIGFzICRjQW41ZiR1c2VSZWYsIHVzZUVmZmVjdCBhcyAkY0FuNWYkdXNlRWZmZWN0fSBmcm9tIFwicmVhY3RcIjtcclxuXHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XHJcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXHJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xyXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcclxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovIFxyXG5cclxuXHJcbmZ1bmN0aW9uICQ2Mjk2N2QxMjZmM2FhODIzJGV4cG9ydCQ0MDA3YWMwOWZmOWM2OGVkKHByb3BzKSB7XHJcbiAgICBsZXQgeyBjb2xsZWN0aW9uOiBjb2xsZWN0aW9uLCBmb2N1c01vZGU6IGZvY3VzTW9kZSB9ID0gcHJvcHM7XHJcbiAgICBsZXQgc2VsZWN0aW9uU3RhdGUgPSAoMCwgJGNBbjVmJHVzZU11bHRpcGxlU2VsZWN0aW9uU3RhdGUpKHByb3BzKTtcclxuICAgIGxldCBkaXNhYmxlZEtleXMgPSAoMCwgJGNBbjVmJHVzZU1lbW8pKCgpPT5wcm9wcy5kaXNhYmxlZEtleXMgPyBuZXcgU2V0KHByb3BzLmRpc2FibGVkS2V5cykgOiBuZXcgU2V0KCksIFtcclxuICAgICAgICBwcm9wcy5kaXNhYmxlZEtleXNcclxuICAgIF0pO1xyXG4gICAgbGV0IHNldEZvY3VzZWRLZXkgPSBzZWxlY3Rpb25TdGF0ZS5zZXRGb2N1c2VkS2V5O1xyXG4gICAgc2VsZWN0aW9uU3RhdGUuc2V0Rm9jdXNlZEtleSA9IChrZXksIGNoaWxkKT0+e1xyXG4gICAgICAgIC8vIElmIGZvY3VzTW9kZSBpcyBjZWxsIGFuZCBhbiBpdGVtIGlzIGZvY3VzZWQsIGZvY3VzIGEgY2hpbGQgY2VsbCBpbnN0ZWFkLlxyXG4gICAgICAgIGlmIChmb2N1c01vZGUgPT09IFwiY2VsbFwiICYmIGtleSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGxldCBpdGVtID0gY29sbGVjdGlvbi5nZXRJdGVtKGtleSk7XHJcbiAgICAgICAgICAgIGlmICgoaXRlbSA9PT0gbnVsbCB8fCBpdGVtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpdGVtLnR5cGUpID09PSBcIml0ZW1cIikge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9nZXRMYXN0SXRlbSwgX2dldEZpcnN0SXRlbTtcclxuICAgICAgICAgICAgICAgIGxldCBjaGlsZHJlbiA9ICgwLCAkY0FuNWYkZ2V0Q2hpbGROb2RlcykoaXRlbSwgY29sbGVjdGlvbik7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQgPT09IFwibGFzdFwiKSBrZXkgPSAoX2dldExhc3RJdGVtID0gKDAsICRjQW41ZiRnZXRMYXN0SXRlbSkoY2hpbGRyZW4pKSA9PT0gbnVsbCB8fCBfZ2V0TGFzdEl0ZW0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nZXRMYXN0SXRlbS5rZXk7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGtleSA9IChfZ2V0Rmlyc3RJdGVtID0gKDAsICRjQW41ZiRnZXRGaXJzdEl0ZW0pKGNoaWxkcmVuKSkgPT09IG51bGwgfHwgX2dldEZpcnN0SXRlbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2dldEZpcnN0SXRlbS5rZXk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0Rm9jdXNlZEtleShrZXksIGNoaWxkKTtcclxuICAgIH07XHJcbiAgICBsZXQgc2VsZWN0aW9uTWFuYWdlciA9ICgwLCAkY0FuNWYkdXNlTWVtbykoKCk9Pm5ldyAoMCwgJGNBbjVmJFNlbGVjdGlvbk1hbmFnZXIpKGNvbGxlY3Rpb24sIHNlbGVjdGlvblN0YXRlKSwgW1xyXG4gICAgICAgIGNvbGxlY3Rpb24sXHJcbiAgICAgICAgc2VsZWN0aW9uU3RhdGVcclxuICAgIF0pO1xyXG4gICAgLy8gUmVzZXQgZm9jdXNlZCBrZXkgaWYgdGhhdCBpdGVtIGlzIGRlbGV0ZWQgZnJvbSB0aGUgY29sbGVjdGlvbi5cclxuICAgIGNvbnN0IGNhY2hlZENvbGxlY3Rpb24gPSAoMCwgJGNBbjVmJHVzZVJlZikobnVsbCk7XHJcbiAgICAoMCwgJGNBbjVmJHVzZUVmZmVjdCkoKCk9PntcclxuICAgICAgICBpZiAoc2VsZWN0aW9uU3RhdGUuZm9jdXNlZEtleSAhPSBudWxsICYmICFjb2xsZWN0aW9uLmdldEl0ZW0oc2VsZWN0aW9uU3RhdGUuZm9jdXNlZEtleSkpIHtcclxuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IGNhY2hlZENvbGxlY3Rpb24uY3VycmVudC5nZXRJdGVtKHNlbGVjdGlvblN0YXRlLmZvY3VzZWRLZXkpO1xyXG4gICAgICAgICAgICBjb25zdCBwYXJlbnROb2RlID0gbm9kZS5wYXJlbnRLZXkgIT0gbnVsbCAmJiAobm9kZS50eXBlID09PSBcImNlbGxcIiB8fCBub2RlLnR5cGUgPT09IFwicm93aGVhZGVyXCIgfHwgbm9kZS50eXBlID09PSBcImNvbHVtblwiKSA/IGNhY2hlZENvbGxlY3Rpb24uY3VycmVudC5nZXRJdGVtKG5vZGUucGFyZW50S2V5KSA6IG5vZGU7XHJcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlZFJvd3MgPSBjYWNoZWRDb2xsZWN0aW9uLmN1cnJlbnQucm93cztcclxuICAgICAgICAgICAgY29uc3Qgcm93cyA9IGNvbGxlY3Rpb24ucm93cztcclxuICAgICAgICAgICAgY29uc3QgZGlmZiA9IGNhY2hlZFJvd3MubGVuZ3RoIC0gcm93cy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGxldCBpbmRleCA9IE1hdGgubWluKGRpZmYgPiAxID8gTWF0aC5tYXgocGFyZW50Tm9kZS5pbmRleCAtIGRpZmYgKyAxLCAwKSA6IHBhcmVudE5vZGUuaW5kZXgsIHJvd3MubGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgICAgIGxldCBuZXdSb3c7XHJcbiAgICAgICAgICAgIHdoaWxlKGluZGV4ID49IDApe1xyXG4gICAgICAgICAgICAgICAgaWYgKCFzZWxlY3Rpb25NYW5hZ2VyLmlzRGlzYWJsZWQocm93c1tpbmRleF0ua2V5KSAmJiByb3dzW2luZGV4XS50eXBlICE9PSBcImhlYWRlcnJvd1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3Um93ID0gcm93c1tpbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBGaW5kIG5leHQsIG5vdCBkaXNhYmxlZCByb3cuXHJcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCByb3dzLmxlbmd0aCAtIDEpIGluZGV4Kys7XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPiBwYXJlbnROb2RlLmluZGV4KSBpbmRleCA9IHBhcmVudE5vZGUuaW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXgtLTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobmV3Um93KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZE5vZGVzID0gbmV3Um93Lmhhc0NoaWxkTm9kZXMgPyBbXHJcbiAgICAgICAgICAgICAgICAgICAgLi4uKDAsICRjQW41ZiRnZXRDaGlsZE5vZGVzKShuZXdSb3csIGNvbGxlY3Rpb24pXHJcbiAgICAgICAgICAgICAgICBdIDogW107XHJcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlUb0ZvY3VzID0gbmV3Um93Lmhhc0NoaWxkTm9kZXMgJiYgcGFyZW50Tm9kZSAhPT0gbm9kZSAmJiBub2RlLmluZGV4IDwgY2hpbGROb2Rlcy5sZW5ndGggPyBjaGlsZE5vZGVzW25vZGUuaW5kZXhdLmtleSA6IG5ld1Jvdy5rZXk7XHJcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25TdGF0ZS5zZXRGb2N1c2VkS2V5KGtleVRvRm9jdXMpO1xyXG4gICAgICAgICAgICB9IGVsc2Ugc2VsZWN0aW9uU3RhdGUuc2V0Rm9jdXNlZEtleShudWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FjaGVkQ29sbGVjdGlvbi5jdXJyZW50ID0gY29sbGVjdGlvbjtcclxuICAgIH0sIFtcclxuICAgICAgICBjb2xsZWN0aW9uLFxyXG4gICAgICAgIHNlbGVjdGlvbk1hbmFnZXIsXHJcbiAgICAgICAgc2VsZWN0aW9uU3RhdGUsXHJcbiAgICAgICAgc2VsZWN0aW9uU3RhdGUuZm9jdXNlZEtleVxyXG4gICAgXSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGNvbGxlY3Rpb246IGNvbGxlY3Rpb24sXHJcbiAgICAgICAgZGlzYWJsZWRLZXlzOiBkaXNhYmxlZEtleXMsXHJcbiAgICAgICAgaXNLZXlib2FyZE5hdmlnYXRpb25EaXNhYmxlZDogZmFsc2UsXHJcbiAgICAgICAgc2VsZWN0aW9uTWFuYWdlcjogc2VsZWN0aW9uTWFuYWdlclxyXG4gICAgfTtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XHJcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXHJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xyXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcclxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovIGNsYXNzICQxNjgwNWIxYjE4MDkzYzVmJGV4cG9ydCRkZTNmZGY2NDkzYzM1M2Qge1xyXG4gICAgKltTeW1ib2wuaXRlcmF0b3JdKCkge1xyXG4gICAgICAgIHlpZWxkKiBbXHJcbiAgICAgICAgICAgIC4uLnRoaXMucm93c1xyXG4gICAgICAgIF07XHJcbiAgICB9XHJcbiAgICBnZXQgc2l6ZSgpIHtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAuLi50aGlzLnJvd3NcclxuICAgICAgICBdLmxlbmd0aDtcclxuICAgIH1cclxuICAgIGdldEtleXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5TWFwLmtleXMoKTtcclxuICAgIH1cclxuICAgIGdldEtleUJlZm9yZShrZXkpIHtcclxuICAgICAgICBsZXQgbm9kZSA9IHRoaXMua2V5TWFwLmdldChrZXkpO1xyXG4gICAgICAgIHJldHVybiBub2RlID8gbm9kZS5wcmV2S2V5IDogbnVsbDtcclxuICAgIH1cclxuICAgIGdldEtleUFmdGVyKGtleSkge1xyXG4gICAgICAgIGxldCBub2RlID0gdGhpcy5rZXlNYXAuZ2V0KGtleSk7XHJcbiAgICAgICAgcmV0dXJuIG5vZGUgPyBub2RlLm5leHRLZXkgOiBudWxsO1xyXG4gICAgfVxyXG4gICAgZ2V0Rmlyc3RLZXkoKSB7XHJcbiAgICAgICAgdmFyIF87XHJcbiAgICAgICAgcmV0dXJuIChfID0gW1xyXG4gICAgICAgICAgICAuLi50aGlzLnJvd3NcclxuICAgICAgICBdWzBdKSA9PT0gbnVsbCB8fCBfID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfLmtleTtcclxuICAgIH1cclxuICAgIGdldExhc3RLZXkoKSB7XHJcbiAgICAgICAgdmFyIF9yb3dzXztcclxuICAgICAgICBsZXQgcm93cyA9IFtcclxuICAgICAgICAgICAgLi4udGhpcy5yb3dzXHJcbiAgICAgICAgXTtcclxuICAgICAgICByZXR1cm4gKF9yb3dzXyA9IHJvd3Nbcm93cy5sZW5ndGggLSAxXSkgPT09IG51bGwgfHwgX3Jvd3NfID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcm93c18ua2V5O1xyXG4gICAgfVxyXG4gICAgZ2V0SXRlbShrZXkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5rZXlNYXAuZ2V0KGtleSk7XHJcbiAgICB9XHJcbiAgICBhdChpZHgpIHtcclxuICAgICAgICBjb25zdCBrZXlzID0gW1xyXG4gICAgICAgICAgICAuLi50aGlzLmdldEtleXMoKVxyXG4gICAgICAgIF07XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SXRlbShrZXlzW2lkeF0pO1xyXG4gICAgfVxyXG4gICAgZ2V0Q2hpbGRyZW4oa2V5KSB7XHJcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLmtleU1hcC5nZXQoa2V5KTtcclxuICAgICAgICByZXR1cm4gKG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm9kZS5jaGlsZE5vZGVzKSB8fCBbXTtcclxuICAgIH1cclxuICAgIGNvbnN0cnVjdG9yKG9wdHMpe1xyXG4gICAgICAgIHRoaXMua2V5TWFwID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMua2V5TWFwID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuY29sdW1uQ291bnQgPSBvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMuY29sdW1uQ291bnQ7XHJcbiAgICAgICAgdGhpcy5yb3dzID0gW107XHJcbiAgICAgICAgbGV0IHZpc2l0ID0gKG5vZGUpPT57XHJcbiAgICAgICAgICAgIC8vIElmIHRoZSBub2RlIGlzIHRoZSBzYW1lIG9iamVjdCBhcyB0aGUgcHJldmlvdXMgbm9kZSBmb3IgdGhlIHNhbWUga2V5LFxyXG4gICAgICAgICAgICAvLyB3ZSBjYW4gc2tpcCB0aGlzIG5vZGUgYW5kIGl0cyBjaGlsZHJlbi4gV2UgYWx3YXlzIHZpc2l0IGNvbHVtbnMgdGhvdWdoLFxyXG4gICAgICAgICAgICAvLyBiZWNhdXNlIHdlIGRlcGVuZCBvbiBvcmRlciB0byBidWlsZCB0aGUgY29sdW1ucyBhcnJheS5cclxuICAgICAgICAgICAgbGV0IHByZXZOb2RlID0gdGhpcy5rZXlNYXAuZ2V0KG5vZGUua2V5KTtcclxuICAgICAgICAgICAgaWYgKG9wdHMudmlzaXROb2RlKSBub2RlID0gb3B0cy52aXNpdE5vZGUobm9kZSk7XHJcbiAgICAgICAgICAgIHRoaXMua2V5TWFwLnNldChub2RlLmtleSwgbm9kZSk7XHJcbiAgICAgICAgICAgIGxldCBjaGlsZEtleXMgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgICAgIGxldCBsYXN0O1xyXG4gICAgICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiBub2RlLmNoaWxkTm9kZXMpe1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IFwiY2VsbFwiICYmIGNoaWxkLnBhcmVudEtleSA9PSBudWxsKSAvLyBpZiBjaGlsZCBpcyBhIGNlbGwgcGFyZW50IGtleSBpc24ndCBhbHJlYWR5IGVzdGFibGlzaGVkIGJ5IHRoZSBjb2xsZWN0aW9uLCBtYXRjaCBjaGlsZCBub2RlIHRvIHBhcmVudCByb3dcclxuICAgICAgICAgICAgICAgIGNoaWxkLnBhcmVudEtleSA9IG5vZGUua2V5O1xyXG4gICAgICAgICAgICAgICAgY2hpbGRLZXlzLmFkZChjaGlsZC5rZXkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxhc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICBsYXN0Lm5leHRLZXkgPSBjaGlsZC5rZXk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQucHJldktleSA9IGxhc3Qua2V5O1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGNoaWxkLnByZXZLZXkgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdmlzaXQoY2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgbGFzdCA9IGNoaWxkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChsYXN0KSBsYXN0Lm5leHRLZXkgPSBudWxsO1xyXG4gICAgICAgICAgICAvLyBSZW1vdmUgZGVsZXRlZCBub2RlcyBhbmQgdGhlaXIgY2hpbGRyZW4gZnJvbSB0aGUga2V5IG1hcFxyXG4gICAgICAgICAgICBpZiAocHJldk5vZGUpIHtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGNoaWxkIG9mIHByZXZOb2RlLmNoaWxkTm9kZXMpaWYgKCFjaGlsZEtleXMuaGFzKGNoaWxkLmtleSkpIHJlbW92ZShjaGlsZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIGxldCByZW1vdmUgPSAobm9kZSk9PntcclxuICAgICAgICAgICAgdGhpcy5rZXlNYXAuZGVsZXRlKG5vZGUua2V5KTtcclxuICAgICAgICAgICAgZm9yIChsZXQgY2hpbGQgb2Ygbm9kZS5jaGlsZE5vZGVzKWlmICh0aGlzLmtleU1hcC5nZXQoY2hpbGQua2V5KSA9PT0gY2hpbGQpIHJlbW92ZShjaGlsZCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBsZXQgbGFzdDtcclxuICAgICAgICBvcHRzLml0ZW1zLmZvckVhY2goKG5vZGUsIGkpPT57XHJcbiAgICAgICAgICAgIGxldCByb3dOb2RlID0ge1xyXG4gICAgICAgICAgICAgICAgbGV2ZWw6IDAsXHJcbiAgICAgICAgICAgICAgICBrZXk6IFwicm93LVwiICsgaSxcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwicm93XCIsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgaGFzQ2hpbGROb2RlczogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGNoaWxkTm9kZXM6IFtcclxuICAgICAgICAgICAgICAgICAgICAuLi5ub2RlLmNoaWxkTm9kZXNcclxuICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgICAgICByZW5kZXJlZDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgdGV4dFZhbHVlOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICAuLi5ub2RlXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGlmIChsYXN0KSB7XHJcbiAgICAgICAgICAgICAgICBsYXN0Lm5leHRLZXkgPSByb3dOb2RlLmtleTtcclxuICAgICAgICAgICAgICAgIHJvd05vZGUucHJldktleSA9IGxhc3Qua2V5O1xyXG4gICAgICAgICAgICB9IGVsc2Ugcm93Tm9kZS5wcmV2S2V5ID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5yb3dzLnB1c2gocm93Tm9kZSk7XHJcbiAgICAgICAgICAgIHZpc2l0KHJvd05vZGUpO1xyXG4gICAgICAgICAgICBsYXN0ID0gcm93Tm9kZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAobGFzdCkgbGFzdC5uZXh0S2V5ID0gbnVsbDtcclxuICAgIH1cclxufVxyXG5cclxuXHJcblxyXG5cclxuZXhwb3J0IHskNjI5NjdkMTI2ZjNhYTgyMyRleHBvcnQkNDAwN2FjMDlmZjljNjhlZCBhcyB1c2VHcmlkU3RhdGUsICQxNjgwNWIxYjE4MDkzYzVmJGV4cG9ydCRkZTNmZGY2NDkzYzM1M2QgYXMgR3JpZENvbGxlY3Rpb259O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGUuanMubWFwXHJcbiJdLCJuYW1lcyI6WyJnZXRDaGlsZE5vZGVzIiwiJGNBbjVmJGdldENoaWxkTm9kZXMiLCJnZXRMYXN0SXRlbSIsIiRjQW41ZiRnZXRMYXN0SXRlbSIsImdldEZpcnN0SXRlbSIsIiRjQW41ZiRnZXRGaXJzdEl0ZW0iLCJ1c2VNdWx0aXBsZVNlbGVjdGlvblN0YXRlIiwiJGNBbjVmJHVzZU11bHRpcGxlU2VsZWN0aW9uU3RhdGUiLCJTZWxlY3Rpb25NYW5hZ2VyIiwiJGNBbjVmJFNlbGVjdGlvbk1hbmFnZXIiLCJ1c2VNZW1vIiwiJGNBbjVmJHVzZU1lbW8iLCJ1c2VSZWYiLCIkY0FuNWYkdXNlUmVmIiwidXNlRWZmZWN0IiwiJGNBbjVmJHVzZUVmZmVjdCIsIiQ2Mjk2N2QxMjZmM2FhODIzJGV4cG9ydCQ0MDA3YWMwOWZmOWM2OGVkIiwicHJvcHMiLCJjb2xsZWN0aW9uIiwiZm9jdXNNb2RlIiwic2VsZWN0aW9uU3RhdGUiLCJkaXNhYmxlZEtleXMiLCJTZXQiLCJzZXRGb2N1c2VkS2V5Iiwia2V5IiwiY2hpbGQiLCJpdGVtIiwiZ2V0SXRlbSIsInR5cGUiLCJfZ2V0TGFzdEl0ZW0iLCJfZ2V0Rmlyc3RJdGVtIiwiY2hpbGRyZW4iLCJzZWxlY3Rpb25NYW5hZ2VyIiwiY2FjaGVkQ29sbGVjdGlvbiIsImZvY3VzZWRLZXkiLCJub2RlIiwiY3VycmVudCIsInBhcmVudE5vZGUiLCJwYXJlbnRLZXkiLCJjYWNoZWRSb3dzIiwicm93cyIsImRpZmYiLCJsZW5ndGgiLCJpbmRleCIsIk1hdGgiLCJtaW4iLCJtYXgiLCJuZXdSb3ciLCJpc0Rpc2FibGVkIiwiY2hpbGROb2RlcyIsImhhc0NoaWxkTm9kZXMiLCJrZXlUb0ZvY3VzIiwiaXNLZXlib2FyZE5hdmlnYXRpb25EaXNhYmxlZCIsIiQxNjgwNWIxYjE4MDkzYzVmJGV4cG9ydCRkZTNmZGY2NDkzYzM1M2QiLCJTeW1ib2wiLCJpdGVyYXRvciIsInNpemUiLCJnZXRLZXlzIiwia2V5TWFwIiwia2V5cyIsImdldEtleUJlZm9yZSIsImdldCIsInByZXZLZXkiLCJnZXRLZXlBZnRlciIsIm5leHRLZXkiLCJnZXRGaXJzdEtleSIsIl8iLCJnZXRMYXN0S2V5IiwiX3Jvd3NfIiwiYXQiLCJpZHgiLCJnZXRDaGlsZHJlbiIsImNvbnN0cnVjdG9yIiwib3B0cyIsIk1hcCIsImNvbHVtbkNvdW50IiwidmlzaXQiLCJwcmV2Tm9kZSIsInZpc2l0Tm9kZSIsInNldCIsImNoaWxkS2V5cyIsImxhc3QiLCJhZGQiLCJoYXMiLCJyZW1vdmUiLCJkZWxldGUiLCJpdGVtcyIsImZvckVhY2giLCJpIiwicm93Tm9kZSIsImxldmVsIiwidmFsdWUiLCJ1bmRlZmluZWQiLCJyZW5kZXJlZCIsInRleHRWYWx1ZSIsInB1c2giLCJ1c2VHcmlkU3RhdGUiLCJHcmlkQ29sbGVjdGlvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/grid/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/list/dist/import.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@react-stately/list/dist/import.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ListCollection: () => (/* binding */ $a02d57049d202695$export$d085fb9e920b5ca7),\n/* harmony export */   useListState: () => (/* binding */ $e72dd72e1c76a225$export$2f645645f7bca764),\n/* harmony export */   useSingleSelectListState: () => (/* binding */ $a0d645289fe9b86b$export$e7f05e985daf4b5f)\n/* harmony export */ });\n/* harmony import */ var _react_stately_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/selection */ \"(ssr)/./node_modules/@react-stately/selection/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-stately/collections */ \"(ssr)/./node_modules/@react-stately/collections/dist/import.mjs\");\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\");\n\n\n\n\n/*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ /*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ /*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ class $a02d57049d202695$export$d085fb9e920b5ca7 {\n    *[Symbol.iterator]() {\n        yield* this.iterable;\n    }\n    get size() {\n        return this.keyMap.size;\n    }\n    getKeys() {\n        return this.keyMap.keys();\n    }\n    getKeyBefore(key) {\n        let node = this.keyMap.get(key);\n        return node ? node.prevKey : null;\n    }\n    getKeyAfter(key) {\n        let node = this.keyMap.get(key);\n        return node ? node.nextKey : null;\n    }\n    getFirstKey() {\n        return this.firstKey;\n    }\n    getLastKey() {\n        return this.lastKey;\n    }\n    getItem(key) {\n        return this.keyMap.get(key);\n    }\n    at(idx) {\n        const keys = [\n            ...this.getKeys()\n        ];\n        return this.getItem(keys[idx]);\n    }\n    getChildren(key) {\n        let node = this.keyMap.get(key);\n        return (node === null || node === void 0 ? void 0 : node.childNodes) || [];\n    }\n    constructor(nodes){\n        this.keyMap = new Map();\n        this.iterable = nodes;\n        let visit = (node)=>{\n            this.keyMap.set(node.key, node);\n            if (node.childNodes && node.type === \"section\") for (let child of node.childNodes)visit(child);\n        };\n        for (let node of nodes)visit(node);\n        let last;\n        let index = 0;\n        for (let [key, node] of this.keyMap){\n            if (last) {\n                last.nextKey = key;\n                node.prevKey = last.key;\n            } else {\n                this.firstKey = key;\n                node.prevKey = undefined;\n            }\n            if (node.type === \"item\") node.index = index++;\n            last = node;\n            // Set nextKey as undefined since this might be the last node\n            // If it isn't the last node, last.nextKey will properly set at start of new loop\n            last.nextKey = undefined;\n        }\n        this.lastKey = last === null || last === void 0 ? void 0 : last.key;\n    }\n}\nfunction $e72dd72e1c76a225$export$2f645645f7bca764(props) {\n    let { filter: filter } = props;\n    let selectionState = (0, _react_stately_selection__WEBPACK_IMPORTED_MODULE_1__.useMultipleSelectionState)(props);\n    let disabledKeys = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>props.disabledKeys ? new Set(props.disabledKeys) : new Set(), [\n        props.disabledKeys\n    ]);\n    let factory = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((nodes)=>filter ? new (0, $a02d57049d202695$export$d085fb9e920b5ca7)(filter(nodes)) : new (0, $a02d57049d202695$export$d085fb9e920b5ca7)(nodes), [\n        filter\n    ]);\n    let context = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            suppressTextValueWarning: props.suppressTextValueWarning\n        }), [\n        props.suppressTextValueWarning\n    ]);\n    let collection = (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.useCollection)(props, factory, context);\n    let selectionManager = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>new (0, _react_stately_selection__WEBPACK_IMPORTED_MODULE_1__.SelectionManager)(collection, selectionState), [\n        collection,\n        selectionState\n    ]);\n    // Reset focused key if that item is deleted from the collection.\n    const cachedCollection = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (selectionState.focusedKey != null && !collection.getItem(selectionState.focusedKey)) {\n            const startItem = cachedCollection.current.getItem(selectionState.focusedKey);\n            const cachedItemNodes = [\n                ...cachedCollection.current.getKeys()\n            ].map((key)=>{\n                const itemNode = cachedCollection.current.getItem(key);\n                return itemNode.type === \"item\" ? itemNode : null;\n            }).filter((node)=>node !== null);\n            const itemNodes = [\n                ...collection.getKeys()\n            ].map((key)=>{\n                const itemNode = collection.getItem(key);\n                return itemNode.type === \"item\" ? itemNode : null;\n            }).filter((node)=>node !== null);\n            const diff = cachedItemNodes.length - itemNodes.length;\n            let index = Math.min(diff > 1 ? Math.max(startItem.index - diff + 1, 0) : startItem.index, itemNodes.length - 1);\n            let newNode;\n            while(index >= 0){\n                if (!selectionManager.isDisabled(itemNodes[index].key)) {\n                    newNode = itemNodes[index];\n                    break;\n                }\n                // Find next, not disabled item.\n                if (index < itemNodes.length - 1) index++;\n                else {\n                    if (index > startItem.index) index = startItem.index;\n                    index--;\n                }\n            }\n            selectionState.setFocusedKey(newNode ? newNode.key : null);\n        }\n        cachedCollection.current = collection;\n    }, [\n        collection,\n        selectionManager,\n        selectionState,\n        selectionState.focusedKey\n    ]);\n    return {\n        collection: collection,\n        disabledKeys: disabledKeys,\n        selectionManager: selectionManager\n    };\n}\n/*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ function $a0d645289fe9b86b$export$e7f05e985daf4b5f(props) {\n    var _props_defaultSelectedKey;\n    let [selectedKey, setSelectedKey] = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_3__.useControlledState)(props.selectedKey, (_props_defaultSelectedKey = props.defaultSelectedKey) !== null && _props_defaultSelectedKey !== void 0 ? _props_defaultSelectedKey : null, props.onSelectionChange);\n    let selectedKeys = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>selectedKey != null ? [\n            selectedKey\n        ] : [], [\n        selectedKey\n    ]);\n    let { collection: collection, disabledKeys: disabledKeys, selectionManager: selectionManager } = (0, $e72dd72e1c76a225$export$2f645645f7bca764)({\n        ...props,\n        selectionMode: \"single\",\n        disallowEmptySelection: true,\n        allowDuplicateSelectionEvents: true,\n        selectedKeys: selectedKeys,\n        onSelectionChange: (keys)=>{\n            var _keys_values_next_value;\n            let key = (_keys_values_next_value = keys.values().next().value) !== null && _keys_values_next_value !== void 0 ? _keys_values_next_value : null;\n            // Always fire onSelectionChange, even if the key is the same\n            // as the current key (useControlledState does not).\n            if (key === selectedKey && props.onSelectionChange) props.onSelectionChange(key);\n            setSelectedKey(key);\n        }\n    });\n    let selectedItem = selectedKey != null ? collection.getItem(selectedKey) : null;\n    return {\n        collection: collection,\n        disabledKeys: disabledKeys,\n        selectionManager: selectionManager,\n        selectedKey: selectedKey,\n        setSelectedKey: setSelectedKey,\n        selectedItem: selectedItem\n    };\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvbGlzdC9kaXN0L2ltcG9ydC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFvSjtBQUNUO0FBQzFEO0FBQ0k7QUFFckY7Ozs7Ozs7Ozs7Q0FVQyxHQUFHOzs7Ozs7Ozs7O0NBVUgsR0FBRzs7Ozs7Ozs7OztDQVVILEdBQUcsTUFBTWdCO0lBQ04sQ0FBQyxDQUFDQyxPQUFPQyxRQUFRLENBQUMsR0FBRztRQUNqQixPQUFPLElBQUksQ0FBQ0MsUUFBUTtJQUN4QjtJQUNBLElBQUlDLE9BQU87UUFDUCxPQUFPLElBQUksQ0FBQ0MsTUFBTSxDQUFDRCxJQUFJO0lBQzNCO0lBQ0FFLFVBQVU7UUFDTixPQUFPLElBQUksQ0FBQ0QsTUFBTSxDQUFDRSxJQUFJO0lBQzNCO0lBQ0FDLGFBQWFDLEdBQUcsRUFBRTtRQUNkLElBQUlDLE9BQU8sSUFBSSxDQUFDTCxNQUFNLENBQUNNLEdBQUcsQ0FBQ0Y7UUFDM0IsT0FBT0MsT0FBT0EsS0FBS0UsT0FBTyxHQUFHO0lBQ2pDO0lBQ0FDLFlBQVlKLEdBQUcsRUFBRTtRQUNiLElBQUlDLE9BQU8sSUFBSSxDQUFDTCxNQUFNLENBQUNNLEdBQUcsQ0FBQ0Y7UUFDM0IsT0FBT0MsT0FBT0EsS0FBS0ksT0FBTyxHQUFHO0lBQ2pDO0lBQ0FDLGNBQWM7UUFDVixPQUFPLElBQUksQ0FBQ0MsUUFBUTtJQUN4QjtJQUNBQyxhQUFhO1FBQ1QsT0FBTyxJQUFJLENBQUNDLE9BQU87SUFDdkI7SUFDQUMsUUFBUVYsR0FBRyxFQUFFO1FBQ1QsT0FBTyxJQUFJLENBQUNKLE1BQU0sQ0FBQ00sR0FBRyxDQUFDRjtJQUMzQjtJQUNBVyxHQUFHQyxHQUFHLEVBQUU7UUFDSixNQUFNZCxPQUFPO2VBQ04sSUFBSSxDQUFDRCxPQUFPO1NBQ2xCO1FBQ0QsT0FBTyxJQUFJLENBQUNhLE9BQU8sQ0FBQ1osSUFBSSxDQUFDYyxJQUFJO0lBQ2pDO0lBQ0FDLFlBQVliLEdBQUcsRUFBRTtRQUNi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QUFZQTtRQUNaTCxjQUFjQTtRQUNkTSxrQkFBa0JBO1FBQ2xCbUIsYUFBYUE7UUFDYkMsZ0JBQWdCQTtRQUNoQlcsY0FBY0E7SUFDbEI7QUFDSjtBQU11TSxDQUN2TSxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYW5hbW9ubmV4dF91aS8uL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3RhdGVseS9saXN0L2Rpc3QvaW1wb3J0Lm1qcz81MDEzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7dXNlTXVsdGlwbGVTZWxlY3Rpb25TdGF0ZSBhcyAkNThQaHMkdXNlTXVsdGlwbGVTZWxlY3Rpb25TdGF0ZSwgU2VsZWN0aW9uTWFuYWdlciBhcyAkNThQaHMkU2VsZWN0aW9uTWFuYWdlcn0gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L3NlbGVjdGlvblwiO1xyXG5pbXBvcnQge3VzZU1lbW8gYXMgJDU4UGhzJHVzZU1lbW8sIHVzZUNhbGxiYWNrIGFzICQ1OFBocyR1c2VDYWxsYmFjaywgdXNlUmVmIGFzICQ1OFBocyR1c2VSZWYsIHVzZUVmZmVjdCBhcyAkNThQaHMkdXNlRWZmZWN0fSBmcm9tIFwicmVhY3RcIjtcclxuaW1wb3J0IHt1c2VDb2xsZWN0aW9uIGFzICQ1OFBocyR1c2VDb2xsZWN0aW9ufSBmcm9tIFwiQHJlYWN0LXN0YXRlbHkvY29sbGVjdGlvbnNcIjtcclxuaW1wb3J0IHt1c2VDb250cm9sbGVkU3RhdGUgYXMgJDU4UGhzJHVzZUNvbnRyb2xsZWRTdGF0ZX0gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L3V0aWxzXCI7XHJcblxyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxyXG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcclxuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXHJcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqLyAvKlxyXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxyXG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcclxuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXHJcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqLyAvKlxyXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxyXG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcclxuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXHJcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqLyBjbGFzcyAkYTAyZDU3MDQ5ZDIwMjY5NSRleHBvcnQkZDA4NWZiOWU5MjBiNWNhNyB7XHJcbiAgICAqW1N5bWJvbC5pdGVyYXRvcl0oKSB7XHJcbiAgICAgICAgeWllbGQqIHRoaXMuaXRlcmFibGU7XHJcbiAgICB9XHJcbiAgICBnZXQgc2l6ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5rZXlNYXAuc2l6ZTtcclxuICAgIH1cclxuICAgIGdldEtleXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5TWFwLmtleXMoKTtcclxuICAgIH1cclxuICAgIGdldEtleUJlZm9yZShrZXkpIHtcclxuICAgICAgICBsZXQgbm9kZSA9IHRoaXMua2V5TWFwLmdldChrZXkpO1xyXG4gICAgICAgIHJldHVybiBub2RlID8gbm9kZS5wcmV2S2V5IDogbnVsbDtcclxuICAgIH1cclxuICAgIGdldEtleUFmdGVyKGtleSkge1xyXG4gICAgICAgIGxldCBub2RlID0gdGhpcy5rZXlNYXAuZ2V0KGtleSk7XHJcbiAgICAgICAgcmV0dXJuIG5vZGUgPyBub2RlLm5leHRLZXkgOiBudWxsO1xyXG4gICAgfVxyXG4gICAgZ2V0Rmlyc3RLZXkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlyc3RLZXk7XHJcbiAgICB9XHJcbiAgICBnZXRMYXN0S2V5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxhc3RLZXk7XHJcbiAgICB9XHJcbiAgICBnZXRJdGVtKGtleSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmtleU1hcC5nZXQoa2V5KTtcclxuICAgIH1cclxuICAgIGF0KGlkeCkge1xyXG4gICAgICAgIGNvbnN0IGtleXMgPSBbXHJcbiAgICAgICAgICAgIC4uLnRoaXMuZ2V0S2V5cygpXHJcbiAgICAgICAgXTtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRJdGVtKGtleXNbaWR4XSk7XHJcbiAgICB9XHJcbiAgICBnZXRDaGlsZHJlbihrZXkpIHtcclxuICAgICAgICBsZXQgbm9kZSA9IHRoaXMua2V5TWFwLmdldChrZXkpO1xyXG4gICAgICAgIHJldHVybiAobm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2RlLmNoaWxkTm9kZXMpIHx8IFtdO1xyXG4gICAgfVxyXG4gICAgY29uc3RydWN0b3Iobm9kZXMpe1xyXG4gICAgICAgIHRoaXMua2V5TWFwID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuaXRlcmFibGUgPSBub2RlcztcclxuICAgICAgICBsZXQgdmlzaXQgPSAobm9kZSk9PntcclxuICAgICAgICAgICAgdGhpcy5rZXlNYXAuc2V0KG5vZGUua2V5LCBub2RlKTtcclxuICAgICAgICAgICAgaWYgKG5vZGUuY2hpbGROb2RlcyAmJiBub2RlLnR5cGUgPT09IFwic2VjdGlvblwiKSBmb3IgKGxldCBjaGlsZCBvZiBub2RlLmNoaWxkTm9kZXMpdmlzaXQoY2hpbGQpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgZm9yIChsZXQgbm9kZSBvZiBub2Rlcyl2aXNpdChub2RlKTtcclxuICAgICAgICBsZXQgbGFzdDtcclxuICAgICAgICBsZXQgaW5kZXggPSAwO1xyXG4gICAgICAgIGZvciAobGV0IFtrZXksIG5vZGVdIG9mIHRoaXMua2V5TWFwKXtcclxuICAgICAgICAgICAgaWYgKGxhc3QpIHtcclxuICAgICAgICAgICAgICAgIGxhc3QubmV4dEtleSA9IGtleTtcclxuICAgICAgICAgICAgICAgIG5vZGUucHJldktleSA9IGxhc3Qua2V5O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5maXJzdEtleSA9IGtleTtcclxuICAgICAgICAgICAgICAgIG5vZGUucHJldktleSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSBcIml0ZW1cIikgbm9kZS5pbmRleCA9IGluZGV4Kys7XHJcbiAgICAgICAgICAgIGxhc3QgPSBub2RlO1xyXG4gICAgICAgICAgICAvLyBTZXQgbmV4dEtleSBhcyB1bmRlZmluZWQgc2luY2UgdGhpcyBtaWdodCBiZSB0aGUgbGFzdCBub2RlXHJcbiAgICAgICAgICAgIC8vIElmIGl0IGlzbid0IHRoZSBsYXN0IG5vZGUsIGxhc3QubmV4dEtleSB3aWxsIHByb3Blcmx5IHNldCBhdCBzdGFydCBvZiBuZXcgbG9vcFxyXG4gICAgICAgICAgICBsYXN0Lm5leHRLZXkgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubGFzdEtleSA9IGxhc3QgPT09IG51bGwgfHwgbGFzdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGFzdC5rZXk7XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5cclxuXHJcblxyXG5mdW5jdGlvbiAkZTcyZGQ3MmUxYzc2YTIyNSRleHBvcnQkMmY2NDU2NDVmN2JjYTc2NChwcm9wcykge1xyXG4gICAgbGV0IHsgZmlsdGVyOiBmaWx0ZXIgfSA9IHByb3BzO1xyXG4gICAgbGV0IHNlbGVjdGlvblN0YXRlID0gKDAsICQ1OFBocyR1c2VNdWx0aXBsZVNlbGVjdGlvblN0YXRlKShwcm9wcyk7XHJcbiAgICBsZXQgZGlzYWJsZWRLZXlzID0gKDAsICQ1OFBocyR1c2VNZW1vKSgoKT0+cHJvcHMuZGlzYWJsZWRLZXlzID8gbmV3IFNldChwcm9wcy5kaXNhYmxlZEtleXMpIDogbmV3IFNldCgpLCBbXHJcbiAgICAgICAgcHJvcHMuZGlzYWJsZWRLZXlzXHJcbiAgICBdKTtcclxuICAgIGxldCBmYWN0b3J5ID0gKDAsICQ1OFBocyR1c2VDYWxsYmFjaykoKG5vZGVzKT0+ZmlsdGVyID8gbmV3ICgwLCAkYTAyZDU3MDQ5ZDIwMjY5NSRleHBvcnQkZDA4NWZiOWU5MjBiNWNhNykoZmlsdGVyKG5vZGVzKSkgOiBuZXcgKDAsICRhMDJkNTcwNDlkMjAyNjk1JGV4cG9ydCRkMDg1ZmI5ZTkyMGI1Y2E3KShub2RlcyksIFtcclxuICAgICAgICBmaWx0ZXJcclxuICAgIF0pO1xyXG4gICAgbGV0IGNvbnRleHQgPSAoMCwgJDU4UGhzJHVzZU1lbW8pKCgpPT4oe1xyXG4gICAgICAgICAgICBzdXBwcmVzc1RleHRWYWx1ZVdhcm5pbmc6IHByb3BzLnN1cHByZXNzVGV4dFZhbHVlV2FybmluZ1xyXG4gICAgICAgIH0pLCBbXHJcbiAgICAgICAgcHJvcHMuc3VwcHJlc3NUZXh0VmFsdWVXYXJuaW5nXHJcbiAgICBdKTtcclxuICAgIGxldCBjb2xsZWN0aW9uID0gKDAsICQ1OFBocyR1c2VDb2xsZWN0aW9uKShwcm9wcywgZmFjdG9yeSwgY29udGV4dCk7XHJcbiAgICBsZXQgc2VsZWN0aW9uTWFuYWdlciA9ICgwLCAkNThQaHMkdXNlTWVtbykoKCk9Pm5ldyAoMCwgJDU4UGhzJFNlbGVjdGlvbk1hbmFnZXIpKGNvbGxlY3Rpb24sIHNlbGVjdGlvblN0YXRlKSwgW1xyXG4gICAgICAgIGNvbGxlY3Rpb24sXHJcbiAgICAgICAgc2VsZWN0aW9uU3RhdGVcclxuICAgIF0pO1xyXG4gICAgLy8gUmVzZXQgZm9jdXNlZCBrZXkgaWYgdGhhdCBpdGVtIGlzIGRlbGV0ZWQgZnJvbSB0aGUgY29sbGVjdGlvbi5cclxuICAgIGNvbnN0IGNhY2hlZENvbGxlY3Rpb24gPSAoMCwgJDU4UGhzJHVzZVJlZikobnVsbCk7XHJcbiAgICAoMCwgJDU4UGhzJHVzZUVmZmVjdCkoKCk9PntcclxuICAgICAgICBpZiAoc2VsZWN0aW9uU3RhdGUuZm9jdXNlZEtleSAhPSBudWxsICYmICFjb2xsZWN0aW9uLmdldEl0ZW0oc2VsZWN0aW9uU3RhdGUuZm9jdXNlZEtleSkpIHtcclxuICAgICAgICAgICAgY29uc3Qgc3RhcnRJdGVtID0gY2FjaGVkQ29sbGVjdGlvbi5jdXJyZW50LmdldEl0ZW0oc2VsZWN0aW9uU3RhdGUuZm9jdXNlZEtleSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlZEl0ZW1Ob2RlcyA9IFtcclxuICAgICAgICAgICAgICAgIC4uLmNhY2hlZENvbGxlY3Rpb24uY3VycmVudC5nZXRLZXlzKClcclxuICAgICAgICAgICAgXS5tYXAoKGtleSk9PntcclxuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW1Ob2RlID0gY2FjaGVkQ29sbGVjdGlvbi5jdXJyZW50LmdldEl0ZW0oa2V5KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtTm9kZS50eXBlID09PSBcIml0ZW1cIiA/IGl0ZW1Ob2RlIDogbnVsbDtcclxuICAgICAgICAgICAgfSkuZmlsdGVyKChub2RlKT0+bm9kZSAhPT0gbnVsbCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1Ob2RlcyA9IFtcclxuICAgICAgICAgICAgICAgIC4uLmNvbGxlY3Rpb24uZ2V0S2V5cygpXHJcbiAgICAgICAgICAgIF0ubWFwKChrZXkpPT57XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtTm9kZSA9IGNvbGxlY3Rpb24uZ2V0SXRlbShrZXkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1Ob2RlLnR5cGUgPT09IFwiaXRlbVwiID8gaXRlbU5vZGUgOiBudWxsO1xyXG4gICAgICAgICAgICB9KS5maWx0ZXIoKG5vZGUpPT5ub2RlICE9PSBudWxsKTtcclxuICAgICAgICAgICAgY29uc3QgZGlmZiA9IGNhY2hlZEl0ZW1Ob2Rlcy5sZW5ndGggLSBpdGVtTm9kZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICBsZXQgaW5kZXggPSBNYXRoLm1pbihkaWZmID4gMSA/IE1hdGgubWF4KHN0YXJ0SXRlbS5pbmRleCAtIGRpZmYgKyAxLCAwKSA6IHN0YXJ0SXRlbS5pbmRleCwgaXRlbU5vZGVzLmxlbmd0aCAtIDEpO1xyXG4gICAgICAgICAgICBsZXQgbmV3Tm9kZTtcclxuICAgICAgICAgICAgd2hpbGUoaW5kZXggPj0gMCl7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXNlbGVjdGlvbk1hbmFnZXIuaXNEaXNhYmxlZChpdGVtTm9kZXNbaW5kZXhdLmtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdOb2RlID0gaXRlbU5vZGVzW2luZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIEZpbmQgbmV4dCwgbm90IGRpc2FibGVkIGl0ZW0uXHJcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCBpdGVtTm9kZXMubGVuZ3RoIC0gMSkgaW5kZXgrKztcclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+IHN0YXJ0SXRlbS5pbmRleCkgaW5kZXggPSBzdGFydEl0ZW0uaW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXgtLTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzZWxlY3Rpb25TdGF0ZS5zZXRGb2N1c2VkS2V5KG5ld05vZGUgPyBuZXdOb2RlLmtleSA6IG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYWNoZWRDb2xsZWN0aW9uLmN1cnJlbnQgPSBjb2xsZWN0aW9uO1xyXG4gICAgfSwgW1xyXG4gICAgICAgIGNvbGxlY3Rpb24sXHJcbiAgICAgICAgc2VsZWN0aW9uTWFuYWdlcixcclxuICAgICAgICBzZWxlY3Rpb25TdGF0ZSxcclxuICAgICAgICBzZWxlY3Rpb25TdGF0ZS5mb2N1c2VkS2V5XHJcbiAgICBdKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgY29sbGVjdGlvbjogY29sbGVjdGlvbixcclxuICAgICAgICBkaXNhYmxlZEtleXM6IGRpc2FibGVkS2V5cyxcclxuICAgICAgICBzZWxlY3Rpb25NYW5hZ2VyOiBzZWxlY3Rpb25NYW5hZ2VyXHJcbiAgICB9O1xyXG59XHJcblxyXG5cclxuLypcclxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcclxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXHJcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxyXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi8gXHJcblxyXG5cclxuZnVuY3Rpb24gJGEwZDY0NTI4OWZlOWI4NmIkZXhwb3J0JGU3ZjA1ZTk4NWRhZjRiNWYocHJvcHMpIHtcclxuICAgIHZhciBfcHJvcHNfZGVmYXVsdFNlbGVjdGVkS2V5O1xyXG4gICAgbGV0IFtzZWxlY3RlZEtleSwgc2V0U2VsZWN0ZWRLZXldID0gKDAsICQ1OFBocyR1c2VDb250cm9sbGVkU3RhdGUpKHByb3BzLnNlbGVjdGVkS2V5LCAoX3Byb3BzX2RlZmF1bHRTZWxlY3RlZEtleSA9IHByb3BzLmRlZmF1bHRTZWxlY3RlZEtleSkgIT09IG51bGwgJiYgX3Byb3BzX2RlZmF1bHRTZWxlY3RlZEtleSAhPT0gdm9pZCAwID8gX3Byb3BzX2RlZmF1bHRTZWxlY3RlZEtleSA6IG51bGwsIHByb3BzLm9uU2VsZWN0aW9uQ2hhbmdlKTtcclxuICAgIGxldCBzZWxlY3RlZEtleXMgPSAoMCwgJDU4UGhzJHVzZU1lbW8pKCgpPT5zZWxlY3RlZEtleSAhPSBudWxsID8gW1xyXG4gICAgICAgICAgICBzZWxlY3RlZEtleVxyXG4gICAgICAgIF0gOiBbXSwgW1xyXG4gICAgICAgIHNlbGVjdGVkS2V5XHJcbiAgICBdKTtcclxuICAgIGxldCB7IGNvbGxlY3Rpb246IGNvbGxlY3Rpb24sIGRpc2FibGVkS2V5czogZGlzYWJsZWRLZXlzLCBzZWxlY3Rpb25NYW5hZ2VyOiBzZWxlY3Rpb25NYW5hZ2VyIH0gPSAoMCwgJGU3MmRkNzJlMWM3NmEyMjUkZXhwb3J0JDJmNjQ1NjQ1ZjdiY2E3NjQpKHtcclxuICAgICAgICAuLi5wcm9wcyxcclxuICAgICAgICBzZWxlY3Rpb25Nb2RlOiBcInNpbmdsZVwiLFxyXG4gICAgICAgIGRpc2FsbG93RW1wdHlTZWxlY3Rpb246IHRydWUsXHJcbiAgICAgICAgYWxsb3dEdXBsaWNhdGVTZWxlY3Rpb25FdmVudHM6IHRydWUsXHJcbiAgICAgICAgc2VsZWN0ZWRLZXlzOiBzZWxlY3RlZEtleXMsXHJcbiAgICAgICAgb25TZWxlY3Rpb25DaGFuZ2U6IChrZXlzKT0+e1xyXG4gICAgICAgICAgICB2YXIgX2tleXNfdmFsdWVzX25leHRfdmFsdWU7XHJcbiAgICAgICAgICAgIGxldCBrZXkgPSAoX2tleXNfdmFsdWVzX25leHRfdmFsdWUgPSBrZXlzLnZhbHVlcygpLm5leHQoKS52YWx1ZSkgIT09IG51bGwgJiYgX2tleXNfdmFsdWVzX25leHRfdmFsdWUgIT09IHZvaWQgMCA/IF9rZXlzX3ZhbHVlc19uZXh0X3ZhbHVlIDogbnVsbDtcclxuICAgICAgICAgICAgLy8gQWx3YXlzIGZpcmUgb25TZWxlY3Rpb25DaGFuZ2UsIGV2ZW4gaWYgdGhlIGtleSBpcyB0aGUgc2FtZVxyXG4gICAgICAgICAgICAvLyBhcyB0aGUgY3VycmVudCBrZXkgKHVzZUNvbnRyb2xsZWRTdGF0ZSBkb2VzIG5vdCkuXHJcbiAgICAgICAgICAgIGlmIChrZXkgPT09IHNlbGVjdGVkS2V5ICYmIHByb3BzLm9uU2VsZWN0aW9uQ2hhbmdlKSBwcm9wcy5vblNlbGVjdGlvbkNoYW5nZShrZXkpO1xyXG4gICAgICAgICAgICBzZXRTZWxlY3RlZEtleShrZXkpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgbGV0IHNlbGVjdGVkSXRlbSA9IHNlbGVjdGVkS2V5ICE9IG51bGwgPyBjb2xsZWN0aW9uLmdldEl0ZW0oc2VsZWN0ZWRLZXkpIDogbnVsbDtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgY29sbGVjdGlvbjogY29sbGVjdGlvbixcclxuICAgICAgICBkaXNhYmxlZEtleXM6IGRpc2FibGVkS2V5cyxcclxuICAgICAgICBzZWxlY3Rpb25NYW5hZ2VyOiBzZWxlY3Rpb25NYW5hZ2VyLFxyXG4gICAgICAgIHNlbGVjdGVkS2V5OiBzZWxlY3RlZEtleSxcclxuICAgICAgICBzZXRTZWxlY3RlZEtleTogc2V0U2VsZWN0ZWRLZXksXHJcbiAgICAgICAgc2VsZWN0ZWRJdGVtOiBzZWxlY3RlZEl0ZW1cclxuICAgIH07XHJcbn1cclxuXHJcblxyXG5cclxuXHJcblxyXG5leHBvcnQgeyRlNzJkZDcyZTFjNzZhMjI1JGV4cG9ydCQyZjY0NTY0NWY3YmNhNzY0IGFzIHVzZUxpc3RTdGF0ZSwgJGEwZDY0NTI4OWZlOWI4NmIkZXhwb3J0JGU3ZjA1ZTk4NWRhZjRiNWYgYXMgdXNlU2luZ2xlU2VsZWN0TGlzdFN0YXRlLCAkYTAyZDU3MDQ5ZDIwMjY5NSRleHBvcnQkZDA4NWZiOWU5MjBiNWNhNyBhcyBMaXN0Q29sbGVjdGlvbn07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsZS5qcy5tYXBcclxuIl0sIm5hbWVzIjpbInVzZU11bHRpcGxlU2VsZWN0aW9uU3RhdGUiLCIkNThQaHMkdXNlTXVsdGlwbGVTZWxlY3Rpb25TdGF0ZSIsIlNlbGVjdGlvbk1hbmFnZXIiLCIkNThQaHMkU2VsZWN0aW9uTWFuYWdlciIsInVzZU1lbW8iLCIkNThQaHMkdXNlTWVtbyIsInVzZUNhbGxiYWNrIiwiJDU4UGhzJHVzZUNhbGxiYWNrIiwidXNlUmVmIiwiJDU4UGhzJHVzZVJlZiIsInVzZUVmZmVjdCIsIiQ1OFBocyR1c2VFZmZlY3QiLCJ1c2VDb2xsZWN0aW9uIiwiJDU4UGhzJHVzZUNvbGxlY3Rpb24iLCJ1c2VDb250cm9sbGVkU3RhdGUiLCIkNThQaHMkdXNlQ29udHJvbGxlZFN0YXRlIiwiJGEwMmQ1NzA0OWQyMDI2OTUkZXhwb3J0JGQwODVmYjllOTIwYjVjYTciLCJTeW1ib2wiLCJpdGVyYXRvciIsIml0ZXJhYmxlIiwic2l6ZSIsImtleU1hcCIsImdldEtleXMiLCJrZXlzIiwiZ2V0S2V5QmVmb3JlIiwia2V5Iiwibm9kZSIsImdldCIsInByZXZLZXkiLCJnZXRLZXlBZnRlciIsIm5leHRLZXkiLCJnZXRGaXJzdEtleSIsImZpcnN0S2V5IiwiZ2V0TGFzdEtleSIsImxhc3RLZXkiLCJnZXRJdGVtIiwiYXQiLCJpZHgiLCJnZXRDaGlsZHJlbiIsImNoaWxkTm9kZXMiLCJjb25zdHJ1Y3RvciIsIm5vZGVzIiwiTWFwIiwidmlzaXQiLCJzZXQiLCJ0eXBlIiwiY2hpbGQiLCJsYXN0IiwiaW5kZXgiLCJ1bmRlZmluZWQiLCIkZTcyZGQ3MmUxYzc2YTIyNSRleHBvcnQkMmY2NDU2NDVmN2JjYTc2NCIsInByb3BzIiwiZmlsdGVyIiwic2VsZWN0aW9uU3RhdGUiLCJkaXNhYmxlZEtleXMiLCJTZXQiLCJmYWN0b3J5IiwiY29udGV4dCIsInN1cHByZXNzVGV4dFZhbHVlV2FybmluZyIsImNvbGxlY3Rpb24iLCJzZWxlY3Rpb25NYW5hZ2VyIiwiY2FjaGVkQ29sbGVjdGlvbiIsImZvY3VzZWRLZXkiLCJzdGFydEl0ZW0iLCJjdXJyZW50IiwiY2FjaGVkSXRlbU5vZGVzIiwibWFwIiwiaXRlbU5vZGUiLCJpdGVtTm9kZXMiLCJkaWZmIiwibGVuZ3RoIiwiTWF0aCIsIm1pbiIsIm1heCIsIm5ld05vZGUiLCJpc0Rpc2FibGVkIiwic2V0Rm9jdXNlZEtleSIsIiRhMGQ2NDUyODlmZTliODZiJGV4cG9ydCRlN2YwNWU5ODVkYWY0YjVmIiwiX3Byb3BzX2RlZmF1bHRTZWxlY3RlZEtleSIsInNlbGVjdGVkS2V5Iiwic2V0U2VsZWN0ZWRLZXkiLCJkZWZhdWx0U2VsZWN0ZWRLZXkiLCJvblNlbGVjdGlvbkNoYW5nZSIsInNlbGVjdGVkS2V5cyIsInNlbGVjdGlvbk1vZGUiLCJkaXNhbGxvd0VtcHR5U2VsZWN0aW9uIiwiYWxsb3dEdXBsaWNhdGVTZWxlY3Rpb25FdmVudHMiLCJfa2V5c192YWx1ZXNfbmV4dF92YWx1ZSIsInZhbHVlcyIsIm5leHQiLCJ2YWx1ZSIsInNlbGVjdGVkSXRlbSIsInVzZUxpc3RTdGF0ZSIsInVzZVNpbmdsZVNlbGVjdExpc3RTdGF0ZSIsIkxpc3RDb2xsZWN0aW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/list/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/menu/dist/import.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@react-stately/menu/dist/import.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UNSTABLE_useSubmenuTriggerState: () => (/* binding */ $e5614764aa47eb35$export$d39fdbfa42246ac4),\n/* harmony export */   useMenuTriggerState: () => (/* binding */ $a28c903ee9ad8dc5$export$79fefeb1c2091ac3)\n/* harmony export */ });\n/* harmony import */ var _react_stately_overlays__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/overlays */ \"(ssr)/./node_modules/@react-stately/overlays/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n\n/*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ /*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ function $a28c903ee9ad8dc5$export$79fefeb1c2091ac3(props) {\n    let overlayTriggerState = (0, _react_stately_overlays__WEBPACK_IMPORTED_MODULE_1__.useOverlayTriggerState)(props);\n    let [focusStrategy, setFocusStrategy] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    let [expandedKeysStack, setExpandedKeysStack] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    let closeAll = ()=>{\n        setExpandedKeysStack([]);\n        overlayTriggerState.close();\n    };\n    let openSubmenu = (triggerKey, level)=>{\n        setExpandedKeysStack((oldStack)=>{\n            if (level > oldStack.length) return oldStack;\n            return [\n                ...oldStack.slice(0, level),\n                triggerKey\n            ];\n        });\n    };\n    let closeSubmenu = (triggerKey, level)=>{\n        setExpandedKeysStack((oldStack)=>{\n            let key = oldStack[level];\n            if (key === triggerKey) return oldStack.slice(0, level);\n            else return oldStack;\n        });\n    };\n    return {\n        focusStrategy: focusStrategy,\n        ...overlayTriggerState,\n        open (focusStrategy = null) {\n            setFocusStrategy(focusStrategy);\n            overlayTriggerState.open();\n        },\n        toggle (focusStrategy = null) {\n            setFocusStrategy(focusStrategy);\n            overlayTriggerState.toggle();\n        },\n        close () {\n            closeAll();\n        },\n        UNSTABLE_expandedKeysStack: expandedKeysStack,\n        UNSTABLE_openSubmenu: openSubmenu,\n        UNSTABLE_closeSubmenu: closeSubmenu\n    };\n}\n/*\r\n * Copyright 2023 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ function $e5614764aa47eb35$export$d39fdbfa42246ac4(props, state) {\n    let { triggerKey: triggerKey } = props;\n    let { UNSTABLE_expandedKeysStack: UNSTABLE_expandedKeysStack, UNSTABLE_openSubmenu: UNSTABLE_openSubmenu, UNSTABLE_closeSubmenu: UNSTABLE_closeSubmenu, close: closeAll } = state;\n    let [submenuLevel] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(UNSTABLE_expandedKeysStack === null || UNSTABLE_expandedKeysStack === void 0 ? void 0 : UNSTABLE_expandedKeysStack.length);\n    let isOpen = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>UNSTABLE_expandedKeysStack[submenuLevel] === triggerKey, [\n        UNSTABLE_expandedKeysStack,\n        triggerKey,\n        submenuLevel\n    ]);\n    let [focusStrategy, setFocusStrategy] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    let open = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((focusStrategy = null)=>{\n        setFocusStrategy(focusStrategy);\n        UNSTABLE_openSubmenu(triggerKey, submenuLevel);\n    }, [\n        UNSTABLE_openSubmenu,\n        submenuLevel,\n        triggerKey\n    ]);\n    let close = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setFocusStrategy(null);\n        UNSTABLE_closeSubmenu(triggerKey, submenuLevel);\n    }, [\n        UNSTABLE_closeSubmenu,\n        submenuLevel,\n        triggerKey\n    ]);\n    let toggle = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((focusStrategy = null)=>{\n        setFocusStrategy(focusStrategy);\n        if (isOpen) close();\n        else open(focusStrategy);\n    }, [\n        close,\n        open,\n        isOpen\n    ]);\n    return (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            focusStrategy: focusStrategy,\n            isOpen: isOpen,\n            open: open,\n            close: close,\n            closeAll: closeAll,\n            submenuLevel: submenuLevel,\n            // TODO: Placeholders that aren't used but give us parity with OverlayTriggerState so we can use this in Popover. Refactor if we update Popover via\n            // https://github.com/adobe/react-spectrum/pull/4976#discussion_r1336472863\n            setOpen: ()=>{},\n            toggle: toggle\n        }), [\n        isOpen,\n        open,\n        close,\n        closeAll,\n        focusStrategy,\n        toggle,\n        submenuLevel\n    ]);\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvbWVudS9kaXN0L2ltcG9ydC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFnRztBQUNnQjtBQUVoSDs7Ozs7Ozs7OztDQVVDLEdBQUc7Ozs7Ozs7Ozs7Q0FVSCxHQUVELFNBQVNRLDBDQUEwQ0MsS0FBSztJQUNwRCxJQUFJQyxzQkFBc0IsQ0FBQyxHQUFHVCwyRUFBNEIsRUFBR1E7SUFDN0QsSUFBSSxDQUFDRSxlQUFlQyxpQkFBaUIsR0FBRyxDQUFDLEdBQUdULDJDQUFjLEVBQUc7SUFDN0QsSUFBSSxDQUFDVSxtQkFBbUJDLHFCQUFxQixHQUFHLENBQUMsR0FBR1gsMkNBQWMsRUFBRyxFQUFFO0lBQ3ZFLElBQUlZLFdBQVc7UUFDWEQscUJBQXFCLEVBQUU7UUFDdkJKLG9CQUFvQk0sS0FBSztJQUM3QjtJQUNBLElBQUlDLGNBQWMsQ0FBQ0MsWUFBWUM7UUFDM0JMLHFCQUFxQixDQUFDTTtZQUNsQixJQUFJRCxRQUFRQyxTQUFTQyxNQUFNLEVBQUUsT0FBT0Q7WUFDcEMsT0FBTzttQkFDQUEsU0FBU0UsS0FBSyxDQUFDLEdBQUdIO2dCQUNyQkQ7YUFDSDtRQUNMO0lBQ0o7SUFDQSxJQUFJSyxlQUFlLENBQUNMLFlBQVlDO1FBQzVCTCxxQkFBcUIsQ0FBQ007WUFDbEIsSUFBSUksTUFBTUosUUFBUSxDQUFDRCxNQUFNO1lBQ3pCLElBQUlLLFFBQVFOLFlBQVksT0FBT0UsU0FBU0UsS0FBSyxDQUFDLEdBQUdIO2lCQUM1QyxPQUFPQztRQUNoQjtJQUNKO0lBQ0EsT0FBTztRQUNIVCxlQUFlQTtRQUNmLEdBQUdELG1CQUFtQjtRQUN0QmUsTUFBTWQsZ0JBQWdCLElBQUk7WUFDdEJDLGlCQUFpQkQ7WUFDakJELG9CQUFvQmUsSUFBSTtRQUM1QjtRQUNBQyxRQUFRZixnQkFBZ0IsSUFBSTtZQUN4QkMsaUJBQWlCRDtZQUNqQkQsb0JBQW9CZ0IsTUFBTTtRQUM5QjtRQUNBVjtZQUNJRDtRQUNKO1FBQ0FZLDRCQUE0QmQ7UUFDNUJlLHNCQUFzQlg7UUFDdEJZLHVCQUF1Qk47SUFDM0I7QUFDSjtBQUdBOzs7Ozs7Ozs7O0NBVUMsR0FDRCxTQUFTTywwQ0FBMENyQixLQUFLLEVBQUVzQixLQUFLO0lBQzNELElBQUksRUFBRWIsWUFBWUEsVUFBVSxFQUFFLEdBQUdUO0lBQ2pDLElBQUksRUFBRWtCLDRCQUE0QkEsMEJBQTBCLEVBQUVDLHNCQUFzQkEsb0JBQW9CLEVBQUVDLHVCQUF1QkEscUJBQXFCLEVBQUViLE9BQU9ELFFBQVEsRUFBRSxHQUFHZ0I7SUFDNUssSUFBSSxDQUFDQyxhQUFhLEdBQUcsQ0FBQyxHQUFHN0IsMkNBQWMsRUFBR3dCLCtCQUErQixRQUFRQSwrQkFBK0IsS0FBSyxJQUFJLEtBQUssSUFBSUEsMkJBQTJCTixNQUFNO0lBQ25LLElBQUlZLFNBQVMsQ0FBQyxHQUFHNUIsMENBQWEsRUFBRyxJQUFJc0IsMEJBQTBCLENBQUNLLGFBQWEsS0FBS2QsWUFBWTtRQUMxRlM7UUFDQVQ7UUFDQWM7S0FDSDtJQUNELElBQUksQ0FBQ3JCLGVBQWVDLGlCQUFpQixHQUFHLENBQUMsR0FBR1QsMkNBQWMsRUFBRztJQUM3RCxJQUFJc0IsT0FBTyxDQUFDLEdBQUdsQiw4Q0FBaUIsRUFBRyxDQUFDSSxnQkFBZ0IsSUFBSTtRQUNwREMsaUJBQWlCRDtRQUNqQmlCLHFCQUFxQlYsWUFBWWM7SUFDckMsR0FBRztRQUNDSjtRQUNBSTtRQUNBZDtLQUNIO0lBQ0QsSUFBSUYsUUFBUSxDQUFDLEdBQUdULDhDQUFpQixFQUFHO1FBQ2hDSyxpQkFBaUI7UUFDakJpQixzQkFBc0JYLFlBQVljO0lBQ3RDLEdBQUc7UUFDQ0g7UUFDQUc7UUFDQWQ7S0FDSDtJQUNELElBQUlRLFNBQVMsQ0FBQyxHQUFHbkIsOENBQWlCLEVBQUcsQ0FBQ0ksZ0JBQWdCLElBQUk7UUFDdERDLGlCQUFpQkQ7UUFDakIsSUFBSXNCLFFBQVFqQjthQUNQUyxLQUFLZDtJQUNkLEdBQUc7UUFDQ0s7UUFDQVM7UUFDQVE7S0FDSDtJQUNELE9BQU8sQ0FBQyxHQUFHNUIsMENBQWEsRUFBRyxJQUFLO1lBQ3hCTSxlQUFlQTtZQUNmc0IsUUFBUUE7WUFDUlIsTUFBTUE7WUFDTlQsT0FBT0E7WUFDUEQsVUFBVUE7WUFDVmlCLGNBQWNBO1lBQ2QsbUpBQW1KO1lBQ25KLDJFQUEyRTtZQUMzRUUsU0FBUyxLQUFLO1lBQ2RSLFFBQVFBO1FBQ1osSUFBSTtRQUNKTztRQUNBUjtRQUNBVDtRQUNBRDtRQUNBSjtRQUNBZTtRQUNBTTtLQUNIO0FBQ0w7QUFLd0osQ0FDeEosa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGFuYW1vbm5leHRfdWkvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvbWVudS9kaXN0L2ltcG9ydC5tanM/MWI1ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3VzZU92ZXJsYXlUcmlnZ2VyU3RhdGUgYXMgJDlYdm9oJHVzZU92ZXJsYXlUcmlnZ2VyU3RhdGV9IGZyb20gXCJAcmVhY3Qtc3RhdGVseS9vdmVybGF5c1wiO1xyXG5pbXBvcnQge3VzZVN0YXRlIGFzICQ5WHZvaCR1c2VTdGF0ZSwgdXNlTWVtbyBhcyAkOVh2b2gkdXNlTWVtbywgdXNlQ2FsbGJhY2sgYXMgJDlYdm9oJHVzZUNhbGxiYWNrfSBmcm9tIFwicmVhY3RcIjtcclxuXHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XHJcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXHJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xyXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcclxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovIC8qXHJcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XHJcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXHJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xyXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcclxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovIFxyXG5cclxuZnVuY3Rpb24gJGEyOGM5MDNlZTlhZDhkYzUkZXhwb3J0JDc5ZmVmZWIxYzIwOTFhYzMocHJvcHMpIHtcclxuICAgIGxldCBvdmVybGF5VHJpZ2dlclN0YXRlID0gKDAsICQ5WHZvaCR1c2VPdmVybGF5VHJpZ2dlclN0YXRlKShwcm9wcyk7XHJcbiAgICBsZXQgW2ZvY3VzU3RyYXRlZ3ksIHNldEZvY3VzU3RyYXRlZ3ldID0gKDAsICQ5WHZvaCR1c2VTdGF0ZSkobnVsbCk7XHJcbiAgICBsZXQgW2V4cGFuZGVkS2V5c1N0YWNrLCBzZXRFeHBhbmRlZEtleXNTdGFja10gPSAoMCwgJDlYdm9oJHVzZVN0YXRlKShbXSk7XHJcbiAgICBsZXQgY2xvc2VBbGwgPSAoKT0+e1xyXG4gICAgICAgIHNldEV4cGFuZGVkS2V5c1N0YWNrKFtdKTtcclxuICAgICAgICBvdmVybGF5VHJpZ2dlclN0YXRlLmNsb3NlKCk7XHJcbiAgICB9O1xyXG4gICAgbGV0IG9wZW5TdWJtZW51ID0gKHRyaWdnZXJLZXksIGxldmVsKT0+e1xyXG4gICAgICAgIHNldEV4cGFuZGVkS2V5c1N0YWNrKChvbGRTdGFjayk9PntcclxuICAgICAgICAgICAgaWYgKGxldmVsID4gb2xkU3RhY2subGVuZ3RoKSByZXR1cm4gb2xkU3RhY2s7XHJcbiAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICAuLi5vbGRTdGFjay5zbGljZSgwLCBsZXZlbCksXHJcbiAgICAgICAgICAgICAgICB0cmlnZ2VyS2V5XHJcbiAgICAgICAgICAgIF07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgbGV0IGNsb3NlU3VibWVudSA9ICh0cmlnZ2VyS2V5LCBsZXZlbCk9PntcclxuICAgICAgICBzZXRFeHBhbmRlZEtleXNTdGFjaygob2xkU3RhY2spPT57XHJcbiAgICAgICAgICAgIGxldCBrZXkgPSBvbGRTdGFja1tsZXZlbF07XHJcbiAgICAgICAgICAgIGlmIChrZXkgPT09IHRyaWdnZXJLZXkpIHJldHVybiBvbGRTdGFjay5zbGljZSgwLCBsZXZlbCk7XHJcbiAgICAgICAgICAgIGVsc2UgcmV0dXJuIG9sZFN0YWNrO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZm9jdXNTdHJhdGVneTogZm9jdXNTdHJhdGVneSxcclxuICAgICAgICAuLi5vdmVybGF5VHJpZ2dlclN0YXRlLFxyXG4gICAgICAgIG9wZW4gKGZvY3VzU3RyYXRlZ3kgPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHNldEZvY3VzU3RyYXRlZ3koZm9jdXNTdHJhdGVneSk7XHJcbiAgICAgICAgICAgIG92ZXJsYXlUcmlnZ2VyU3RhdGUub3BlbigpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdG9nZ2xlIChmb2N1c1N0cmF0ZWd5ID0gbnVsbCkge1xyXG4gICAgICAgICAgICBzZXRGb2N1c1N0cmF0ZWd5KGZvY3VzU3RyYXRlZ3kpO1xyXG4gICAgICAgICAgICBvdmVybGF5VHJpZ2dlclN0YXRlLnRvZ2dsZSgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY2xvc2UgKCkge1xyXG4gICAgICAgICAgICBjbG9zZUFsbCgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgVU5TVEFCTEVfZXhwYW5kZWRLZXlzU3RhY2s6IGV4cGFuZGVkS2V5c1N0YWNrLFxyXG4gICAgICAgIFVOU1RBQkxFX29wZW5TdWJtZW51OiBvcGVuU3VibWVudSxcclxuICAgICAgICBVTlNUQUJMRV9jbG9zZVN1Ym1lbnU6IGNsb3NlU3VibWVudVxyXG4gICAgfTtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDIzIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XHJcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXHJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xyXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcclxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovIFxyXG5mdW5jdGlvbiAkZTU2MTQ3NjRhYTQ3ZWIzNSRleHBvcnQkZDM5ZmRiZmE0MjI0NmFjNChwcm9wcywgc3RhdGUpIHtcclxuICAgIGxldCB7IHRyaWdnZXJLZXk6IHRyaWdnZXJLZXkgfSA9IHByb3BzO1xyXG4gICAgbGV0IHsgVU5TVEFCTEVfZXhwYW5kZWRLZXlzU3RhY2s6IFVOU1RBQkxFX2V4cGFuZGVkS2V5c1N0YWNrLCBVTlNUQUJMRV9vcGVuU3VibWVudTogVU5TVEFCTEVfb3BlblN1Ym1lbnUsIFVOU1RBQkxFX2Nsb3NlU3VibWVudTogVU5TVEFCTEVfY2xvc2VTdWJtZW51LCBjbG9zZTogY2xvc2VBbGwgfSA9IHN0YXRlO1xyXG4gICAgbGV0IFtzdWJtZW51TGV2ZWxdID0gKDAsICQ5WHZvaCR1c2VTdGF0ZSkoVU5TVEFCTEVfZXhwYW5kZWRLZXlzU3RhY2sgPT09IG51bGwgfHwgVU5TVEFCTEVfZXhwYW5kZWRLZXlzU3RhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IFVOU1RBQkxFX2V4cGFuZGVkS2V5c1N0YWNrLmxlbmd0aCk7XHJcbiAgICBsZXQgaXNPcGVuID0gKDAsICQ5WHZvaCR1c2VNZW1vKSgoKT0+VU5TVEFCTEVfZXhwYW5kZWRLZXlzU3RhY2tbc3VibWVudUxldmVsXSA9PT0gdHJpZ2dlcktleSwgW1xyXG4gICAgICAgIFVOU1RBQkxFX2V4cGFuZGVkS2V5c1N0YWNrLFxyXG4gICAgICAgIHRyaWdnZXJLZXksXHJcbiAgICAgICAgc3VibWVudUxldmVsXHJcbiAgICBdKTtcclxuICAgIGxldCBbZm9jdXNTdHJhdGVneSwgc2V0Rm9jdXNTdHJhdGVneV0gPSAoMCwgJDlYdm9oJHVzZVN0YXRlKShudWxsKTtcclxuICAgIGxldCBvcGVuID0gKDAsICQ5WHZvaCR1c2VDYWxsYmFjaykoKGZvY3VzU3RyYXRlZ3kgPSBudWxsKT0+e1xyXG4gICAgICAgIHNldEZvY3VzU3RyYXRlZ3koZm9jdXNTdHJhdGVneSk7XHJcbiAgICAgICAgVU5TVEFCTEVfb3BlblN1Ym1lbnUodHJpZ2dlcktleSwgc3VibWVudUxldmVsKTtcclxuICAgIH0sIFtcclxuICAgICAgICBVTlNUQUJMRV9vcGVuU3VibWVudSxcclxuICAgICAgICBzdWJtZW51TGV2ZWwsXHJcbiAgICAgICAgdHJpZ2dlcktleVxyXG4gICAgXSk7XHJcbiAgICBsZXQgY2xvc2UgPSAoMCwgJDlYdm9oJHVzZUNhbGxiYWNrKSgoKT0+e1xyXG4gICAgICAgIHNldEZvY3VzU3RyYXRlZ3kobnVsbCk7XHJcbiAgICAgICAgVU5TVEFCTEVfY2xvc2VTdWJtZW51KHRyaWdnZXJLZXksIHN1Ym1lbnVMZXZlbCk7XHJcbiAgICB9LCBbXHJcbiAgICAgICAgVU5TVEFCTEVfY2xvc2VTdWJtZW51LFxyXG4gICAgICAgIHN1Ym1lbnVMZXZlbCxcclxuICAgICAgICB0cmlnZ2VyS2V5XHJcbiAgICBdKTtcclxuICAgIGxldCB0b2dnbGUgPSAoMCwgJDlYdm9oJHVzZUNhbGxiYWNrKSgoZm9jdXNTdHJhdGVneSA9IG51bGwpPT57XHJcbiAgICAgICAgc2V0Rm9jdXNTdHJhdGVneShmb2N1c1N0cmF0ZWd5KTtcclxuICAgICAgICBpZiAoaXNPcGVuKSBjbG9zZSgpO1xyXG4gICAgICAgIGVsc2Ugb3Blbihmb2N1c1N0cmF0ZWd5KTtcclxuICAgIH0sIFtcclxuICAgICAgICBjbG9zZSxcclxuICAgICAgICBvcGVuLFxyXG4gICAgICAgIGlzT3BlblxyXG4gICAgXSk7XHJcbiAgICByZXR1cm4gKDAsICQ5WHZvaCR1c2VNZW1vKSgoKT0+KHtcclxuICAgICAgICAgICAgZm9jdXNTdHJhdGVneTogZm9jdXNTdHJhdGVneSxcclxuICAgICAgICAgICAgaXNPcGVuOiBpc09wZW4sXHJcbiAgICAgICAgICAgIG9wZW46IG9wZW4sXHJcbiAgICAgICAgICAgIGNsb3NlOiBjbG9zZSxcclxuICAgICAgICAgICAgY2xvc2VBbGw6IGNsb3NlQWxsLFxyXG4gICAgICAgICAgICBzdWJtZW51TGV2ZWw6IHN1Ym1lbnVMZXZlbCxcclxuICAgICAgICAgICAgLy8gVE9ETzogUGxhY2Vob2xkZXJzIHRoYXQgYXJlbid0IHVzZWQgYnV0IGdpdmUgdXMgcGFyaXR5IHdpdGggT3ZlcmxheVRyaWdnZXJTdGF0ZSBzbyB3ZSBjYW4gdXNlIHRoaXMgaW4gUG9wb3Zlci4gUmVmYWN0b3IgaWYgd2UgdXBkYXRlIFBvcG92ZXIgdmlhXHJcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hZG9iZS9yZWFjdC1zcGVjdHJ1bS9wdWxsLzQ5NzYjZGlzY3Vzc2lvbl9yMTMzNjQ3Mjg2M1xyXG4gICAgICAgICAgICBzZXRPcGVuOiAoKT0+e30sXHJcbiAgICAgICAgICAgIHRvZ2dsZTogdG9nZ2xlXHJcbiAgICAgICAgfSksIFtcclxuICAgICAgICBpc09wZW4sXHJcbiAgICAgICAgb3BlbixcclxuICAgICAgICBjbG9zZSxcclxuICAgICAgICBjbG9zZUFsbCxcclxuICAgICAgICBmb2N1c1N0cmF0ZWd5LFxyXG4gICAgICAgIHRvZ2dsZSxcclxuICAgICAgICBzdWJtZW51TGV2ZWxcclxuICAgIF0pO1xyXG59XHJcblxyXG5cclxuXHJcblxyXG5leHBvcnQgeyRhMjhjOTAzZWU5YWQ4ZGM1JGV4cG9ydCQ3OWZlZmViMWMyMDkxYWMzIGFzIHVzZU1lbnVUcmlnZ2VyU3RhdGUsICRlNTYxNDc2NGFhNDdlYjM1JGV4cG9ydCRkMzlmZGJmYTQyMjQ2YWM0IGFzIFVOU1RBQkxFX3VzZVN1Ym1lbnVUcmlnZ2VyU3RhdGV9O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGUuanMubWFwXHJcbiJdLCJuYW1lcyI6WyJ1c2VPdmVybGF5VHJpZ2dlclN0YXRlIiwiJDlYdm9oJHVzZU92ZXJsYXlUcmlnZ2VyU3RhdGUiLCJ1c2VTdGF0ZSIsIiQ5WHZvaCR1c2VTdGF0ZSIsInVzZU1lbW8iLCIkOVh2b2gkdXNlTWVtbyIsInVzZUNhbGxiYWNrIiwiJDlYdm9oJHVzZUNhbGxiYWNrIiwiJGEyOGM5MDNlZTlhZDhkYzUkZXhwb3J0JDc5ZmVmZWIxYzIwOTFhYzMiLCJwcm9wcyIsIm92ZXJsYXlUcmlnZ2VyU3RhdGUiLCJmb2N1c1N0cmF0ZWd5Iiwic2V0Rm9jdXNTdHJhdGVneSIsImV4cGFuZGVkS2V5c1N0YWNrIiwic2V0RXhwYW5kZWRLZXlzU3RhY2siLCJjbG9zZUFsbCIsImNsb3NlIiwib3BlblN1Ym1lbnUiLCJ0cmlnZ2VyS2V5IiwibGV2ZWwiLCJvbGRTdGFjayIsImxlbmd0aCIsInNsaWNlIiwiY2xvc2VTdWJtZW51Iiwia2V5Iiwib3BlbiIsInRvZ2dsZSIsIlVOU1RBQkxFX2V4cGFuZGVkS2V5c1N0YWNrIiwiVU5TVEFCTEVfb3BlblN1Ym1lbnUiLCJVTlNUQUJMRV9jbG9zZVN1Ym1lbnUiLCIkZTU2MTQ3NjRhYTQ3ZWIzNSRleHBvcnQkZDM5ZmRiZmE0MjI0NmFjNCIsInN0YXRlIiwic3VibWVudUxldmVsIiwiaXNPcGVuIiwic2V0T3BlbiIsInVzZU1lbnVUcmlnZ2VyU3RhdGUiLCJVTlNUQUJMRV91c2VTdWJtZW51VHJpZ2dlclN0YXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/menu/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/overlays/dist/import.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@react-stately/overlays/dist/import.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useOverlayTriggerState: () => (/* binding */ $fc909762b330b746$export$61c6a8c84e605fb6)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\");\n\n\n/*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ /*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ function $fc909762b330b746$export$61c6a8c84e605fb6(props) {\n    let [isOpen, setOpen] = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.useControlledState)(props.isOpen, props.defaultOpen || false, props.onOpenChange);\n    const open = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setOpen(true);\n    }, [\n        setOpen\n    ]);\n    const close = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setOpen(false);\n    }, [\n        setOpen\n    ]);\n    const toggle = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setOpen(!isOpen);\n    }, [\n        setOpen,\n        isOpen\n    ]);\n    return {\n        isOpen: isOpen,\n        setOpen: setOpen,\n        open: open,\n        close: close,\n        toggle: toggle\n    };\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvb3ZlcmxheXMvZGlzdC9pbXBvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF3RDtBQUM2QjtBQUVyRjs7Ozs7Ozs7OztDQVVDLEdBQUc7Ozs7Ozs7Ozs7Q0FVSCxHQUVELFNBQVNJLDBDQUEwQ0MsS0FBSztJQUNwRCxJQUFJLENBQUNDLFFBQVFDLFFBQVEsR0FBRyxDQUFDLEdBQUdKLG9FQUF3QixFQUFHRSxNQUFNQyxNQUFNLEVBQUVELE1BQU1HLFdBQVcsSUFBSSxPQUFPSCxNQUFNSSxZQUFZO0lBQ25ILE1BQU1DLE9BQU8sQ0FBQyxHQUFHVCw4Q0FBaUIsRUFBRztRQUNqQ00sUUFBUTtJQUNaLEdBQUc7UUFDQ0E7S0FDSDtJQUNELE1BQU1JLFFBQVEsQ0FBQyxHQUFHViw4Q0FBaUIsRUFBRztRQUNsQ00sUUFBUTtJQUNaLEdBQUc7UUFDQ0E7S0FDSDtJQUNELE1BQU1LLFNBQVMsQ0FBQyxHQUFHWCw4Q0FBaUIsRUFBRztRQUNuQ00sUUFBUSxDQUFDRDtJQUNiLEdBQUc7UUFDQ0M7UUFDQUQ7S0FDSDtJQUNELE9BQU87UUFDSEEsUUFBUUE7UUFDUkMsU0FBU0E7UUFDVEcsTUFBTUE7UUFDTkMsT0FBT0E7UUFDUEMsUUFBUUE7SUFDWjtBQUNKO0FBSzZFLENBQzdFLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL2RhbmFtb25uZXh0X3VpLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC1zdGF0ZWx5L292ZXJsYXlzL2Rpc3QvaW1wb3J0Lm1qcz8wN2E0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7dXNlQ2FsbGJhY2sgYXMgJDRvQTNQJHVzZUNhbGxiYWNrfSBmcm9tIFwicmVhY3RcIjtcclxuaW1wb3J0IHt1c2VDb250cm9sbGVkU3RhdGUgYXMgJDRvQTNQJHVzZUNvbnRyb2xsZWRTdGF0ZX0gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L3V0aWxzXCI7XHJcblxyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxyXG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcclxuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXHJcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqLyAvKlxyXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxyXG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcclxuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXHJcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqLyBcclxuXHJcbmZ1bmN0aW9uICRmYzkwOTc2MmIzMzBiNzQ2JGV4cG9ydCQ2MWM2YThjODRlNjA1ZmI2KHByb3BzKSB7XHJcbiAgICBsZXQgW2lzT3Blbiwgc2V0T3Blbl0gPSAoMCwgJDRvQTNQJHVzZUNvbnRyb2xsZWRTdGF0ZSkocHJvcHMuaXNPcGVuLCBwcm9wcy5kZWZhdWx0T3BlbiB8fCBmYWxzZSwgcHJvcHMub25PcGVuQ2hhbmdlKTtcclxuICAgIGNvbnN0IG9wZW4gPSAoMCwgJDRvQTNQJHVzZUNhbGxiYWNrKSgoKT0+e1xyXG4gICAgICAgIHNldE9wZW4odHJ1ZSk7XHJcbiAgICB9LCBbXHJcbiAgICAgICAgc2V0T3BlblxyXG4gICAgXSk7XHJcbiAgICBjb25zdCBjbG9zZSA9ICgwLCAkNG9BM1AkdXNlQ2FsbGJhY2spKCgpPT57XHJcbiAgICAgICAgc2V0T3BlbihmYWxzZSk7XHJcbiAgICB9LCBbXHJcbiAgICAgICAgc2V0T3BlblxyXG4gICAgXSk7XHJcbiAgICBjb25zdCB0b2dnbGUgPSAoMCwgJDRvQTNQJHVzZUNhbGxiYWNrKSgoKT0+e1xyXG4gICAgICAgIHNldE9wZW4oIWlzT3Blbik7XHJcbiAgICB9LCBbXHJcbiAgICAgICAgc2V0T3BlbixcclxuICAgICAgICBpc09wZW5cclxuICAgIF0pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBpc09wZW46IGlzT3BlbixcclxuICAgICAgICBzZXRPcGVuOiBzZXRPcGVuLFxyXG4gICAgICAgIG9wZW46IG9wZW4sXHJcbiAgICAgICAgY2xvc2U6IGNsb3NlLFxyXG4gICAgICAgIHRvZ2dsZTogdG9nZ2xlXHJcbiAgICB9O1xyXG59XHJcblxyXG5cclxuXHJcblxyXG5leHBvcnQgeyRmYzkwOTc2MmIzMzBiNzQ2JGV4cG9ydCQ2MWM2YThjODRlNjA1ZmI2IGFzIHVzZU92ZXJsYXlUcmlnZ2VyU3RhdGV9O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGUuanMubWFwXHJcbiJdLCJuYW1lcyI6WyJ1c2VDYWxsYmFjayIsIiQ0b0EzUCR1c2VDYWxsYmFjayIsInVzZUNvbnRyb2xsZWRTdGF0ZSIsIiQ0b0EzUCR1c2VDb250cm9sbGVkU3RhdGUiLCIkZmM5MDk3NjJiMzMwYjc0NiRleHBvcnQkNjFjNmE4Yzg0ZTYwNWZiNiIsInByb3BzIiwiaXNPcGVuIiwic2V0T3BlbiIsImRlZmF1bHRPcGVuIiwib25PcGVuQ2hhbmdlIiwib3BlbiIsImNsb3NlIiwidG9nZ2xlIiwidXNlT3ZlcmxheVRyaWdnZXJTdGF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/overlays/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/radio/dist/import.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@react-stately/radio/dist/import.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useRadioGroupState: () => (/* binding */ $a54cdc5c1942b639$export$bca9d026f8e704eb)\n/* harmony export */ });\n/* harmony import */ var _react_stately_form__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-stately/form */ \"(ssr)/./node_modules/@react-stately/form/dist/import.mjs\");\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n\n\n/*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ /*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ let $a54cdc5c1942b639$var$instance = Math.round(Math.random() * 10000000000);\nlet $a54cdc5c1942b639$var$i = 0;\nfunction $a54cdc5c1942b639$export$bca9d026f8e704eb(props) {\n    // Preserved here for backward compatibility. React Aria now generates the name instead of stately.\n    let name = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>props.name || `radio-group-${$a54cdc5c1942b639$var$instance}-${++$a54cdc5c1942b639$var$i}`, [\n        props.name\n    ]);\n    var _props_defaultValue;\n    let [selectedValue, setSelected] = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.useControlledState)(props.value, (_props_defaultValue = props.defaultValue) !== null && _props_defaultValue !== void 0 ? _props_defaultValue : null, props.onChange);\n    let [lastFocusedValue, setLastFocusedValue] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    let validation = (0, _react_stately_form__WEBPACK_IMPORTED_MODULE_2__.useFormValidationState)({\n        ...props,\n        value: selectedValue\n    });\n    let setSelectedValue = (value)=>{\n        if (!props.isReadOnly && !props.isDisabled) {\n            setSelected(value);\n            validation.commitValidation();\n        }\n    };\n    let isInvalid = validation.displayValidation.isInvalid;\n    return {\n        ...validation,\n        name: name,\n        selectedValue: selectedValue,\n        setSelectedValue: setSelectedValue,\n        lastFocusedValue: lastFocusedValue,\n        setLastFocusedValue: setLastFocusedValue,\n        isDisabled: props.isDisabled || false,\n        isReadOnly: props.isReadOnly || false,\n        isRequired: props.isRequired || false,\n        validationState: props.validationState || (isInvalid ? \"invalid\" : null),\n        isInvalid: isInvalid\n    };\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvcmFkaW8vZGlzdC9pbXBvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBNEY7QUFDUDtBQUNSO0FBRTdFOzs7Ozs7Ozs7O0NBVUMsR0FBRzs7Ozs7Ozs7OztDQVVILEdBR0QsSUFBSVEsaUNBQWlDQyxLQUFLQyxLQUFLLENBQUNELEtBQUtFLE1BQU0sS0FBSztBQUNoRSxJQUFJQywwQkFBMEI7QUFDOUIsU0FBU0MsMENBQTBDQyxLQUFLO0lBQ3BELG1HQUFtRztJQUNuRyxJQUFJQyxPQUFPLENBQUMsR0FBR1YsMENBQWEsRUFBRyxJQUFJUyxNQUFNQyxJQUFJLElBQUksQ0FBQyxZQUFZLEVBQUVQLCtCQUErQixDQUFDLEVBQUUsRUFBRUksd0JBQXdCLENBQUMsRUFBRTtRQUMzSEUsTUFBTUMsSUFBSTtLQUNiO0lBQ0QsSUFBSUM7SUFDSixJQUFJLENBQUNDLGVBQWVDLFlBQVksR0FBRyxDQUFDLEdBQUdmLG9FQUF3QixFQUFHVyxNQUFNSyxLQUFLLEVBQUUsQ0FBQ0gsc0JBQXNCRixNQUFNTSxZQUFZLE1BQU0sUUFBUUosd0JBQXdCLEtBQUssSUFBSUEsc0JBQXNCLE1BQU1GLE1BQU1PLFFBQVE7SUFDak4sSUFBSSxDQUFDQyxrQkFBa0JDLG9CQUFvQixHQUFHLENBQUMsR0FBR2hCLDJDQUFjLEVBQUc7SUFDbkUsSUFBSWlCLGFBQWEsQ0FBQyxHQUFHdkIsdUVBQTRCLEVBQUc7UUFDaEQsR0FBR2EsS0FBSztRQUNSSyxPQUFPRjtJQUNYO0lBQ0EsSUFBSVEsbUJBQW1CLENBQUNOO1FBQ3BCLElBQUksQ0FBQ0wsTUFBTVksVUFBVSxJQUFJLENBQUNaLE1BQU1hLFVBQVUsRUFBRTtZQUN4Q1QsWUFBWUM7WUFDWkssV0FBV0ksZ0JBQWdCO1FBQy9CO0lBQ0o7SUFDQSxJQUFJQyxZQUFZTCxXQUFXTSxpQkFBaUIsQ0FBQ0QsU0FBUztJQUN0RCxPQUFPO1FBQ0gsR0FBR0wsVUFBVTtRQUNiVCxNQUFNQTtRQUNORSxlQUFlQTtRQUNmUSxrQkFBa0JBO1FBQ2xCSCxrQkFBa0JBO1FBQ2xCQyxxQkFBcUJBO1FBQ3JCSSxZQUFZYixNQUFNYSxVQUFVLElBQUk7UUFDaENELFlBQVlaLE1BQU1ZLFVBQVUsSUFBSTtRQUNoQ0ssWUFBWWpCLE1BQU1pQixVQUFVLElBQUk7UUFDaENDLGlCQUFpQmxCLE1BQU1rQixlQUFlLElBQUtILENBQUFBLFlBQVksWUFBWSxJQUFHO1FBQ3RFQSxXQUFXQTtJQUNmO0FBQ0o7QUFLeUUsQ0FDekUsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGFuYW1vbm5leHRfdWkvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvcmFkaW8vZGlzdC9pbXBvcnQubWpzPzMzZTMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHt1c2VGb3JtVmFsaWRhdGlvblN0YXRlIGFzICRmUTJTRiR1c2VGb3JtVmFsaWRhdGlvblN0YXRlfSBmcm9tIFwiQHJlYWN0LXN0YXRlbHkvZm9ybVwiO1xyXG5pbXBvcnQge3VzZUNvbnRyb2xsZWRTdGF0ZSBhcyAkZlEyU0YkdXNlQ29udHJvbGxlZFN0YXRlfSBmcm9tIFwiQHJlYWN0LXN0YXRlbHkvdXRpbHNcIjtcclxuaW1wb3J0IHt1c2VNZW1vIGFzICRmUTJTRiR1c2VNZW1vLCB1c2VTdGF0ZSBhcyAkZlEyU0YkdXNlU3RhdGV9IGZyb20gXCJyZWFjdFwiO1xyXG5cclxuLypcclxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcclxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXHJcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxyXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi8gLypcclxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcclxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXHJcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxyXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi8gXHJcblxyXG5cclxubGV0ICRhNTRjZGM1YzE5NDJiNjM5JHZhciRpbnN0YW5jZSA9IE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDEwMDAwMDAwMDAwKTtcclxubGV0ICRhNTRjZGM1YzE5NDJiNjM5JHZhciRpID0gMDtcclxuZnVuY3Rpb24gJGE1NGNkYzVjMTk0MmI2MzkkZXhwb3J0JGJjYTlkMDI2ZjhlNzA0ZWIocHJvcHMpIHtcclxuICAgIC8vIFByZXNlcnZlZCBoZXJlIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LiBSZWFjdCBBcmlhIG5vdyBnZW5lcmF0ZXMgdGhlIG5hbWUgaW5zdGVhZCBvZiBzdGF0ZWx5LlxyXG4gICAgbGV0IG5hbWUgPSAoMCwgJGZRMlNGJHVzZU1lbW8pKCgpPT5wcm9wcy5uYW1lIHx8IGByYWRpby1ncm91cC0keyRhNTRjZGM1YzE5NDJiNjM5JHZhciRpbnN0YW5jZX0tJHsrKyRhNTRjZGM1YzE5NDJiNjM5JHZhciRpfWAsIFtcclxuICAgICAgICBwcm9wcy5uYW1lXHJcbiAgICBdKTtcclxuICAgIHZhciBfcHJvcHNfZGVmYXVsdFZhbHVlO1xyXG4gICAgbGV0IFtzZWxlY3RlZFZhbHVlLCBzZXRTZWxlY3RlZF0gPSAoMCwgJGZRMlNGJHVzZUNvbnRyb2xsZWRTdGF0ZSkocHJvcHMudmFsdWUsIChfcHJvcHNfZGVmYXVsdFZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlKSAhPT0gbnVsbCAmJiBfcHJvcHNfZGVmYXVsdFZhbHVlICE9PSB2b2lkIDAgPyBfcHJvcHNfZGVmYXVsdFZhbHVlIDogbnVsbCwgcHJvcHMub25DaGFuZ2UpO1xyXG4gICAgbGV0IFtsYXN0Rm9jdXNlZFZhbHVlLCBzZXRMYXN0Rm9jdXNlZFZhbHVlXSA9ICgwLCAkZlEyU0YkdXNlU3RhdGUpKG51bGwpO1xyXG4gICAgbGV0IHZhbGlkYXRpb24gPSAoMCwgJGZRMlNGJHVzZUZvcm1WYWxpZGF0aW9uU3RhdGUpKHtcclxuICAgICAgICAuLi5wcm9wcyxcclxuICAgICAgICB2YWx1ZTogc2VsZWN0ZWRWYWx1ZVxyXG4gICAgfSk7XHJcbiAgICBsZXQgc2V0U2VsZWN0ZWRWYWx1ZSA9ICh2YWx1ZSk9PntcclxuICAgICAgICBpZiAoIXByb3BzLmlzUmVhZE9ubHkgJiYgIXByb3BzLmlzRGlzYWJsZWQpIHtcclxuICAgICAgICAgICAgc2V0U2VsZWN0ZWQodmFsdWUpO1xyXG4gICAgICAgICAgICB2YWxpZGF0aW9uLmNvbW1pdFZhbGlkYXRpb24oKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgbGV0IGlzSW52YWxpZCA9IHZhbGlkYXRpb24uZGlzcGxheVZhbGlkYXRpb24uaXNJbnZhbGlkO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICAuLi52YWxpZGF0aW9uLFxyXG4gICAgICAgIG5hbWU6IG5hbWUsXHJcbiAgICAgICAgc2VsZWN0ZWRWYWx1ZTogc2VsZWN0ZWRWYWx1ZSxcclxuICAgICAgICBzZXRTZWxlY3RlZFZhbHVlOiBzZXRTZWxlY3RlZFZhbHVlLFxyXG4gICAgICAgIGxhc3RGb2N1c2VkVmFsdWU6IGxhc3RGb2N1c2VkVmFsdWUsXHJcbiAgICAgICAgc2V0TGFzdEZvY3VzZWRWYWx1ZTogc2V0TGFzdEZvY3VzZWRWYWx1ZSxcclxuICAgICAgICBpc0Rpc2FibGVkOiBwcm9wcy5pc0Rpc2FibGVkIHx8IGZhbHNlLFxyXG4gICAgICAgIGlzUmVhZE9ubHk6IHByb3BzLmlzUmVhZE9ubHkgfHwgZmFsc2UsXHJcbiAgICAgICAgaXNSZXF1aXJlZDogcHJvcHMuaXNSZXF1aXJlZCB8fCBmYWxzZSxcclxuICAgICAgICB2YWxpZGF0aW9uU3RhdGU6IHByb3BzLnZhbGlkYXRpb25TdGF0ZSB8fCAoaXNJbnZhbGlkID8gXCJpbnZhbGlkXCIgOiBudWxsKSxcclxuICAgICAgICBpc0ludmFsaWQ6IGlzSW52YWxpZFxyXG4gICAgfTtcclxufVxyXG5cclxuXHJcblxyXG5cclxuZXhwb3J0IHskYTU0Y2RjNWMxOTQyYjYzOSRleHBvcnQkYmNhOWQwMjZmOGU3MDRlYiBhcyB1c2VSYWRpb0dyb3VwU3RhdGV9O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGUuanMubWFwXHJcbiJdLCJuYW1lcyI6WyJ1c2VGb3JtVmFsaWRhdGlvblN0YXRlIiwiJGZRMlNGJHVzZUZvcm1WYWxpZGF0aW9uU3RhdGUiLCJ1c2VDb250cm9sbGVkU3RhdGUiLCIkZlEyU0YkdXNlQ29udHJvbGxlZFN0YXRlIiwidXNlTWVtbyIsIiRmUTJTRiR1c2VNZW1vIiwidXNlU3RhdGUiLCIkZlEyU0YkdXNlU3RhdGUiLCIkYTU0Y2RjNWMxOTQyYjYzOSR2YXIkaW5zdGFuY2UiLCJNYXRoIiwicm91bmQiLCJyYW5kb20iLCIkYTU0Y2RjNWMxOTQyYjYzOSR2YXIkaSIsIiRhNTRjZGM1YzE5NDJiNjM5JGV4cG9ydCRiY2E5ZDAyNmY4ZTcwNGViIiwicHJvcHMiLCJuYW1lIiwiX3Byb3BzX2RlZmF1bHRWYWx1ZSIsInNlbGVjdGVkVmFsdWUiLCJzZXRTZWxlY3RlZCIsInZhbHVlIiwiZGVmYXVsdFZhbHVlIiwib25DaGFuZ2UiLCJsYXN0Rm9jdXNlZFZhbHVlIiwic2V0TGFzdEZvY3VzZWRWYWx1ZSIsInZhbGlkYXRpb24iLCJzZXRTZWxlY3RlZFZhbHVlIiwiaXNSZWFkT25seSIsImlzRGlzYWJsZWQiLCJjb21taXRWYWxpZGF0aW9uIiwiaXNJbnZhbGlkIiwiZGlzcGxheVZhbGlkYXRpb24iLCJpc1JlcXVpcmVkIiwidmFsaWRhdGlvblN0YXRlIiwidXNlUmFkaW9Hcm91cFN0YXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/radio/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/selection/dist/import.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@react-stately/selection/dist/import.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SelectionManager: () => (/* binding */ $d496c0a20b6e58ec$export$6c8a5aaad13c9852),\n/* harmony export */   useMultipleSelectionState: () => (/* binding */ $7af3f5b51489e0b5$export$253fe78d46329472)\n/* harmony export */ });\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-stately/collections */ \"(ssr)/./node_modules/@react-stately/collections/dist/import.mjs\");\n\n\n\n/*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ /*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ /*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ class $e40ea825a81a3709$export$52baac22726c72bf extends Set {\n    constructor(keys, anchorKey, currentKey){\n        super(keys);\n        if (keys instanceof $e40ea825a81a3709$export$52baac22726c72bf) {\n            this.anchorKey = anchorKey || keys.anchorKey;\n            this.currentKey = currentKey || keys.currentKey;\n        } else {\n            this.anchorKey = anchorKey;\n            this.currentKey = currentKey;\n        }\n    }\n}\nfunction $7af3f5b51489e0b5$var$equalSets(setA, setB) {\n    if (setA.size !== setB.size) return false;\n    for (let item of setA){\n        if (!setB.has(item)) return false;\n    }\n    return true;\n}\nfunction $7af3f5b51489e0b5$export$253fe78d46329472(props) {\n    let { selectionMode: selectionMode = \"none\", disallowEmptySelection: disallowEmptySelection, allowDuplicateSelectionEvents: allowDuplicateSelectionEvents, selectionBehavior: selectionBehaviorProp = \"toggle\", disabledBehavior: disabledBehavior = \"all\" } = props;\n    // We want synchronous updates to `isFocused` and `focusedKey` after their setters are called.\n    // But we also need to trigger a react re-render. So, we have both a ref (sync) and state (async).\n    let isFocusedRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    let [, setFocused] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    let focusedKeyRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    let childFocusStrategyRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    let [, setFocusedKey] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    let selectedKeysProp = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>$7af3f5b51489e0b5$var$convertSelection(props.selectedKeys), [\n        props.selectedKeys\n    ]);\n    let defaultSelectedKeys = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>$7af3f5b51489e0b5$var$convertSelection(props.defaultSelectedKeys, new (0, $e40ea825a81a3709$export$52baac22726c72bf)()), [\n        props.defaultSelectedKeys\n    ]);\n    let [selectedKeys, setSelectedKeys] = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.useControlledState)(selectedKeysProp, defaultSelectedKeys, props.onSelectionChange);\n    let disabledKeysProp = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>props.disabledKeys ? new Set(props.disabledKeys) : new Set(), [\n        props.disabledKeys\n    ]);\n    let [selectionBehavior, setSelectionBehavior] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(selectionBehaviorProp);\n    // If the selectionBehavior prop is set to replace, but the current state is toggle (e.g. due to long press\n    // to enter selection mode on touch), and the selection becomes empty, reset the selection behavior.\n    if (selectionBehaviorProp === \"replace\" && selectionBehavior === \"toggle\" && typeof selectedKeys === \"object\" && selectedKeys.size === 0) setSelectionBehavior(\"replace\");\n    // If the selectionBehavior prop changes, update the state as well.\n    let lastSelectionBehavior = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(selectionBehaviorProp);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (selectionBehaviorProp !== lastSelectionBehavior.current) {\n            setSelectionBehavior(selectionBehaviorProp);\n            lastSelectionBehavior.current = selectionBehaviorProp;\n        }\n    }, [\n        selectionBehaviorProp\n    ]);\n    return {\n        selectionMode: selectionMode,\n        disallowEmptySelection: disallowEmptySelection,\n        selectionBehavior: selectionBehavior,\n        setSelectionBehavior: setSelectionBehavior,\n        get isFocused () {\n            return isFocusedRef.current;\n        },\n        setFocused (f) {\n            isFocusedRef.current = f;\n            setFocused(f);\n        },\n        get focusedKey () {\n            return focusedKeyRef.current;\n        },\n        get childFocusStrategy () {\n            return childFocusStrategyRef.current;\n        },\n        setFocusedKey (k, childFocusStrategy = \"first\") {\n            focusedKeyRef.current = k;\n            childFocusStrategyRef.current = childFocusStrategy;\n            setFocusedKey(k);\n        },\n        selectedKeys: selectedKeys,\n        setSelectedKeys (keys) {\n            if (allowDuplicateSelectionEvents || !$7af3f5b51489e0b5$var$equalSets(keys, selectedKeys)) setSelectedKeys(keys);\n        },\n        disabledKeys: disabledKeysProp,\n        disabledBehavior: disabledBehavior\n    };\n}\nfunction $7af3f5b51489e0b5$var$convertSelection(selection, defaultValue) {\n    if (!selection) return defaultValue;\n    return selection === \"all\" ? \"all\" : new (0, $e40ea825a81a3709$export$52baac22726c72bf)(selection);\n}\n/*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ class $d496c0a20b6e58ec$export$6c8a5aaad13c9852 {\n    /**\r\n   * The type of selection that is allowed in the collection.\r\n   */ get selectionMode() {\n        return this.state.selectionMode;\n    }\n    /**\r\n   * Whether the collection allows empty selection.\r\n   */ get disallowEmptySelection() {\n        return this.state.disallowEmptySelection;\n    }\n    /**\r\n   * The selection behavior for the collection.\r\n   */ get selectionBehavior() {\n        return this.state.selectionBehavior;\n    }\n    /**\r\n   * Sets the selection behavior for the collection.\r\n   */ setSelectionBehavior(selectionBehavior) {\n        this.state.setSelectionBehavior(selectionBehavior);\n    }\n    /**\r\n   * Whether the collection is currently focused.\r\n   */ get isFocused() {\n        return this.state.isFocused;\n    }\n    /**\r\n   * Sets whether the collection is focused.\r\n   */ setFocused(isFocused) {\n        this.state.setFocused(isFocused);\n    }\n    /**\r\n   * The current focused key in the collection.\r\n   */ get focusedKey() {\n        return this.state.focusedKey;\n    }\n    /** Whether the first or last child of the focused key should receive focus. */ get childFocusStrategy() {\n        return this.state.childFocusStrategy;\n    }\n    /**\r\n   * Sets the focused key.\r\n   */ setFocusedKey(key, childFocusStrategy) {\n        if (key == null || this.collection.getItem(key)) this.state.setFocusedKey(key, childFocusStrategy);\n    }\n    /**\r\n   * The currently selected keys in the collection.\r\n   */ get selectedKeys() {\n        return this.state.selectedKeys === \"all\" ? new Set(this.getSelectAllKeys()) : this.state.selectedKeys;\n    }\n    /**\r\n   * The raw selection value for the collection.\r\n   * Either 'all' for select all, or a set of keys.\r\n   */ get rawSelection() {\n        return this.state.selectedKeys;\n    }\n    /**\r\n   * Returns whether a key is selected.\r\n   */ isSelected(key) {\n        if (this.state.selectionMode === \"none\") return false;\n        key = this.getKey(key);\n        return this.state.selectedKeys === \"all\" ? this.canSelectItem(key) : this.state.selectedKeys.has(key);\n    }\n    /**\r\n   * Whether the selection is empty.\r\n   */ get isEmpty() {\n        return this.state.selectedKeys !== \"all\" && this.state.selectedKeys.size === 0;\n    }\n    /**\r\n   * Whether all items in the collection are selected.\r\n   */ get isSelectAll() {\n        if (this.isEmpty) return false;\n        if (this.state.selectedKeys === \"all\") return true;\n        if (this._isSelectAll != null) return this._isSelectAll;\n        let allKeys = this.getSelectAllKeys();\n        let selectedKeys = this.state.selectedKeys;\n        this._isSelectAll = allKeys.every((k)=>selectedKeys.has(k));\n        return this._isSelectAll;\n    }\n    get firstSelectedKey() {\n        let first = null;\n        for (let key of this.state.selectedKeys){\n            let item = this.collection.getItem(key);\n            if (!first || item && (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.compareNodeOrder)(this.collection, item, first) < 0) first = item;\n        }\n        return first === null || first === void 0 ? void 0 : first.key;\n    }\n    get lastSelectedKey() {\n        let last = null;\n        for (let key of this.state.selectedKeys){\n            let item = this.collection.getItem(key);\n            if (!last || item && (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.compareNodeOrder)(this.collection, item, last) > 0) last = item;\n        }\n        return last === null || last === void 0 ? void 0 : last.key;\n    }\n    get disabledKeys() {\n        return this.state.disabledKeys;\n    }\n    get disabledBehavior() {\n        return this.state.disabledBehavior;\n    }\n    /**\r\n   * Extends the selection to the given key.\r\n   */ extendSelection(toKey) {\n        if (this.selectionMode === \"none\") return;\n        if (this.selectionMode === \"single\") {\n            this.replaceSelection(toKey);\n            return;\n        }\n        toKey = this.getKey(toKey);\n        let selection;\n        // Only select the one key if coming from a select all.\n        if (this.state.selectedKeys === \"all\") selection = new (0, $e40ea825a81a3709$export$52baac22726c72bf)([\n            toKey\n        ], toKey, toKey);\n        else {\n            let selectedKeys = this.state.selectedKeys;\n            let anchorKey = selectedKeys.anchorKey || toKey;\n            selection = new (0, $e40ea825a81a3709$export$52baac22726c72bf)(selectedKeys, anchorKey, toKey);\n            for (let key of this.getKeyRange(anchorKey, selectedKeys.currentKey || toKey))selection.delete(key);\n            for (let key of this.getKeyRange(toKey, anchorKey))if (this.canSelectItem(key)) selection.add(key);\n        }\n        this.state.setSelectedKeys(selection);\n    }\n    getKeyRange(from, to) {\n        let fromItem = this.collection.getItem(from);\n        let toItem = this.collection.getItem(to);\n        if (fromItem && toItem) {\n            if ((0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.compareNodeOrder)(this.collection, fromItem, toItem) <= 0) return this.getKeyRangeInternal(from, to);\n            return this.getKeyRangeInternal(to, from);\n        }\n        return [];\n    }\n    getKeyRangeInternal(from, to) {\n        let keys = [];\n        let key = from;\n        while(key){\n            let item = this.collection.getItem(key);\n            if (item && item.type === \"item\" || item.type === \"cell\" && this.allowsCellSelection) keys.push(key);\n            if (key === to) return keys;\n            key = this.collection.getKeyAfter(key);\n        }\n        return [];\n    }\n    getKey(key) {\n        let item = this.collection.getItem(key);\n        if (!item) return key;\n        // If cell selection is allowed, just return the key.\n        if (item.type === \"cell\" && this.allowsCellSelection) return key;\n        // Find a parent item to select\n        while(item.type !== \"item\" && item.parentKey != null)item = this.collection.getItem(item.parentKey);\n        if (!item || item.type !== \"item\") return null;\n        return item.key;\n    }\n    /**\r\n   * Toggles whether the given key is selected.\r\n   */ toggleSelection(key) {\n        if (this.selectionMode === \"none\") return;\n        if (this.selectionMode === \"single\" && !this.isSelected(key)) {\n            this.replaceSelection(key);\n            return;\n        }\n        key = this.getKey(key);\n        if (key == null) return;\n        let keys = new (0, $e40ea825a81a3709$export$52baac22726c72bf)(this.state.selectedKeys === \"all\" ? this.getSelectAllKeys() : this.state.selectedKeys);\n        if (keys.has(key)) keys.delete(key);\n        else if (this.canSelectItem(key)) {\n            keys.add(key);\n            keys.anchorKey = key;\n            keys.currentKey = key;\n        }\n        if (this.disallowEmptySelection && keys.size === 0) return;\n        this.state.setSelectedKeys(keys);\n    }\n    /**\r\n   * Replaces the selection with only the given key.\r\n   */ replaceSelection(key) {\n        if (this.selectionMode === \"none\") return;\n        key = this.getKey(key);\n        if (key == null) return;\n        let selection = this.canSelectItem(key) ? new (0, $e40ea825a81a3709$export$52baac22726c72bf)([\n            key\n        ], key, key) : new (0, $e40ea825a81a3709$export$52baac22726c72bf)();\n        this.state.setSelectedKeys(selection);\n    }\n    /**\r\n   * Replaces the selection with the given keys.\r\n   */ setSelectedKeys(keys) {\n        if (this.selectionMode === \"none\") return;\n        let selection = new (0, $e40ea825a81a3709$export$52baac22726c72bf)();\n        for (let key of keys){\n            key = this.getKey(key);\n            if (key != null) {\n                selection.add(key);\n                if (this.selectionMode === \"single\") break;\n            }\n        }\n        this.state.setSelectedKeys(selection);\n    }\n    getSelectAllKeys() {\n        let keys = [];\n        let addKeys = (key)=>{\n            while(key){\n                if (this.canSelectItem(key)) {\n                    let item = this.collection.getItem(key);\n                    if (item.type === \"item\") keys.push(key);\n                    // Add child keys. If cell selection is allowed, then include item children too.\n                    if (item.hasChildNodes && (this.allowsCellSelection || item.type !== \"item\")) addKeys((0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.getFirstItem)((0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.getChildNodes)(item, this.collection)).key);\n                }\n                key = this.collection.getKeyAfter(key);\n            }\n        };\n        addKeys(this.collection.getFirstKey());\n        return keys;\n    }\n    /**\r\n   * Selects all items in the collection.\r\n   */ selectAll() {\n        if (!this.isSelectAll && this.selectionMode === \"multiple\") this.state.setSelectedKeys(\"all\");\n    }\n    /**\r\n   * Removes all keys from the selection.\r\n   */ clearSelection() {\n        if (!this.disallowEmptySelection && (this.state.selectedKeys === \"all\" || this.state.selectedKeys.size > 0)) this.state.setSelectedKeys(new (0, $e40ea825a81a3709$export$52baac22726c72bf)());\n    }\n    /**\r\n   * Toggles between select all and an empty selection.\r\n   */ toggleSelectAll() {\n        if (this.isSelectAll) this.clearSelection();\n        else this.selectAll();\n    }\n    select(key, e) {\n        if (this.selectionMode === \"none\") return;\n        if (this.selectionMode === \"single\") {\n            if (this.isSelected(key) && !this.disallowEmptySelection) this.toggleSelection(key);\n            else this.replaceSelection(key);\n        } else if (this.selectionBehavior === \"toggle\" || e && (e.pointerType === \"touch\" || e.pointerType === \"virtual\")) this.toggleSelection(key);\n        else this.replaceSelection(key);\n    }\n    /**\r\n   * Returns whether the current selection is equal to the given selection.\r\n   */ isSelectionEqual(selection) {\n        if (selection === this.state.selectedKeys) return true;\n        // Check if the set of keys match.\n        let selectedKeys = this.selectedKeys;\n        if (selection.size !== selectedKeys.size) return false;\n        for (let key of selection){\n            if (!selectedKeys.has(key)) return false;\n        }\n        for (let key of selectedKeys){\n            if (!selection.has(key)) return false;\n        }\n        return true;\n    }\n    canSelectItem(key) {\n        if (this.state.selectionMode === \"none\" || this.state.disabledKeys.has(key)) return false;\n        let item = this.collection.getItem(key);\n        if (!item || item.type === \"cell\" && !this.allowsCellSelection) return false;\n        return true;\n    }\n    isDisabled(key) {\n        return this.state.disabledKeys.has(key) && this.state.disabledBehavior === \"all\";\n    }\n    isLink(key) {\n        var _this_collection_getItem_props, _this_collection_getItem;\n        return !!((_this_collection_getItem = this.collection.getItem(key)) === null || _this_collection_getItem === void 0 ? void 0 : (_this_collection_getItem_props = _this_collection_getItem.props) === null || _this_collection_getItem_props === void 0 ? void 0 : _this_collection_getItem_props.href);\n    }\n    constructor(collection, state, options){\n        this.collection = collection;\n        this.state = state;\n        var _options_allowsCellSelection;\n        this.allowsCellSelection = (_options_allowsCellSelection = options === null || options === void 0 ? void 0 : options.allowsCellSelection) !== null && _options_allowsCellSelection !== void 0 ? _options_allowsCellSelection : false;\n        this._isSelectAll = null;\n    }\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvc2VsZWN0aW9uL2Rpc3QvaW1wb3J0Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFxRjtBQUNnRDtBQUM4QjtBQUVuSzs7Ozs7Ozs7OztDQVVDLEdBQUc7Ozs7Ozs7Ozs7Q0FVSCxHQUFHOzs7Ozs7Ozs7O0NBVUgsR0FBRyxNQUFNZ0Isa0RBQWtEQztJQUN4REMsWUFBWUMsSUFBSSxFQUFFQyxTQUFTLEVBQUVDLFVBQVUsQ0FBQztRQUNwQyxLQUFLLENBQUNGO1FBQ04sSUFBSUEsZ0JBQWdCSCwyQ0FBMkM7WUFDM0QsSUFBSSxDQUFDSSxTQUFTLEdBQUdBLGFBQWFELEtBQUtDLFNBQVM7WUFDNUMsSUFBSSxDQUFDQyxVQUFVLEdBQUdBLGNBQWNGLEtBQUtFLFVBQVU7UUFDbkQsT0FBTztZQUNILElBQUksQ0FBQ0QsU0FBUyxHQUFHQTtZQUNqQixJQUFJLENBQUNDLFVBQVUsR0FBR0E7UUFDdEI7SUFDSjtBQUNKO0FBS0EsU0FBU0MsZ0NBQWdDQyxJQUFJLEVBQUVDLElBQUk7SUFDL0MsSUFBSUQsS0FBS0UsSUFBSSxLQUFLRCxLQUFLQyxJQUFJLEVBQUUsT0FBTztJQUNwQyxLQUFLLElBQUlDLFFBQVFILEtBQUs7UUFDbEIsSUFBSSxDQUFDQyxLQUFLRyxHQUFHLENBQUNELE9BQU8sT0FBTztJQUNoQztJQUNBLE9BQU87QUFDWDtBQUNBLFNBQVNFLDBDQUEwQ0MsS0FBSztJQUNwRCxJQUFJLEVBQUVDLGVBQWVBLGdCQUFnQixNQUFNLEVBQUVDLHdCQUF3QkEsc0JBQXNCLEVBQUVDLCtCQUErQkEsNkJBQTZCLEVBQUVDLG1CQUFtQkMsd0JBQXdCLFFBQVEsRUFBRUMsa0JBQWtCQSxtQkFBbUIsS0FBSyxFQUFFLEdBQUdOO0lBQy9QLDhGQUE4RjtJQUM5RixrR0FBa0c7SUFDbEcsSUFBSU8sZUFBZSxDQUFDLEdBQUdqQyx5Q0FBWSxFQUFHO0lBQ3RDLElBQUksR0FBR2tDLFdBQVcsR0FBRyxDQUFDLEdBQUdoQywyQ0FBYyxFQUFHO0lBQzFDLElBQUlpQyxnQkFBZ0IsQ0FBQyxHQUFHbkMseUNBQVksRUFBRztJQUN2QyxJQUFJb0Msd0JBQXdCLENBQUMsR0FBR3BDLHlDQUFZLEVBQUc7SUFDL0MsSUFBSSxHQUFHcUMsY0FBYyxHQUFHLENBQUMsR0FBR25DLDJDQUFjLEVBQUc7SUFDN0MsSUFBSW9DLG1CQUFtQixDQUFDLEdBQUdsQywwQ0FBYSxFQUFHLElBQUltQyx1Q0FBdUNiLE1BQU1jLFlBQVksR0FBRztRQUN2R2QsTUFBTWMsWUFBWTtLQUNyQjtJQUNELElBQUlDLHNCQUFzQixDQUFDLEdBQUdyQywwQ0FBYSxFQUFHLElBQUltQyx1Q0FBdUNiLE1BQU1lLG1CQUFtQixFQUFFLElBQUssSUFBRzVCLHlDQUF3QyxNQUFPO1FBQ3ZLYSxNQUFNZSxtQkFBbUI7S0FDNUI7SUFDRCxJQUFJLENBQUNELGNBQWNFLGdCQUFnQixHQUFHLENBQUMsR0FBRzVDLG9FQUF3QixFQUFHd0Msa0JBQWtCRyxxQkFBcUJmLE1BQU1pQixpQkFBaUI7SUFDbkksSUFBSUMsbUJBQW1CLENBQUMsR0FBR3hDLDBDQUFhLEVBQUcsSUFBSXNCLE1BQU1tQixZQUFZLEdBQUcsSUFBSS9CLElBQUlZLE1BQU1tQixZQUFZLElBQUksSUFBSS9CLE9BQU87UUFDekdZLE1BQU1tQixZQUFZO0tBQ3JCO0lBQ0QsSUFBSSxDQUFDZixtQkFBbUJnQixxQkFBcUIsR0FBRyxDQUFDLEdBQUc1QywyQ0FBYyxFQUFHNkI7SUFDckUsMkdBQTJHO0lBQzNHLG9HQUFvRztJQUNwRyxJQUFJQSwwQkFBMEIsYUFBYUQsc0JBQXNCLFlBQVksT0FBT1UsaUJBQWlCLFlBQVlBLGFBQWFsQixJQUFJLEtBQUssR0FBR3dCLHFCQUFxQjtJQUMvSixtRUFBbUU7SUFDbkUsSUFBSUMsd0JBQXdCLENBQUMsR0FBRy9DLHlDQUFZLEVBQUcrQjtJQUM5QyxJQUFHekIsNENBQWUsRUFBRztRQUNsQixJQUFJeUIsMEJBQTBCZ0Isc0JBQXNCQyxPQUFPLEVBQUU7WUFDekRGLHFCQUFxQmY7WUFDckJnQixzQkFBc0JDLE9BQU8sR0FBR2pCO1FBQ3BDO0lBQ0osR0FBRztRQUNDQTtLQUNIO0lBQ0QsT0FBTztRQUNISixlQUFlQTtRQUNmQyx3QkFBd0JBO1FBQ3hCRSxtQkFBbUJBO1FBQ25CZ0Isc0JBQXNCQTtRQUN0QixJQUFJRyxhQUFhO1lBQ2IsT0FBT2hCLGFBQWFlLE9BQU87UUFDL0I7UUFDQWQsWUFBWWdCLENBQUM7WUFDVGpCLGFBQWFlLE9BQU8sR0FBR0U7WUFDdkJoQixXQUFXZ0I7UUFDZjtRQUNBLElBQUlDLGNBQWM7WUFDZCxPQUFPaEIsY0FBY2EsT0FBTztRQUNoQztRQUNBLElBQUlJLHNCQUFzQjtZQUN0QixPQUFPaEIsc0JBQXNCWSxPQUFPO1FBQ3hDO1FBQ0FYLGVBQWVnQixDQUFDLEVBQUVELHFCQUFxQixPQUFPO1lBQzFDakIsY0FBY2EsT0FBTyxHQUFHSztZQUN4QmpCLHNCQUFzQlksT0FBTyxHQUFHSTtZQUNoQ2YsY0FBY2dCO1FBQ2xCO1FBQ0FiLGNBQWNBO1FBQ2RFLGlCQUFpQjFCLElBQUk7WUFDakIsSUFBSWEsaUNBQWlDLENBQUNWLGdDQUFnQ0gsTUFBTXdCLGVBQWVFLGdCQUFnQjFCO1FBQy9HO1FBQ0E2QixjQUFjRDtRQUNkWixrQkFBa0JBO0lBQ3RCO0FBQ0o7QUFDQSxTQUFTTyx1Q0FBdUNlLFNBQVMsRUFBRUMsWUFBWTtJQUNuRSxJQUFJLENBQUNELFdBQVcsT0FBT0M7SUFDdkIsT0FBT0QsY0FBYyxRQUFRLFFBQVEsSUFBSyxJQUFHekMseUNBQXdDLEVBQUd5QztBQUM1RjtBQUdBOzs7Ozs7Ozs7O0NBVUMsR0FFRCxNQUFNRTtJQUNGOztHQUVELEdBQUcsSUFBSTdCLGdCQUFnQjtRQUNsQixPQUFPLElBQUksQ0FBQzhCLEtBQUssQ0FBQzlCLGFBQWE7SUFDbkM7SUFDQTs7R0FFRCxHQUFHLElBQUlDLHlCQUF5QjtRQUMzQixPQUFPLElBQUksQ0FBQzZCLEtBQUssQ0FBQzdCLHNCQUFzQjtJQUM1QztJQUNBOztHQUVELEdBQUcsSUFBSUUsb0JBQW9CO1FBQ3RCLE9BQU8sSUFBSSxDQUFDMkIsS0FBSyxDQUFDM0IsaUJBQWlCO0lBQ3ZDO0lBQ0E7O0dBRUQsR0FBR2dCLHFCQUFxQmhCLGlCQUFpQixFQUFFO1FBQ3RDLElBQUksQ0FBQzJCLEtBQUssQ0FBQ1gsb0JBQW9CLENBQUNoQjtJQUNwQztJQUNBOztHQUVELEdBQUcsSUFBSW1CLFlBQVk7UUFDZCxPQUFPLElBQUksQ0FBQ1EsS0FBSyxDQUFDUixTQUFTO0lBQy9CO0lBQ0E7O0dBRUQsR0FBR2YsV0FBV2UsU0FBUyxFQUFFO1FBQ3BCLElBQUksQ0FBQ1EsS0FBSyxDQUFDdkIsVUFBVSxDQUFDZTtJQUMxQjtJQUNBOztHQUVELEdBQUcsSUFBSUUsYUFBYTtRQUNmLE9BQU8sSUFBSSxDQUFDTSxLQUFLLENBQUNOLFVBQVU7SUFDaEM7SUFDQSw2RUFBNkUsR0FBRyxJQUFJQyxxQkFBcUI7UUFDckcsT0FBTyxJQUFJLENBQUNLLEtBQUssQ0FBQ0wsa0JBQWtCO0lBQ3hDO0lBQ0E7O0dBRUQsR0FBR2YsY0FBY3FCLEdBQUcsRUFBRU4sa0JBQWtCLEVBQUU7UUFDckMsSUFBSU0sT0FBTyxRQUFRLElBQUksQ0FBQ0MsVUFBVSxDQUFDQyxPQUFPLENBQUNGLE1BQU0sSUFBSSxDQUFDRCxLQUFLLENBQUNwQixhQUFhLENBQUNxQixLQUFLTjtJQUNuRjtJQUNBOztHQUVELEdBQUcsSUFBSVosZUFBZTtRQUNqQixPQUFPLElBQUksQ0FBQ2lCLEtBQUssQ0FBQ2pCLFlBQVksS0FBSyxRQUFRLElBQUkxQixJQUFJLElBQUksQ0FBQytDLGdCQUFnQixNQUFNLElBQUksQ0FBQ0osS0FBSyxDQUFDakIsWUFBWTtJQUN6RztJQUNBOzs7R0FHRCxHQUFHLElBQUlzQixlQUFlO1FBQ2pCLE9BQU8sSUFBSSxDQUFDTCxLQUFLLENBQUNqQixZQUFZO0lBQ2xDO0lBQ0E7O0dBRUQsR0FBR3VCLFdBQVdMLEdBQUcsRUFBRTtRQUNkLElBQUksSUFBSSxDQUFDRCxLQUFLLENBQUM5QixhQUFhLEtBQUssUUFBUSxPQUFPO1FBQ2hEK0IsTUFBTSxJQUFJLENBQUNNLE1BQU0sQ0FBQ047UUFDbEIsT0FBTyxJQUFJLENBQUNELEtBQUssQ0FBQ2pCLFlBQVksS0FBSyxRQUFRLElBQUksQ0FBQ3lCLGFBQWEsQ0FBQ1AsT0FBTyxJQUFJLENBQUNELEtBQUssQ0FBQ2pCLFlBQVksQ0FBQ2hCLEdBQUcsQ0FBQ2tDO0lBQ3JHO0lBQ0E7O0dBRUQsR0FBRyxJQUFJUSxVQUFVO1FBQ1osT0FBTyxJQUFJLENBQUNULEtBQUssQ0FBQ2pCLFlBQVksS0FBSyxTQUFTLElBQUksQ0FBQ2lCLEtBQUssQ0FBQ2pCLFlBQVksQ0FBQ2xCLElBQUksS0FBSztJQUNqRjtJQUNBOztHQUVELEdBQUcsSUFBSTZDLGNBQWM7UUFDaEIsSUFBSSxJQUFJLENBQUNELE9BQU8sRUFBRSxPQUFPO1FBQ3pCLElBQUksSUFBSSxDQUFDVCxLQUFLLENBQUNqQixZQUFZLEtBQUssT0FBTyxPQUFPO1FBQzlDLElBQUksSUFBSSxDQUFDNEIsWUFBWSxJQUFJLE1BQU0sT0FBTyxJQUFJLENBQUNBLFlBQVk7UUFDdkQsSUFBSUMsVUFBVSxJQUFJLENBQUNSLGdCQUFnQjtRQUNuQyxJQUFJckIsZUFBZSxJQUFJLENBQUNpQixLQUFLLENBQUNqQixZQUFZO1FBQzFDLElBQUksQ0FBQzRCLFlBQVksR0FBR0MsUUFBUUMsS0FBSyxDQUFDLENBQUNqQixJQUFJYixhQUFhaEIsR0FBRyxDQUFDNkI7UUFDeEQsT0FBTyxJQUFJLENBQUNlLFlBQVk7SUFDNUI7SUFDQSxJQUFJRyxtQkFBbUI7UUFDbkIsSUFBSUMsUUFBUTtRQUNaLEtBQUssSUFBSWQsT0FBTyxJQUFJLENBQUNELEtBQUssQ0FBQ2pCLFlBQVksQ0FBQztZQUNwQyxJQUFJakIsT0FBTyxJQUFJLENBQUNvQyxVQUFVLENBQUNDLE9BQU8sQ0FBQ0Y7WUFDbkMsSUFBSSxDQUFDYyxTQUFTakQsUUFBUSxDQUFDLEdBQUdmLHdFQUFzQixFQUFHLElBQUksQ0FBQ21ELFVBQVUsRUFBRXBDLE1BQU1pRCxTQUFTLEdBQUdBLFFBQVFqRDtRQUNsRztRQUNBLE9BQU9pRCxVQUFVLFFBQVFBLFVBQVUsS0FBSyxJQUFJLEtBQUssSUFBSUEsTUFBTWQsR0FBRztJQUNsRTtJQUNBLElBQUllLGtCQUFrQjtRQUNsQixJQUFJQyxPQUFPO1FBQ1gsS0FBSyxJQUFJaEIsT0FBTyxJQUFJLENBQUNELEtBQUssQ0FBQ2pCLFlBQVksQ0FBQztZQUNwQyxJQUFJakIsT0FBTyxJQUFJLENBQUNvQyxVQUFVLENBQUNDLE9BQU8sQ0FBQ0Y7WUFDbkMsSUFBSSxDQUFDZ0IsUUFBUW5ELFFBQVEsQ0FBQyxHQUFHZix3RUFBc0IsRUFBRyxJQUFJLENBQUNtRCxVQUFVLEVBQUVwQyxNQUFNbUQsUUFBUSxHQUFHQSxPQUFPbkQ7UUFDL0Y7UUFDQSxPQUFPbUQsU0FBUyxRQUFRQSxTQUFTLEtBQUssSUFBSSxLQUFLLElBQUlBLEtBQUtoQixHQUFHO0lBQy9EO0lBQ0EsSUFBSWIsZUFBZTtRQUNmLE9BQU8sSUFBSSxDQUFDWSxLQUFLLENBQUNaLFlBQVk7SUFDbEM7SUFDQSxJQUFJYixtQkFBbUI7UUFDbkIsT0FBTyxJQUFJLENBQUN5QixLQUFLLENBQUN6QixnQkFBZ0I7SUFDdEM7SUFDQTs7R0FFRCxHQUFHMkMsZ0JBQWdCQyxLQUFLLEVBQUU7UUFDckIsSUFBSSxJQUFJLENBQUNqRCxhQUFhLEtBQUssUUFBUTtRQUNuQyxJQUFJLElBQUksQ0FBQ0EsYUFBYSxLQUFLLFVBQVU7WUFDakMsSUFBSSxDQUFDa0QsZ0JBQWdCLENBQUNEO1lBQ3RCO1FBQ0o7UUFDQUEsUUFBUSxJQUFJLENBQUNaLE1BQU0sQ0FBQ1k7UUFDcEIsSUFBSXRCO1FBQ0osdURBQXVEO1FBQ3ZELElBQUksSUFBSSxDQUFDRyxLQUFLLENBQUNqQixZQUFZLEtBQUssT0FBT2MsWUFBWSxJQUFLLElBQUd6Qyx5Q0FBd0MsRUFBRztZQUNsRytEO1NBQ0gsRUFBRUEsT0FBT0E7YUFDTDtZQUNELElBQUlwQyxlQUFlLElBQUksQ0FBQ2lCLEtBQUssQ0FBQ2pCLFlBQVk7WUFDMUMsSUFBSXZCLFlBQVl1QixhQUFhdkIsU0FBUyxJQUFJMkQ7WUFDMUN0QixZQUFZLElBQUssSUFBR3pDLHlDQUF3QyxFQUFHMkIsY0FBY3ZCLFdBQVcyRDtZQUN4RixLQUFLLElBQUlsQixPQUFPLElBQUksQ0FBQ29CLFdBQVcsQ0FBQzdELFdBQVd1QixhQUFhdEIsVUFBVSxJQUFJMEQsT0FBT3RCLFVBQVV5QixNQUFNLENBQUNyQjtZQUMvRixLQUFLLElBQUlBLE9BQU8sSUFBSSxDQUFDb0IsV0FBVyxDQUFDRixPQUFPM0QsV0FBVyxJQUFJLElBQUksQ0FBQ2dELGFBQWEsQ0FBQ1AsTUFBTUosVUFBVTBCLEdBQUcsQ0FBQ3RCO1FBQ2xHO1FBQ0EsSUFBSSxDQUFDRCxLQUFLLENBQUNmLGVBQWUsQ0FBQ1k7SUFDL0I7SUFDQXdCLFlBQVlHLElBQUksRUFBRUMsRUFBRSxFQUFFO1FBQ2xCLElBQUlDLFdBQVcsSUFBSSxDQUFDeEIsVUFBVSxDQUFDQyxPQUFPLENBQUNxQjtRQUN2QyxJQUFJRyxTQUFTLElBQUksQ0FBQ3pCLFVBQVUsQ0FBQ0MsT0FBTyxDQUFDc0I7UUFDckMsSUFBSUMsWUFBWUMsUUFBUTtZQUNwQixJQUFJLENBQUMsR0FBRzVFLHdFQUFzQixFQUFHLElBQUksQ0FBQ21ELFVBQVUsRUFBRXdCLFVBQVVDLFdBQVcsR0FBRyxPQUFPLElBQUksQ0FBQ0MsbUJBQW1CLENBQUNKLE1BQU1DO1lBQ2hILE9BQU8sSUFBSSxDQUFDRyxtQkFBbUIsQ0FBQ0gsSUFBSUQ7UUFDeEM7UUFDQSxPQUFPLEVBQUU7SUFDYjtJQUNBSSxvQkFBb0JKLElBQUksRUFBRUMsRUFBRSxFQUFFO1FBQzFCLElBQUlsRSxPQUFPLEVBQUU7UUFDYixJQUFJMEMsTUFBTXVCO1FBQ1YsTUFBTXZCLElBQUk7WUFDTixJQUFJbkMsT0FBTyxJQUFJLENBQUNvQyxVQUFVLENBQUNDLE9BQU8sQ0FBQ0Y7WUFDbkMsSUFBSW5DLFFBQVFBLEtBQUsrRCxJQUFJLEtBQUssVUFBVS9ELEtBQUsrRCxJQUFJLEtBQUssVUFBVSxJQUFJLENBQUNDLG1CQUFtQixFQUFFdkUsS0FBS3dFLElBQUksQ0FBQzlCO1lBQ2hHLElBQUlBLFFBQVF3QixJQUFJLE9BQU9sRTtZQUN2QjBDLE1BQU0sSUFBSSxDQUFDQyxVQUFVLENBQUM4QixXQUFXLENBQUMvQjtRQUN0QztRQUNBLE9BQU8sRUFBRTtJQUNiO0lBQ0FNLE9BQU9OLEdBQUcsRUFBRTtRQUNSLElBQUluQyxPQUFPLElBQUksQ0FBQ29DLFVBQVUsQ0FBQ0MsT0FBTyxDQUFDRjtRQUNuQyxJQUFJLENBQUNuQyxNQUNMLE9BQU9tQztRQUNQLHFEQUFxRDtRQUNyRCxJQUFJbkMsS0FBSytELElBQUksS0FBSyxVQUFVLElBQUksQ0FBQ0MsbUJBQW1CLEVBQUUsT0FBTzdCO1FBQzdELCtCQUErQjtRQUMvQixNQUFNbkMsS0FBSytELElBQUksS0FBSyxVQUFVL0QsS0FBS21FLFNBQVMsSUFBSSxLQUFLbkUsT0FBTyxJQUFJLENBQUNvQyxVQUFVLENBQUNDLE9BQU8sQ0FBQ3JDLEtBQUttRSxTQUFTO1FBQ2xHLElBQUksQ0FBQ25FLFFBQVFBLEtBQUsrRCxJQUFJLEtBQUssUUFBUSxPQUFPO1FBQzFDLE9BQU8vRCxLQUFLbUMsR0FBRztJQUNuQjtJQUNBOztHQUVELEdBQUdpQyxnQkFBZ0JqQyxHQUFHLEVBQUU7UUFDbkIsSUFBSSxJQUFJLENBQUMvQixhQUFhLEtBQUssUUFBUTtRQUNuQyxJQUFJLElBQUksQ0FBQ0EsYUFBYSxLQUFLLFlBQVksQ0FBQyxJQUFJLENBQUNvQyxVQUFVLENBQUNMLE1BQU07WUFDMUQsSUFBSSxDQUFDbUIsZ0JBQWdCLENBQUNuQjtZQUN0QjtRQUNKO1FBQ0FBLE1BQU0sSUFBSSxDQUFDTSxNQUFNLENBQUNOO1FBQ2xCLElBQUlBLE9BQU8sTUFBTTtRQUNqQixJQUFJMUMsT0FBTyxJQUFLLElBQUdILHlDQUF3QyxFQUFHLElBQUksQ0FBQzRDLEtBQUssQ0FBQ2pCLFlBQVksS0FBSyxRQUFRLElBQUksQ0FBQ3FCLGdCQUFnQixLQUFLLElBQUksQ0FBQ0osS0FBSyxDQUFDakIsWUFBWTtRQUNuSixJQUFJeEIsS0FBS1EsR0FBRyxDQUFDa0MsTUFBTTFDLEtBQUsrRCxNQUFNLENBQUNyQjthQUMxQixJQUFJLElBQUksQ0FBQ08sYUFBYSxDQUFDUCxNQUFNO1lBQzlCMUMsS0FBS2dFLEdBQUcsQ0FBQ3RCO1lBQ1QxQyxLQUFLQyxTQUFTLEdBQUd5QztZQUNqQjFDLEtBQUtFLFVBQVUsR0FBR3dDO1FBQ3RCO1FBQ0EsSUFBSSxJQUFJLENBQUM5QixzQkFBc0IsSUFBSVosS0FBS00sSUFBSSxLQUFLLEdBQUc7UUFDcEQsSUFBSSxDQUFDbUMsS0FBSyxDQUFDZixlQUFlLENBQUMxQjtJQUMvQjtJQUNBOztHQUVELEdBQUc2RCxpQkFBaUJuQixHQUFHLEVBQUU7UUFDcEIsSUFBSSxJQUFJLENBQUMvQixhQUFhLEtBQUssUUFBUTtRQUNuQytCLE1BQU0sSUFBSSxDQUFDTSxNQUFNLENBQUNOO1FBQ2xCLElBQUlBLE9BQU8sTUFBTTtRQUNqQixJQUFJSixZQUFZLElBQUksQ0FBQ1csYUFBYSxDQUFDUCxPQUFPLElBQUssSUFBRzdDLHlDQUF3QyxFQUFHO1lBQ3pGNkM7U0FDSCxFQUFFQSxLQUFLQSxPQUFPLElBQUssSUFBRzdDLHlDQUF3QztRQUMvRCxJQUFJLENBQUM0QyxLQUFLLENBQUNmLGVBQWUsQ0FBQ1k7SUFDL0I7SUFDQTs7R0FFRCxHQUFHWixnQkFBZ0IxQixJQUFJLEVBQUU7UUFDcEIsSUFBSSxJQUFJLENBQUNXLGFBQWEsS0FBSyxRQUFRO1FBQ25DLElBQUkyQixZQUFZLElBQUssSUFBR3pDLHlDQUF3QztRQUNoRSxLQUFLLElBQUk2QyxPQUFPMUMsS0FBSztZQUNqQjBDLE1BQU0sSUFBSSxDQUFDTSxNQUFNLENBQUNOO1lBQ2xCLElBQUlBLE9BQU8sTUFBTTtnQkFDYkosVUFBVTBCLEdBQUcsQ0FBQ3RCO2dCQUNkLElBQUksSUFBSSxDQUFDL0IsYUFBYSxLQUFLLFVBQVU7WUFDekM7UUFDSjtRQUNBLElBQUksQ0FBQzhCLEtBQUssQ0FBQ2YsZUFBZSxDQUFDWTtJQUMvQjtJQUNBTyxtQkFBbUI7UUFDZixJQUFJN0MsT0FBTyxFQUFFO1FBQ2IsSUFBSTRFLFVBQVUsQ0FBQ2xDO1lBQ1gsTUFBTUEsSUFBSTtnQkFDTixJQUFJLElBQUksQ0FBQ08sYUFBYSxDQUFDUCxNQUFNO29CQUN6QixJQUFJbkMsT0FBTyxJQUFJLENBQUNvQyxVQUFVLENBQUNDLE9BQU8sQ0FBQ0Y7b0JBQ25DLElBQUluQyxLQUFLK0QsSUFBSSxLQUFLLFFBQVF0RSxLQUFLd0UsSUFBSSxDQUFDOUI7b0JBQ3BDLGdGQUFnRjtvQkFDaEYsSUFBSW5DLEtBQUtzRSxhQUFhLElBQUssS0FBSSxDQUFDTixtQkFBbUIsSUFBSWhFLEtBQUsrRCxJQUFJLEtBQUssTUFBSyxHQUFJTSxRQUFRLENBQUMsR0FBR2xGLG9FQUFrQixFQUFHLENBQUMsR0FBR0UscUVBQW1CLEVBQUdXLE1BQU0sSUFBSSxDQUFDb0MsVUFBVSxHQUFHRCxHQUFHO2dCQUN4SztnQkFDQUEsTUFBTSxJQUFJLENBQUNDLFVBQVUsQ0FBQzhCLFdBQVcsQ0FBQy9CO1lBQ3RDO1FBQ0o7UUFDQWtDLFFBQVEsSUFBSSxDQUFDakMsVUFBVSxDQUFDbUMsV0FBVztRQUNuQyxPQUFPOUU7SUFDWDtJQUNBOztHQUVELEdBQUcrRSxZQUFZO1FBQ1YsSUFBSSxDQUFDLElBQUksQ0FBQzVCLFdBQVcsSUFBSSxJQUFJLENBQUN4QyxhQUFhLEtBQUssWUFBWSxJQUFJLENBQUM4QixLQUFLLENBQUNmLGVBQWUsQ0FBQztJQUMzRjtJQUNBOztHQUVELEdBQUdzRCxpQkFBaUI7UUFDZixJQUFJLENBQUMsSUFBSSxDQUFDcEUsc0JBQXNCLElBQUssS0FBSSxDQUFDNkIsS0FBSyxDQUFDakIsWUFBWSxLQUFLLFNBQVMsSUFBSSxDQUFDaUIsS0FBSyxDQUFDakIsWUFBWSxDQUFDbEIsSUFBSSxHQUFHLElBQUksSUFBSSxDQUFDbUMsS0FBSyxDQUFDZixlQUFlLENBQUMsSUFBSyxJQUFHN0IseUNBQXdDO0lBQzVMO0lBQ0E7O0dBRUQsR0FBR29GLGtCQUFrQjtRQUNoQixJQUFJLElBQUksQ0FBQzlCLFdBQVcsRUFBRSxJQUFJLENBQUM2QixjQUFjO2FBQ3BDLElBQUksQ0FBQ0QsU0FBUztJQUN2QjtJQUNBRyxPQUFPeEMsR0FBRyxFQUFFeUMsQ0FBQyxFQUFFO1FBQ1gsSUFBSSxJQUFJLENBQUN4RSxhQUFhLEtBQUssUUFBUTtRQUNuQyxJQUFJLElBQUksQ0FBQ0EsYUFBYSxLQUFLLFVBQVU7WUFDakMsSUFBSSxJQUFJLENBQUNvQyxVQUFVLENBQUNMLFFBQVEsQ0FBQyxJQUFJLENBQUM5QixzQkFBc0IsRUFBRSxJQUFJLENBQUMrRCxlQUFlLENBQUNqQztpQkFDMUUsSUFBSSxDQUFDbUIsZ0JBQWdCLENBQUNuQjtRQUMvQixPQUFPLElBQUksSUFBSSxDQUFDNUIsaUJBQWlCLEtBQUssWUFBWXFFLEtBQU1BLENBQUFBLEVBQUVDLFdBQVcsS0FBSyxXQUFXRCxFQUFFQyxXQUFXLEtBQUssU0FBUSxHQUMvRyxJQUFJLENBQUNULGVBQWUsQ0FBQ2pDO2FBQ2hCLElBQUksQ0FBQ21CLGdCQUFnQixDQUFDbkI7SUFDL0I7SUFDQTs7R0FFRCxHQUFHMkMsaUJBQWlCL0MsU0FBUyxFQUFFO1FBQzFCLElBQUlBLGNBQWMsSUFBSSxDQUFDRyxLQUFLLENBQUNqQixZQUFZLEVBQUUsT0FBTztRQUNsRCxrQ0FBa0M7UUFDbEMsSUFBSUEsZUFBZSxJQUFJLENBQUNBLFlBQVk7UUFDcEMsSUFBSWMsVUFBVWhDLElBQUksS0FBS2tCLGFBQWFsQixJQUFJLEVBQUUsT0FBTztRQUNqRCxLQUFLLElBQUlvQyxPQUFPSixVQUFVO1lBQ3RCLElBQUksQ0FBQ2QsYUFBYWhCLEdBQUcsQ0FBQ2tDLE1BQU0sT0FBTztRQUN2QztRQUNBLEtBQUssSUFBSUEsT0FBT2xCLGFBQWE7WUFDekIsSUFBSSxDQUFDYyxVQUFVOUIsR0FBRyxDQUFDa0MsTUFBTSxPQUFPO1FBQ3BDO1FBQ0EsT0FBTztJQUNYO0lBQ0FPLGNBQWNQLEdBQUcsRUFBRTtRQUNmLElBQUksSUFBSSxDQUFDRCxLQUFLLENBQUM5QixhQUFhLEtBQUssVUFBVSxJQUFJLENBQUM4QixLQUFLLENBQUNaLFlBQVksQ0FBQ3JCLEdBQUcsQ0FBQ2tDLE1BQU0sT0FBTztRQUNwRixJQUFJbkMsT0FBTyxJQUFJLENBQUNvQyxVQUFVLENBQUNDLE9BQU8sQ0FBQ0Y7UUFDbkMsSUFBSSxDQUFDbkMsUUFBUUEsS0FBSytELElBQUksS0FBSyxVQUFVLENBQUMsSUFBSSxDQUFDQyxtQkFBbUIsRUFBRSxPQUFPO1FBQ3ZFLE9BQU87SUFDWDtJQUNBZSxXQUFXNUMsR0FBRyxFQUFFO1FBQ1osT0FBTyxJQUFJLENBQUNELEtBQUssQ0FBQ1osWUFBWSxDQUFDckIsR0FBRyxDQUFDa0MsUUFBUSxJQUFJLENBQUNELEtBQUssQ0FBQ3pCLGdCQUFnQixLQUFLO0lBQy9FO0lBQ0F1RSxPQUFPN0MsR0FBRyxFQUFFO1FBQ1IsSUFBSThDLGdDQUFnQ0M7UUFDcEMsT0FBTyxDQUFDLENBQUUsRUFBQ0EsMkJBQTJCLElBQUksQ0FBQzlDLFVBQVUsQ0FBQ0MsT0FBTyxDQUFDRixJQUFHLE1BQU8sUUFBUStDLDZCQUE2QixLQUFLLElBQUksS0FBSyxJQUFJLENBQUNELGlDQUFpQ0MseUJBQXlCL0UsS0FBSyxNQUFNLFFBQVE4RSxtQ0FBbUMsS0FBSyxJQUFJLEtBQUssSUFBSUEsK0JBQStCRSxJQUFJO0lBQ3pTO0lBQ0EzRixZQUFZNEMsVUFBVSxFQUFFRixLQUFLLEVBQUVrRCxPQUFPLENBQUM7UUFDbkMsSUFBSSxDQUFDaEQsVUFBVSxHQUFHQTtRQUNsQixJQUFJLENBQUNGLEtBQUssR0FBR0E7UUFDYixJQUFJbUQ7UUFDSixJQUFJLENBQUNyQixtQkFBbUIsR0FBRyxDQUFDcUIsK0JBQStCRCxZQUFZLFFBQVFBLFlBQVksS0FBSyxJQUFJLEtBQUssSUFBSUEsUUFBUXBCLG1CQUFtQixNQUFNLFFBQVFxQixpQ0FBaUMsS0FBSyxJQUFJQSwrQkFBK0I7UUFDL04sSUFBSSxDQUFDeEMsWUFBWSxHQUFHO0lBQ3hCO0FBQ0o7QUFLK0ksQ0FDL0ksa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGFuYW1vbm5leHRfdWkvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvc2VsZWN0aW9uL2Rpc3QvaW1wb3J0Lm1qcz9hZWQxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7dXNlQ29udHJvbGxlZFN0YXRlIGFzICRRc3RvMiR1c2VDb250cm9sbGVkU3RhdGV9IGZyb20gXCJAcmVhY3Qtc3RhdGVseS91dGlsc1wiO1xyXG5pbXBvcnQge3VzZVJlZiBhcyAkUXN0bzIkdXNlUmVmLCB1c2VTdGF0ZSBhcyAkUXN0bzIkdXNlU3RhdGUsIHVzZU1lbW8gYXMgJFFzdG8yJHVzZU1lbW8sIHVzZUVmZmVjdCBhcyAkUXN0bzIkdXNlRWZmZWN0fSBmcm9tIFwicmVhY3RcIjtcclxuaW1wb3J0IHtjb21wYXJlTm9kZU9yZGVyIGFzICRRc3RvMiRjb21wYXJlTm9kZU9yZGVyLCBnZXRGaXJzdEl0ZW0gYXMgJFFzdG8yJGdldEZpcnN0SXRlbSwgZ2V0Q2hpbGROb2RlcyBhcyAkUXN0bzIkZ2V0Q2hpbGROb2Rlc30gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L2NvbGxlY3Rpb25zXCI7XHJcblxyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxyXG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcclxuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXHJcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqLyAvKlxyXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxyXG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcclxuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXHJcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqLyAvKlxyXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxyXG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcclxuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXHJcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqLyBjbGFzcyAkZTQwZWE4MjVhODFhMzcwOSRleHBvcnQkNTJiYWFjMjI3MjZjNzJiZiBleHRlbmRzIFNldCB7XHJcbiAgICBjb25zdHJ1Y3RvcihrZXlzLCBhbmNob3JLZXksIGN1cnJlbnRLZXkpe1xyXG4gICAgICAgIHN1cGVyKGtleXMpO1xyXG4gICAgICAgIGlmIChrZXlzIGluc3RhbmNlb2YgJGU0MGVhODI1YTgxYTM3MDkkZXhwb3J0JDUyYmFhYzIyNzI2YzcyYmYpIHtcclxuICAgICAgICAgICAgdGhpcy5hbmNob3JLZXkgPSBhbmNob3JLZXkgfHwga2V5cy5hbmNob3JLZXk7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEtleSA9IGN1cnJlbnRLZXkgfHwga2V5cy5jdXJyZW50S2V5O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuYW5jaG9yS2V5ID0gYW5jaG9yS2V5O1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRLZXkgPSBjdXJyZW50S2V5O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuXHJcblxyXG5cclxuZnVuY3Rpb24gJDdhZjNmNWI1MTQ4OWUwYjUkdmFyJGVxdWFsU2V0cyhzZXRBLCBzZXRCKSB7XHJcbiAgICBpZiAoc2V0QS5zaXplICE9PSBzZXRCLnNpemUpIHJldHVybiBmYWxzZTtcclxuICAgIGZvciAobGV0IGl0ZW0gb2Ygc2V0QSl7XHJcbiAgICAgICAgaWYgKCFzZXRCLmhhcyhpdGVtKSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuZnVuY3Rpb24gJDdhZjNmNWI1MTQ4OWUwYjUkZXhwb3J0JDI1M2ZlNzhkNDYzMjk0NzIocHJvcHMpIHtcclxuICAgIGxldCB7IHNlbGVjdGlvbk1vZGU6IHNlbGVjdGlvbk1vZGUgPSBcIm5vbmVcIiwgZGlzYWxsb3dFbXB0eVNlbGVjdGlvbjogZGlzYWxsb3dFbXB0eVNlbGVjdGlvbiwgYWxsb3dEdXBsaWNhdGVTZWxlY3Rpb25FdmVudHM6IGFsbG93RHVwbGljYXRlU2VsZWN0aW9uRXZlbnRzLCBzZWxlY3Rpb25CZWhhdmlvcjogc2VsZWN0aW9uQmVoYXZpb3JQcm9wID0gXCJ0b2dnbGVcIiwgZGlzYWJsZWRCZWhhdmlvcjogZGlzYWJsZWRCZWhhdmlvciA9IFwiYWxsXCIgfSA9IHByb3BzO1xyXG4gICAgLy8gV2Ugd2FudCBzeW5jaHJvbm91cyB1cGRhdGVzIHRvIGBpc0ZvY3VzZWRgIGFuZCBgZm9jdXNlZEtleWAgYWZ0ZXIgdGhlaXIgc2V0dGVycyBhcmUgY2FsbGVkLlxyXG4gICAgLy8gQnV0IHdlIGFsc28gbmVlZCB0byB0cmlnZ2VyIGEgcmVhY3QgcmUtcmVuZGVyLiBTbywgd2UgaGF2ZSBib3RoIGEgcmVmIChzeW5jKSBhbmQgc3RhdGUgKGFzeW5jKS5cclxuICAgIGxldCBpc0ZvY3VzZWRSZWYgPSAoMCwgJFFzdG8yJHVzZVJlZikoZmFsc2UpO1xyXG4gICAgbGV0IFssIHNldEZvY3VzZWRdID0gKDAsICRRc3RvMiR1c2VTdGF0ZSkoZmFsc2UpO1xyXG4gICAgbGV0IGZvY3VzZWRLZXlSZWYgPSAoMCwgJFFzdG8yJHVzZVJlZikobnVsbCk7XHJcbiAgICBsZXQgY2hpbGRGb2N1c1N0cmF0ZWd5UmVmID0gKDAsICRRc3RvMiR1c2VSZWYpKG51bGwpO1xyXG4gICAgbGV0IFssIHNldEZvY3VzZWRLZXldID0gKDAsICRRc3RvMiR1c2VTdGF0ZSkobnVsbCk7XHJcbiAgICBsZXQgc2VsZWN0ZWRLZXlzUHJvcCA9ICgwLCAkUXN0bzIkdXNlTWVtbykoKCk9PiQ3YWYzZjViNTE0ODllMGI1JHZhciRjb252ZXJ0U2VsZWN0aW9uKHByb3BzLnNlbGVjdGVkS2V5cyksIFtcclxuICAgICAgICBwcm9wcy5zZWxlY3RlZEtleXNcclxuICAgIF0pO1xyXG4gICAgbGV0IGRlZmF1bHRTZWxlY3RlZEtleXMgPSAoMCwgJFFzdG8yJHVzZU1lbW8pKCgpPT4kN2FmM2Y1YjUxNDg5ZTBiNSR2YXIkY29udmVydFNlbGVjdGlvbihwcm9wcy5kZWZhdWx0U2VsZWN0ZWRLZXlzLCBuZXcgKDAsICRlNDBlYTgyNWE4MWEzNzA5JGV4cG9ydCQ1MmJhYWMyMjcyNmM3MmJmKSgpKSwgW1xyXG4gICAgICAgIHByb3BzLmRlZmF1bHRTZWxlY3RlZEtleXNcclxuICAgIF0pO1xyXG4gICAgbGV0IFtzZWxlY3RlZEtleXMsIHNldFNlbGVjdGVkS2V5c10gPSAoMCwgJFFzdG8yJHVzZUNvbnRyb2xsZWRTdGF0ZSkoc2VsZWN0ZWRLZXlzUHJvcCwgZGVmYXVsdFNlbGVjdGVkS2V5cywgcHJvcHMub25TZWxlY3Rpb25DaGFuZ2UpO1xyXG4gICAgbGV0IGRpc2FibGVkS2V5c1Byb3AgPSAoMCwgJFFzdG8yJHVzZU1lbW8pKCgpPT5wcm9wcy5kaXNhYmxlZEtleXMgPyBuZXcgU2V0KHByb3BzLmRpc2FibGVkS2V5cykgOiBuZXcgU2V0KCksIFtcclxuICAgICAgICBwcm9wcy5kaXNhYmxlZEtleXNcclxuICAgIF0pO1xyXG4gICAgbGV0IFtzZWxlY3Rpb25CZWhhdmlvciwgc2V0U2VsZWN0aW9uQmVoYXZpb3JdID0gKDAsICRRc3RvMiR1c2VTdGF0ZSkoc2VsZWN0aW9uQmVoYXZpb3JQcm9wKTtcclxuICAgIC8vIElmIHRoZSBzZWxlY3Rpb25CZWhhdmlvciBwcm9wIGlzIHNldCB0byByZXBsYWNlLCBidXQgdGhlIGN1cnJlbnQgc3RhdGUgaXMgdG9nZ2xlIChlLmcuIGR1ZSB0byBsb25nIHByZXNzXHJcbiAgICAvLyB0byBlbnRlciBzZWxlY3Rpb24gbW9kZSBvbiB0b3VjaCksIGFuZCB0aGUgc2VsZWN0aW9uIGJlY29tZXMgZW1wdHksIHJlc2V0IHRoZSBzZWxlY3Rpb24gYmVoYXZpb3IuXHJcbiAgICBpZiAoc2VsZWN0aW9uQmVoYXZpb3JQcm9wID09PSBcInJlcGxhY2VcIiAmJiBzZWxlY3Rpb25CZWhhdmlvciA9PT0gXCJ0b2dnbGVcIiAmJiB0eXBlb2Ygc2VsZWN0ZWRLZXlzID09PSBcIm9iamVjdFwiICYmIHNlbGVjdGVkS2V5cy5zaXplID09PSAwKSBzZXRTZWxlY3Rpb25CZWhhdmlvcihcInJlcGxhY2VcIik7XHJcbiAgICAvLyBJZiB0aGUgc2VsZWN0aW9uQmVoYXZpb3IgcHJvcCBjaGFuZ2VzLCB1cGRhdGUgdGhlIHN0YXRlIGFzIHdlbGwuXHJcbiAgICBsZXQgbGFzdFNlbGVjdGlvbkJlaGF2aW9yID0gKDAsICRRc3RvMiR1c2VSZWYpKHNlbGVjdGlvbkJlaGF2aW9yUHJvcCk7XHJcbiAgICAoMCwgJFFzdG8yJHVzZUVmZmVjdCkoKCk9PntcclxuICAgICAgICBpZiAoc2VsZWN0aW9uQmVoYXZpb3JQcm9wICE9PSBsYXN0U2VsZWN0aW9uQmVoYXZpb3IuY3VycmVudCkge1xyXG4gICAgICAgICAgICBzZXRTZWxlY3Rpb25CZWhhdmlvcihzZWxlY3Rpb25CZWhhdmlvclByb3ApO1xyXG4gICAgICAgICAgICBsYXN0U2VsZWN0aW9uQmVoYXZpb3IuY3VycmVudCA9IHNlbGVjdGlvbkJlaGF2aW9yUHJvcDtcclxuICAgICAgICB9XHJcbiAgICB9LCBbXHJcbiAgICAgICAgc2VsZWN0aW9uQmVoYXZpb3JQcm9wXHJcbiAgICBdKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgc2VsZWN0aW9uTW9kZTogc2VsZWN0aW9uTW9kZSxcclxuICAgICAgICBkaXNhbGxvd0VtcHR5U2VsZWN0aW9uOiBkaXNhbGxvd0VtcHR5U2VsZWN0aW9uLFxyXG4gICAgICAgIHNlbGVjdGlvbkJlaGF2aW9yOiBzZWxlY3Rpb25CZWhhdmlvcixcclxuICAgICAgICBzZXRTZWxlY3Rpb25CZWhhdmlvcjogc2V0U2VsZWN0aW9uQmVoYXZpb3IsXHJcbiAgICAgICAgZ2V0IGlzRm9jdXNlZCAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpc0ZvY3VzZWRSZWYuY3VycmVudDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldEZvY3VzZWQgKGYpIHtcclxuICAgICAgICAgICAgaXNGb2N1c2VkUmVmLmN1cnJlbnQgPSBmO1xyXG4gICAgICAgICAgICBzZXRGb2N1c2VkKGYpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0IGZvY3VzZWRLZXkgKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZm9jdXNlZEtleVJlZi5jdXJyZW50O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0IGNoaWxkRm9jdXNTdHJhdGVneSAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjaGlsZEZvY3VzU3RyYXRlZ3lSZWYuY3VycmVudDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldEZvY3VzZWRLZXkgKGssIGNoaWxkRm9jdXNTdHJhdGVneSA9IFwiZmlyc3RcIikge1xyXG4gICAgICAgICAgICBmb2N1c2VkS2V5UmVmLmN1cnJlbnQgPSBrO1xyXG4gICAgICAgICAgICBjaGlsZEZvY3VzU3RyYXRlZ3lSZWYuY3VycmVudCA9IGNoaWxkRm9jdXNTdHJhdGVneTtcclxuICAgICAgICAgICAgc2V0Rm9jdXNlZEtleShrKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNlbGVjdGVkS2V5czogc2VsZWN0ZWRLZXlzLFxyXG4gICAgICAgIHNldFNlbGVjdGVkS2V5cyAoa2V5cykge1xyXG4gICAgICAgICAgICBpZiAoYWxsb3dEdXBsaWNhdGVTZWxlY3Rpb25FdmVudHMgfHwgISQ3YWYzZjViNTE0ODllMGI1JHZhciRlcXVhbFNldHMoa2V5cywgc2VsZWN0ZWRLZXlzKSkgc2V0U2VsZWN0ZWRLZXlzKGtleXMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGlzYWJsZWRLZXlzOiBkaXNhYmxlZEtleXNQcm9wLFxyXG4gICAgICAgIGRpc2FibGVkQmVoYXZpb3I6IGRpc2FibGVkQmVoYXZpb3JcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gJDdhZjNmNWI1MTQ4OWUwYjUkdmFyJGNvbnZlcnRTZWxlY3Rpb24oc2VsZWN0aW9uLCBkZWZhdWx0VmFsdWUpIHtcclxuICAgIGlmICghc2VsZWN0aW9uKSByZXR1cm4gZGVmYXVsdFZhbHVlO1xyXG4gICAgcmV0dXJuIHNlbGVjdGlvbiA9PT0gXCJhbGxcIiA/IFwiYWxsXCIgOiBuZXcgKDAsICRlNDBlYTgyNWE4MWEzNzA5JGV4cG9ydCQ1MmJhYWMyMjcyNmM3MmJmKShzZWxlY3Rpb24pO1xyXG59XHJcblxyXG5cclxuLypcclxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcclxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXHJcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxyXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi8gXHJcblxyXG5jbGFzcyAkZDQ5NmMwYTIwYjZlNThlYyRleHBvcnQkNmM4YTVhYWFkMTNjOTg1MiB7XHJcbiAgICAvKipcclxuICAgKiBUaGUgdHlwZSBvZiBzZWxlY3Rpb24gdGhhdCBpcyBhbGxvd2VkIGluIHRoZSBjb2xsZWN0aW9uLlxyXG4gICAqLyBnZXQgc2VsZWN0aW9uTW9kZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5zZWxlY3Rpb25Nb2RlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICogV2hldGhlciB0aGUgY29sbGVjdGlvbiBhbGxvd3MgZW1wdHkgc2VsZWN0aW9uLlxyXG4gICAqLyBnZXQgZGlzYWxsb3dFbXB0eVNlbGVjdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5kaXNhbGxvd0VtcHR5U2VsZWN0aW9uO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICogVGhlIHNlbGVjdGlvbiBiZWhhdmlvciBmb3IgdGhlIGNvbGxlY3Rpb24uXHJcbiAgICovIGdldCBzZWxlY3Rpb25CZWhhdmlvcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5zZWxlY3Rpb25CZWhhdmlvcjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAqIFNldHMgdGhlIHNlbGVjdGlvbiBiZWhhdmlvciBmb3IgdGhlIGNvbGxlY3Rpb24uXHJcbiAgICovIHNldFNlbGVjdGlvbkJlaGF2aW9yKHNlbGVjdGlvbkJlaGF2aW9yKSB7XHJcbiAgICAgICAgdGhpcy5zdGF0ZS5zZXRTZWxlY3Rpb25CZWhhdmlvcihzZWxlY3Rpb25CZWhhdmlvcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgKiBXaGV0aGVyIHRoZSBjb2xsZWN0aW9uIGlzIGN1cnJlbnRseSBmb2N1c2VkLlxyXG4gICAqLyBnZXQgaXNGb2N1c2VkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmlzRm9jdXNlZDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAqIFNldHMgd2hldGhlciB0aGUgY29sbGVjdGlvbiBpcyBmb2N1c2VkLlxyXG4gICAqLyBzZXRGb2N1c2VkKGlzRm9jdXNlZCkge1xyXG4gICAgICAgIHRoaXMuc3RhdGUuc2V0Rm9jdXNlZChpc0ZvY3VzZWQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICogVGhlIGN1cnJlbnQgZm9jdXNlZCBrZXkgaW4gdGhlIGNvbGxlY3Rpb24uXHJcbiAgICovIGdldCBmb2N1c2VkS2V5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmZvY3VzZWRLZXk7XHJcbiAgICB9XHJcbiAgICAvKiogV2hldGhlciB0aGUgZmlyc3Qgb3IgbGFzdCBjaGlsZCBvZiB0aGUgZm9jdXNlZCBrZXkgc2hvdWxkIHJlY2VpdmUgZm9jdXMuICovIGdldCBjaGlsZEZvY3VzU3RyYXRlZ3koKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuY2hpbGRGb2N1c1N0cmF0ZWd5O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICogU2V0cyB0aGUgZm9jdXNlZCBrZXkuXHJcbiAgICovIHNldEZvY3VzZWRLZXkoa2V5LCBjaGlsZEZvY3VzU3RyYXRlZ3kpIHtcclxuICAgICAgICBpZiAoa2V5ID09IG51bGwgfHwgdGhpcy5jb2xsZWN0aW9uLmdldEl0ZW0oa2V5KSkgdGhpcy5zdGF0ZS5zZXRGb2N1c2VkS2V5KGtleSwgY2hpbGRGb2N1c1N0cmF0ZWd5KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAqIFRoZSBjdXJyZW50bHkgc2VsZWN0ZWQga2V5cyBpbiB0aGUgY29sbGVjdGlvbi5cclxuICAgKi8gZ2V0IHNlbGVjdGVkS2V5cygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5zZWxlY3RlZEtleXMgPT09IFwiYWxsXCIgPyBuZXcgU2V0KHRoaXMuZ2V0U2VsZWN0QWxsS2V5cygpKSA6IHRoaXMuc3RhdGUuc2VsZWN0ZWRLZXlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICogVGhlIHJhdyBzZWxlY3Rpb24gdmFsdWUgZm9yIHRoZSBjb2xsZWN0aW9uLlxyXG4gICAqIEVpdGhlciAnYWxsJyBmb3Igc2VsZWN0IGFsbCwgb3IgYSBzZXQgb2Yga2V5cy5cclxuICAgKi8gZ2V0IHJhd1NlbGVjdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5zZWxlY3RlZEtleXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgKiBSZXR1cm5zIHdoZXRoZXIgYSBrZXkgaXMgc2VsZWN0ZWQuXHJcbiAgICovIGlzU2VsZWN0ZWQoa2V5KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuc2VsZWN0aW9uTW9kZSA9PT0gXCJub25lXCIpIHJldHVybiBmYWxzZTtcclxuICAgICAgICBrZXkgPSB0aGlzLmdldEtleShrZXkpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLnNlbGVjdGVkS2V5cyA9PT0gXCJhbGxcIiA/IHRoaXMuY2FuU2VsZWN0SXRlbShrZXkpIDogdGhpcy5zdGF0ZS5zZWxlY3RlZEtleXMuaGFzKGtleSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgKiBXaGV0aGVyIHRoZSBzZWxlY3Rpb24gaXMgZW1wdHkuXHJcbiAgICovIGdldCBpc0VtcHR5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLnNlbGVjdGVkS2V5cyAhPT0gXCJhbGxcIiAmJiB0aGlzLnN0YXRlLnNlbGVjdGVkS2V5cy5zaXplID09PSAwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICogV2hldGhlciBhbGwgaXRlbXMgaW4gdGhlIGNvbGxlY3Rpb24gYXJlIHNlbGVjdGVkLlxyXG4gICAqLyBnZXQgaXNTZWxlY3RBbGwoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNFbXB0eSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnNlbGVjdGVkS2V5cyA9PT0gXCJhbGxcIikgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgaWYgKHRoaXMuX2lzU2VsZWN0QWxsICE9IG51bGwpIHJldHVybiB0aGlzLl9pc1NlbGVjdEFsbDtcclxuICAgICAgICBsZXQgYWxsS2V5cyA9IHRoaXMuZ2V0U2VsZWN0QWxsS2V5cygpO1xyXG4gICAgICAgIGxldCBzZWxlY3RlZEtleXMgPSB0aGlzLnN0YXRlLnNlbGVjdGVkS2V5cztcclxuICAgICAgICB0aGlzLl9pc1NlbGVjdEFsbCA9IGFsbEtleXMuZXZlcnkoKGspPT5zZWxlY3RlZEtleXMuaGFzKGspKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5faXNTZWxlY3RBbGw7XHJcbiAgICB9XHJcbiAgICBnZXQgZmlyc3RTZWxlY3RlZEtleSgpIHtcclxuICAgICAgICBsZXQgZmlyc3QgPSBudWxsO1xyXG4gICAgICAgIGZvciAobGV0IGtleSBvZiB0aGlzLnN0YXRlLnNlbGVjdGVkS2V5cyl7XHJcbiAgICAgICAgICAgIGxldCBpdGVtID0gdGhpcy5jb2xsZWN0aW9uLmdldEl0ZW0oa2V5KTtcclxuICAgICAgICAgICAgaWYgKCFmaXJzdCB8fCBpdGVtICYmICgwLCAkUXN0bzIkY29tcGFyZU5vZGVPcmRlcikodGhpcy5jb2xsZWN0aW9uLCBpdGVtLCBmaXJzdCkgPCAwKSBmaXJzdCA9IGl0ZW07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmaXJzdCA9PT0gbnVsbCB8fCBmaXJzdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmlyc3Qua2V5O1xyXG4gICAgfVxyXG4gICAgZ2V0IGxhc3RTZWxlY3RlZEtleSgpIHtcclxuICAgICAgICBsZXQgbGFzdCA9IG51bGw7XHJcbiAgICAgICAgZm9yIChsZXQga2V5IG9mIHRoaXMuc3RhdGUuc2VsZWN0ZWRLZXlzKXtcclxuICAgICAgICAgICAgbGV0IGl0ZW0gPSB0aGlzLmNvbGxlY3Rpb24uZ2V0SXRlbShrZXkpO1xyXG4gICAgICAgICAgICBpZiAoIWxhc3QgfHwgaXRlbSAmJiAoMCwgJFFzdG8yJGNvbXBhcmVOb2RlT3JkZXIpKHRoaXMuY29sbGVjdGlvbiwgaXRlbSwgbGFzdCkgPiAwKSBsYXN0ID0gaXRlbTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGxhc3QgPT09IG51bGwgfHwgbGFzdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGFzdC5rZXk7XHJcbiAgICB9XHJcbiAgICBnZXQgZGlzYWJsZWRLZXlzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmRpc2FibGVkS2V5cztcclxuICAgIH1cclxuICAgIGdldCBkaXNhYmxlZEJlaGF2aW9yKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmRpc2FibGVkQmVoYXZpb3I7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgKiBFeHRlbmRzIHRoZSBzZWxlY3Rpb24gdG8gdGhlIGdpdmVuIGtleS5cclxuICAgKi8gZXh0ZW5kU2VsZWN0aW9uKHRvS2V5KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uTW9kZSA9PT0gXCJub25lXCIpIHJldHVybjtcclxuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25Nb2RlID09PSBcInNpbmdsZVwiKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVwbGFjZVNlbGVjdGlvbih0b0tleSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdG9LZXkgPSB0aGlzLmdldEtleSh0b0tleSk7XHJcbiAgICAgICAgbGV0IHNlbGVjdGlvbjtcclxuICAgICAgICAvLyBPbmx5IHNlbGVjdCB0aGUgb25lIGtleSBpZiBjb21pbmcgZnJvbSBhIHNlbGVjdCBhbGwuXHJcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuc2VsZWN0ZWRLZXlzID09PSBcImFsbFwiKSBzZWxlY3Rpb24gPSBuZXcgKDAsICRlNDBlYTgyNWE4MWEzNzA5JGV4cG9ydCQ1MmJhYWMyMjcyNmM3MmJmKShbXHJcbiAgICAgICAgICAgIHRvS2V5XHJcbiAgICAgICAgXSwgdG9LZXksIHRvS2V5KTtcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbGV0IHNlbGVjdGVkS2V5cyA9IHRoaXMuc3RhdGUuc2VsZWN0ZWRLZXlzO1xyXG4gICAgICAgICAgICBsZXQgYW5jaG9yS2V5ID0gc2VsZWN0ZWRLZXlzLmFuY2hvcktleSB8fCB0b0tleTtcclxuICAgICAgICAgICAgc2VsZWN0aW9uID0gbmV3ICgwLCAkZTQwZWE4MjVhODFhMzcwOSRleHBvcnQkNTJiYWFjMjI3MjZjNzJiZikoc2VsZWN0ZWRLZXlzLCBhbmNob3JLZXksIHRvS2V5KTtcclxuICAgICAgICAgICAgZm9yIChsZXQga2V5IG9mIHRoaXMuZ2V0S2V5UmFuZ2UoYW5jaG9yS2V5LCBzZWxlY3RlZEtleXMuY3VycmVudEtleSB8fCB0b0tleSkpc2VsZWN0aW9uLmRlbGV0ZShrZXkpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBrZXkgb2YgdGhpcy5nZXRLZXlSYW5nZSh0b0tleSwgYW5jaG9yS2V5KSlpZiAodGhpcy5jYW5TZWxlY3RJdGVtKGtleSkpIHNlbGVjdGlvbi5hZGQoa2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zdGF0ZS5zZXRTZWxlY3RlZEtleXMoc2VsZWN0aW9uKTtcclxuICAgIH1cclxuICAgIGdldEtleVJhbmdlKGZyb20sIHRvKSB7XHJcbiAgICAgICAgbGV0IGZyb21JdGVtID0gdGhpcy5jb2xsZWN0aW9uLmdldEl0ZW0oZnJvbSk7XHJcbiAgICAgICAgbGV0IHRvSXRlbSA9IHRoaXMuY29sbGVjdGlvbi5nZXRJdGVtKHRvKTtcclxuICAgICAgICBpZiAoZnJvbUl0ZW0gJiYgdG9JdGVtKSB7XHJcbiAgICAgICAgICAgIGlmICgoMCwgJFFzdG8yJGNvbXBhcmVOb2RlT3JkZXIpKHRoaXMuY29sbGVjdGlvbiwgZnJvbUl0ZW0sIHRvSXRlbSkgPD0gMCkgcmV0dXJuIHRoaXMuZ2V0S2V5UmFuZ2VJbnRlcm5hbChmcm9tLCB0byk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEtleVJhbmdlSW50ZXJuYWwodG8sIGZyb20pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgICBnZXRLZXlSYW5nZUludGVybmFsKGZyb20sIHRvKSB7XHJcbiAgICAgICAgbGV0IGtleXMgPSBbXTtcclxuICAgICAgICBsZXQga2V5ID0gZnJvbTtcclxuICAgICAgICB3aGlsZShrZXkpe1xyXG4gICAgICAgICAgICBsZXQgaXRlbSA9IHRoaXMuY29sbGVjdGlvbi5nZXRJdGVtKGtleSk7XHJcbiAgICAgICAgICAgIGlmIChpdGVtICYmIGl0ZW0udHlwZSA9PT0gXCJpdGVtXCIgfHwgaXRlbS50eXBlID09PSBcImNlbGxcIiAmJiB0aGlzLmFsbG93c0NlbGxTZWxlY3Rpb24pIGtleXMucHVzaChrZXkpO1xyXG4gICAgICAgICAgICBpZiAoa2V5ID09PSB0bykgcmV0dXJuIGtleXM7XHJcbiAgICAgICAgICAgIGtleSA9IHRoaXMuY29sbGVjdGlvbi5nZXRLZXlBZnRlcihrZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgICBnZXRLZXkoa2V5KSB7XHJcbiAgICAgICAgbGV0IGl0ZW0gPSB0aGlzLmNvbGxlY3Rpb24uZ2V0SXRlbShrZXkpO1xyXG4gICAgICAgIGlmICghaXRlbSkgLy8gwq9cXF8o44OEKV8vwq9cclxuICAgICAgICByZXR1cm4ga2V5O1xyXG4gICAgICAgIC8vIElmIGNlbGwgc2VsZWN0aW9uIGlzIGFsbG93ZWQsIGp1c3QgcmV0dXJuIHRoZSBrZXkuXHJcbiAgICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gXCJjZWxsXCIgJiYgdGhpcy5hbGxvd3NDZWxsU2VsZWN0aW9uKSByZXR1cm4ga2V5O1xyXG4gICAgICAgIC8vIEZpbmQgYSBwYXJlbnQgaXRlbSB0byBzZWxlY3RcclxuICAgICAgICB3aGlsZShpdGVtLnR5cGUgIT09IFwiaXRlbVwiICYmIGl0ZW0ucGFyZW50S2V5ICE9IG51bGwpaXRlbSA9IHRoaXMuY29sbGVjdGlvbi5nZXRJdGVtKGl0ZW0ucGFyZW50S2V5KTtcclxuICAgICAgICBpZiAoIWl0ZW0gfHwgaXRlbS50eXBlICE9PSBcIml0ZW1cIikgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgcmV0dXJuIGl0ZW0ua2V5O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICogVG9nZ2xlcyB3aGV0aGVyIHRoZSBnaXZlbiBrZXkgaXMgc2VsZWN0ZWQuXHJcbiAgICovIHRvZ2dsZVNlbGVjdGlvbihrZXkpIHtcclxuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25Nb2RlID09PSBcIm5vbmVcIikgcmV0dXJuO1xyXG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk1vZGUgPT09IFwic2luZ2xlXCIgJiYgIXRoaXMuaXNTZWxlY3RlZChrZXkpKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVwbGFjZVNlbGVjdGlvbihrZXkpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGtleSA9IHRoaXMuZ2V0S2V5KGtleSk7XHJcbiAgICAgICAgaWYgKGtleSA9PSBudWxsKSByZXR1cm47XHJcbiAgICAgICAgbGV0IGtleXMgPSBuZXcgKDAsICRlNDBlYTgyNWE4MWEzNzA5JGV4cG9ydCQ1MmJhYWMyMjcyNmM3MmJmKSh0aGlzLnN0YXRlLnNlbGVjdGVkS2V5cyA9PT0gXCJhbGxcIiA/IHRoaXMuZ2V0U2VsZWN0QWxsS2V5cygpIDogdGhpcy5zdGF0ZS5zZWxlY3RlZEtleXMpO1xyXG4gICAgICAgIGlmIChrZXlzLmhhcyhrZXkpKSBrZXlzLmRlbGV0ZShrZXkpO1xyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuY2FuU2VsZWN0SXRlbShrZXkpKSB7XHJcbiAgICAgICAgICAgIGtleXMuYWRkKGtleSk7XHJcbiAgICAgICAgICAgIGtleXMuYW5jaG9yS2V5ID0ga2V5O1xyXG4gICAgICAgICAgICBrZXlzLmN1cnJlbnRLZXkgPSBrZXk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmRpc2FsbG93RW1wdHlTZWxlY3Rpb24gJiYga2V5cy5zaXplID09PSAwKSByZXR1cm47XHJcbiAgICAgICAgdGhpcy5zdGF0ZS5zZXRTZWxlY3RlZEtleXMoa2V5cyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgKiBSZXBsYWNlcyB0aGUgc2VsZWN0aW9uIHdpdGggb25seSB0aGUgZ2l2ZW4ga2V5LlxyXG4gICAqLyByZXBsYWNlU2VsZWN0aW9uKGtleSkge1xyXG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk1vZGUgPT09IFwibm9uZVwiKSByZXR1cm47XHJcbiAgICAgICAga2V5ID0gdGhpcy5nZXRLZXkoa2V5KTtcclxuICAgICAgICBpZiAoa2V5ID09IG51bGwpIHJldHVybjtcclxuICAgICAgICBsZXQgc2VsZWN0aW9uID0gdGhpcy5jYW5TZWxlY3RJdGVtKGtleSkgPyBuZXcgKDAsICRlNDBlYTgyNWE4MWEzNzA5JGV4cG9ydCQ1MmJhYWMyMjcyNmM3MmJmKShbXHJcbiAgICAgICAgICAgIGtleVxyXG4gICAgICAgIF0sIGtleSwga2V5KSA6IG5ldyAoMCwgJGU0MGVhODI1YTgxYTM3MDkkZXhwb3J0JDUyYmFhYzIyNzI2YzcyYmYpKCk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZS5zZXRTZWxlY3RlZEtleXMoc2VsZWN0aW9uKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAqIFJlcGxhY2VzIHRoZSBzZWxlY3Rpb24gd2l0aCB0aGUgZ2l2ZW4ga2V5cy5cclxuICAgKi8gc2V0U2VsZWN0ZWRLZXlzKGtleXMpIHtcclxuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25Nb2RlID09PSBcIm5vbmVcIikgcmV0dXJuO1xyXG4gICAgICAgIGxldCBzZWxlY3Rpb24gPSBuZXcgKDAsICRlNDBlYTgyNWE4MWEzNzA5JGV4cG9ydCQ1MmJhYWMyMjcyNmM3MmJmKSgpO1xyXG4gICAgICAgIGZvciAobGV0IGtleSBvZiBrZXlzKXtcclxuICAgICAgICAgICAga2V5ID0gdGhpcy5nZXRLZXkoa2V5KTtcclxuICAgICAgICAgICAgaWYgKGtleSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24uYWRkKGtleSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25Nb2RlID09PSBcInNpbmdsZVwiKSBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnN0YXRlLnNldFNlbGVjdGVkS2V5cyhzZWxlY3Rpb24pO1xyXG4gICAgfVxyXG4gICAgZ2V0U2VsZWN0QWxsS2V5cygpIHtcclxuICAgICAgICBsZXQga2V5cyA9IFtdO1xyXG4gICAgICAgIGxldCBhZGRLZXlzID0gKGtleSk9PntcclxuICAgICAgICAgICAgd2hpbGUoa2V5KXtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNhblNlbGVjdEl0ZW0oa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBpdGVtID0gdGhpcy5jb2xsZWN0aW9uLmdldEl0ZW0oa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS50eXBlID09PSBcIml0ZW1cIikga2V5cy5wdXNoKGtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGNoaWxkIGtleXMuIElmIGNlbGwgc2VsZWN0aW9uIGlzIGFsbG93ZWQsIHRoZW4gaW5jbHVkZSBpdGVtIGNoaWxkcmVuIHRvby5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5oYXNDaGlsZE5vZGVzICYmICh0aGlzLmFsbG93c0NlbGxTZWxlY3Rpb24gfHwgaXRlbS50eXBlICE9PSBcIml0ZW1cIikpIGFkZEtleXMoKDAsICRRc3RvMiRnZXRGaXJzdEl0ZW0pKCgwLCAkUXN0bzIkZ2V0Q2hpbGROb2RlcykoaXRlbSwgdGhpcy5jb2xsZWN0aW9uKSkua2V5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGtleSA9IHRoaXMuY29sbGVjdGlvbi5nZXRLZXlBZnRlcihrZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBhZGRLZXlzKHRoaXMuY29sbGVjdGlvbi5nZXRGaXJzdEtleSgpKTtcclxuICAgICAgICByZXR1cm4ga2V5cztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAqIFNlbGVjdHMgYWxsIGl0ZW1zIGluIHRoZSBjb2xsZWN0aW9uLlxyXG4gICAqLyBzZWxlY3RBbGwoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzU2VsZWN0QWxsICYmIHRoaXMuc2VsZWN0aW9uTW9kZSA9PT0gXCJtdWx0aXBsZVwiKSB0aGlzLnN0YXRlLnNldFNlbGVjdGVkS2V5cyhcImFsbFwiKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAqIFJlbW92ZXMgYWxsIGtleXMgZnJvbSB0aGUgc2VsZWN0aW9uLlxyXG4gICAqLyBjbGVhclNlbGVjdGlvbigpIHtcclxuICAgICAgICBpZiAoIXRoaXMuZGlzYWxsb3dFbXB0eVNlbGVjdGlvbiAmJiAodGhpcy5zdGF0ZS5zZWxlY3RlZEtleXMgPT09IFwiYWxsXCIgfHwgdGhpcy5zdGF0ZS5zZWxlY3RlZEtleXMuc2l6ZSA+IDApKSB0aGlzLnN0YXRlLnNldFNlbGVjdGVkS2V5cyhuZXcgKDAsICRlNDBlYTgyNWE4MWEzNzA5JGV4cG9ydCQ1MmJhYWMyMjcyNmM3MmJmKSgpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAqIFRvZ2dsZXMgYmV0d2VlbiBzZWxlY3QgYWxsIGFuZCBhbiBlbXB0eSBzZWxlY3Rpb24uXHJcbiAgICovIHRvZ2dsZVNlbGVjdEFsbCgpIHtcclxuICAgICAgICBpZiAodGhpcy5pc1NlbGVjdEFsbCkgdGhpcy5jbGVhclNlbGVjdGlvbigpO1xyXG4gICAgICAgIGVsc2UgdGhpcy5zZWxlY3RBbGwoKTtcclxuICAgIH1cclxuICAgIHNlbGVjdChrZXksIGUpIHtcclxuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25Nb2RlID09PSBcIm5vbmVcIikgcmV0dXJuO1xyXG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk1vZGUgPT09IFwic2luZ2xlXCIpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNTZWxlY3RlZChrZXkpICYmICF0aGlzLmRpc2FsbG93RW1wdHlTZWxlY3Rpb24pIHRoaXMudG9nZ2xlU2VsZWN0aW9uKGtleSk7XHJcbiAgICAgICAgICAgIGVsc2UgdGhpcy5yZXBsYWNlU2VsZWN0aW9uKGtleSk7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnNlbGVjdGlvbkJlaGF2aW9yID09PSBcInRvZ2dsZVwiIHx8IGUgJiYgKGUucG9pbnRlclR5cGUgPT09IFwidG91Y2hcIiB8fCBlLnBvaW50ZXJUeXBlID09PSBcInZpcnR1YWxcIikpIC8vIGlmIHRvdWNoIG9yIHZpcnR1YWwgKFZPKSB0aGVuIHdlIGp1c3Qgd2FudCB0byB0b2dnbGUsIG90aGVyd2lzZSBpdCdzIGltcG9zc2libGUgdG8gbXVsdGkgc2VsZWN0IGJlY2F1c2UgdGhleSBkb24ndCBoYXZlIG1vZGlmaWVyIGtleXNcclxuICAgICAgICB0aGlzLnRvZ2dsZVNlbGVjdGlvbihrZXkpO1xyXG4gICAgICAgIGVsc2UgdGhpcy5yZXBsYWNlU2VsZWN0aW9uKGtleSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIGlzIGVxdWFsIHRvIHRoZSBnaXZlbiBzZWxlY3Rpb24uXHJcbiAgICovIGlzU2VsZWN0aW9uRXF1YWwoc2VsZWN0aW9uKSB7XHJcbiAgICAgICAgaWYgKHNlbGVjdGlvbiA9PT0gdGhpcy5zdGF0ZS5zZWxlY3RlZEtleXMpIHJldHVybiB0cnVlO1xyXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBzZXQgb2Yga2V5cyBtYXRjaC5cclxuICAgICAgICBsZXQgc2VsZWN0ZWRLZXlzID0gdGhpcy5zZWxlY3RlZEtleXM7XHJcbiAgICAgICAgaWYgKHNlbGVjdGlvbi5zaXplICE9PSBzZWxlY3RlZEtleXMuc2l6ZSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGZvciAobGV0IGtleSBvZiBzZWxlY3Rpb24pe1xyXG4gICAgICAgICAgICBpZiAoIXNlbGVjdGVkS2V5cy5oYXMoa2V5KSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBrZXkgb2Ygc2VsZWN0ZWRLZXlzKXtcclxuICAgICAgICAgICAgaWYgKCFzZWxlY3Rpb24uaGFzKGtleSkpIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBjYW5TZWxlY3RJdGVtKGtleSkge1xyXG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnNlbGVjdGlvbk1vZGUgPT09IFwibm9uZVwiIHx8IHRoaXMuc3RhdGUuZGlzYWJsZWRLZXlzLmhhcyhrZXkpKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgbGV0IGl0ZW0gPSB0aGlzLmNvbGxlY3Rpb24uZ2V0SXRlbShrZXkpO1xyXG4gICAgICAgIGlmICghaXRlbSB8fCBpdGVtLnR5cGUgPT09IFwiY2VsbFwiICYmICF0aGlzLmFsbG93c0NlbGxTZWxlY3Rpb24pIHJldHVybiBmYWxzZTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlzRGlzYWJsZWQoa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuZGlzYWJsZWRLZXlzLmhhcyhrZXkpICYmIHRoaXMuc3RhdGUuZGlzYWJsZWRCZWhhdmlvciA9PT0gXCJhbGxcIjtcclxuICAgIH1cclxuICAgIGlzTGluayhrZXkpIHtcclxuICAgICAgICB2YXIgX3RoaXNfY29sbGVjdGlvbl9nZXRJdGVtX3Byb3BzLCBfdGhpc19jb2xsZWN0aW9uX2dldEl0ZW07XHJcbiAgICAgICAgcmV0dXJuICEhKChfdGhpc19jb2xsZWN0aW9uX2dldEl0ZW0gPSB0aGlzLmNvbGxlY3Rpb24uZ2V0SXRlbShrZXkpKSA9PT0gbnVsbCB8fCBfdGhpc19jb2xsZWN0aW9uX2dldEl0ZW0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfdGhpc19jb2xsZWN0aW9uX2dldEl0ZW1fcHJvcHMgPSBfdGhpc19jb2xsZWN0aW9uX2dldEl0ZW0ucHJvcHMpID09PSBudWxsIHx8IF90aGlzX2NvbGxlY3Rpb25fZ2V0SXRlbV9wcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXNfY29sbGVjdGlvbl9nZXRJdGVtX3Byb3BzLmhyZWYpO1xyXG4gICAgfVxyXG4gICAgY29uc3RydWN0b3IoY29sbGVjdGlvbiwgc3RhdGUsIG9wdGlvbnMpe1xyXG4gICAgICAgIHRoaXMuY29sbGVjdGlvbiA9IGNvbGxlY3Rpb247XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xyXG4gICAgICAgIHZhciBfb3B0aW9uc19hbGxvd3NDZWxsU2VsZWN0aW9uO1xyXG4gICAgICAgIHRoaXMuYWxsb3dzQ2VsbFNlbGVjdGlvbiA9IChfb3B0aW9uc19hbGxvd3NDZWxsU2VsZWN0aW9uID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmFsbG93c0NlbGxTZWxlY3Rpb24pICE9PSBudWxsICYmIF9vcHRpb25zX2FsbG93c0NlbGxTZWxlY3Rpb24gIT09IHZvaWQgMCA/IF9vcHRpb25zX2FsbG93c0NlbGxTZWxlY3Rpb24gOiBmYWxzZTtcclxuICAgICAgICB0aGlzLl9pc1NlbGVjdEFsbCA9IG51bGw7XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5cclxuXHJcbmV4cG9ydCB7JDdhZjNmNWI1MTQ4OWUwYjUkZXhwb3J0JDI1M2ZlNzhkNDYzMjk0NzIgYXMgdXNlTXVsdGlwbGVTZWxlY3Rpb25TdGF0ZSwgJGQ0OTZjMGEyMGI2ZTU4ZWMkZXhwb3J0JDZjOGE1YWFhZDEzYzk4NTIgYXMgU2VsZWN0aW9uTWFuYWdlcn07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsZS5qcy5tYXBcclxuIl0sIm5hbWVzIjpbInVzZUNvbnRyb2xsZWRTdGF0ZSIsIiRRc3RvMiR1c2VDb250cm9sbGVkU3RhdGUiLCJ1c2VSZWYiLCIkUXN0bzIkdXNlUmVmIiwidXNlU3RhdGUiLCIkUXN0bzIkdXNlU3RhdGUiLCJ1c2VNZW1vIiwiJFFzdG8yJHVzZU1lbW8iLCJ1c2VFZmZlY3QiLCIkUXN0bzIkdXNlRWZmZWN0IiwiY29tcGFyZU5vZGVPcmRlciIsIiRRc3RvMiRjb21wYXJlTm9kZU9yZGVyIiwiZ2V0Rmlyc3RJdGVtIiwiJFFzdG8yJGdldEZpcnN0SXRlbSIsImdldENoaWxkTm9kZXMiLCIkUXN0bzIkZ2V0Q2hpbGROb2RlcyIsIiRlNDBlYTgyNWE4MWEzNzA5JGV4cG9ydCQ1MmJhYWMyMjcyNmM3MmJmIiwiU2V0IiwiY29uc3RydWN0b3IiLCJrZXlzIiwiYW5jaG9yS2V5IiwiY3VycmVudEtleSIsIiQ3YWYzZjViNTE0ODllMGI1JHZhciRlcXVhbFNldHMiLCJzZXRBIiwic2V0QiIsInNpemUiLCJpdGVtIiwiaGFzIiwiJDdhZjNmNWI1MTQ4OWUwYjUkZXhwb3J0JDI1M2ZlNzhkNDYzMjk0NzIiLCJwcm9wcyIsInNlbGVjdGlvbk1vZGUiLCJkaXNhbGxvd0VtcHR5U2VsZWN0aW9uIiwiYWxsb3dEdXBsaWNhdGVTZWxlY3Rpb25FdmVudHMiLCJzZWxlY3Rpb25CZWhhdmlvciIsInNlbGVjdGlvbkJlaGF2aW9yUHJvcCIsImRpc2FibGVkQmVoYXZpb3IiLCJpc0ZvY3VzZWRSZWYiLCJzZXRGb2N1c2VkIiwiZm9jdXNlZEtleVJlZiIsImNoaWxkRm9jdXNTdHJhdGVneVJlZiIsInNldEZvY3VzZWRLZXkiLCJzZWxlY3RlZEtleXNQcm9wIiwiJDdhZjNmNWI1MTQ4OWUwYjUkdmFyJGNvbnZlcnRTZWxlY3Rpb24iLCJzZWxlY3RlZEtleXMiLCJkZWZhdWx0U2VsZWN0ZWRLZXlzIiwic2V0U2VsZWN0ZWRLZXlzIiwib25TZWxlY3Rpb25DaGFuZ2UiLCJkaXNhYmxlZEtleXNQcm9wIiwiZGlzYWJsZWRLZXlzIiwic2V0U2VsZWN0aW9uQmVoYXZpb3IiLCJsYXN0U2VsZWN0aW9uQmVoYXZpb3IiLCJjdXJyZW50IiwiaXNGb2N1c2VkIiwiZiIsImZvY3VzZWRLZXkiLCJjaGlsZEZvY3VzU3RyYXRlZ3kiLCJrIiwic2VsZWN0aW9uIiwiZGVmYXVsdFZhbHVlIiwiJGQ0OTZjMGEyMGI2ZTU4ZWMkZXhwb3J0JDZjOGE1YWFhZDEzYzk4NTIiLCJzdGF0ZSIsImtleSIsImNvbGxlY3Rpb24iLCJnZXRJdGVtIiwiZ2V0U2VsZWN0QWxsS2V5cyIsInJhd1NlbGVjdGlvbiIsImlzU2VsZWN0ZWQiLCJnZXRLZXkiLCJjYW5TZWxlY3RJdGVtIiwiaXNFbXB0eSIsImlzU2VsZWN0QWxsIiwiX2lzU2VsZWN0QWxsIiwiYWxsS2V5cyIsImV2ZXJ5IiwiZmlyc3RTZWxlY3RlZEtleSIsImZpcnN0IiwibGFzdFNlbGVjdGVkS2V5IiwibGFzdCIsImV4dGVuZFNlbGVjdGlvbiIsInRvS2V5IiwicmVwbGFjZVNlbGVjdGlvbiIsImdldEtleVJhbmdlIiwiZGVsZXRlIiwiYWRkIiwiZnJvbSIsInRvIiwiZnJvbUl0ZW0iLCJ0b0l0ZW0iLCJnZXRLZXlSYW5nZUludGVybmFsIiwidHlwZSIsImFsbG93c0NlbGxTZWxlY3Rpb24iLCJwdXNoIiwiZ2V0S2V5QWZ0ZXIiLCJwYXJlbnRLZXkiLCJ0b2dnbGVTZWxlY3Rpb24iLCJhZGRLZXlzIiwiaGFzQ2hpbGROb2RlcyIsImdldEZpcnN0S2V5Iiwic2VsZWN0QWxsIiwiY2xlYXJTZWxlY3Rpb24iLCJ0b2dnbGVTZWxlY3RBbGwiLCJzZWxlY3QiLCJlIiwicG9pbnRlclR5cGUiLCJpc1NlbGVjdGlvbkVxdWFsIiwiaXNEaXNhYmxlZCIsImlzTGluayIsIl90aGlzX2NvbGxlY3Rpb25fZ2V0SXRlbV9wcm9wcyIsIl90aGlzX2NvbGxlY3Rpb25fZ2V0SXRlbSIsImhyZWYiLCJvcHRpb25zIiwiX29wdGlvbnNfYWxsb3dzQ2VsbFNlbGVjdGlvbiIsInVzZU11bHRpcGxlU2VsZWN0aW9uU3RhdGUiLCJTZWxlY3Rpb25NYW5hZ2VyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/selection/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/slider/dist/import.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@react-stately/slider/dist/import.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useSliderState: () => (/* binding */ $28f99e3e86e6ec45$export$e5fda3247f5d67f9)\n/* harmony export */ });\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n\n/*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ /*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ const $28f99e3e86e6ec45$var$DEFAULT_MIN_VALUE = 0;\nconst $28f99e3e86e6ec45$var$DEFAULT_MAX_VALUE = 100;\nconst $28f99e3e86e6ec45$var$DEFAULT_STEP_VALUE = 1;\nfunction $28f99e3e86e6ec45$export$e5fda3247f5d67f9(props) {\n    const { isDisabled: isDisabled = false, minValue: minValue = $28f99e3e86e6ec45$var$DEFAULT_MIN_VALUE, maxValue: maxValue = $28f99e3e86e6ec45$var$DEFAULT_MAX_VALUE, numberFormatter: formatter, step: step = $28f99e3e86e6ec45$var$DEFAULT_STEP_VALUE, orientation: orientation = \"horizontal\" } = props;\n    // Page step should be at least equal to step and always a multiple of the step.\n    let pageSize = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        let calcPageSize = (maxValue - minValue) / 10;\n        calcPageSize = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.snapValueToStep)(calcPageSize, 0, calcPageSize + step, step);\n        return Math.max(calcPageSize, step);\n    }, [\n        step,\n        maxValue,\n        minValue\n    ]);\n    let restrictValues = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((values)=>values === null || values === void 0 ? void 0 : values.map((val, idx)=>{\n            let min = idx === 0 ? minValue : val[idx - 1];\n            let max = idx === values.length - 1 ? maxValue : val[idx + 1];\n            return (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.snapValueToStep)(val, min, max, step);\n        }), [\n        minValue,\n        maxValue,\n        step\n    ]);\n    let value = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>restrictValues($28f99e3e86e6ec45$var$convertValue(props.value)), [\n        props.value\n    ]);\n    let defaultValue = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        var _convertValue;\n        return restrictValues((_convertValue = $28f99e3e86e6ec45$var$convertValue(props.defaultValue)) !== null && _convertValue !== void 0 ? _convertValue : [\n            minValue\n        ]);\n    }, [\n        props.defaultValue,\n        minValue\n    ]);\n    let onChange = $28f99e3e86e6ec45$var$createOnChange(props.value, props.defaultValue, props.onChange);\n    let onChangeEnd = $28f99e3e86e6ec45$var$createOnChange(props.value, props.defaultValue, props.onChangeEnd);\n    const [values, setValuesState] = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.useControlledState)(value, defaultValue, onChange);\n    const [isDraggings, setDraggingsState] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(new Array(values.length).fill(false));\n    const isEditablesRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(new Array(values.length).fill(true));\n    const [focusedIndex, setFocusedIndex] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(undefined);\n    const valuesRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(values);\n    const isDraggingsRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(isDraggings);\n    let setValues = (values)=>{\n        valuesRef.current = values;\n        setValuesState(values);\n    };\n    let setDraggings = (draggings)=>{\n        isDraggingsRef.current = draggings;\n        setDraggingsState(draggings);\n    };\n    function getValuePercent(value) {\n        return (value - minValue) / (maxValue - minValue);\n    }\n    function getThumbMinValue(index) {\n        return index === 0 ? minValue : values[index - 1];\n    }\n    function getThumbMaxValue(index) {\n        return index === values.length - 1 ? maxValue : values[index + 1];\n    }\n    function isThumbEditable(index) {\n        return isEditablesRef.current[index];\n    }\n    function setThumbEditable(index, editable) {\n        isEditablesRef.current[index] = editable;\n    }\n    function updateValue(index, value) {\n        if (isDisabled || !isThumbEditable(index)) return;\n        const thisMin = getThumbMinValue(index);\n        const thisMax = getThumbMaxValue(index);\n        // Round value to multiple of step, clamp value between min and max\n        value = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.snapValueToStep)(value, thisMin, thisMax, step);\n        let newValues = $28f99e3e86e6ec45$var$replaceIndex(valuesRef.current, index, value);\n        setValues(newValues);\n    }\n    function updateDragging(index, dragging) {\n        if (isDisabled || !isThumbEditable(index)) return;\n        const wasDragging = isDraggingsRef.current[index];\n        isDraggingsRef.current = $28f99e3e86e6ec45$var$replaceIndex(isDraggingsRef.current, index, dragging);\n        setDraggings(isDraggingsRef.current);\n        // Call onChangeEnd if no handles are dragging.\n        if (onChangeEnd && wasDragging && !isDraggingsRef.current.some(Boolean)) onChangeEnd(valuesRef.current);\n    }\n    function getFormattedValue(value) {\n        return formatter.format(value);\n    }\n    function setThumbPercent(index, percent) {\n        updateValue(index, getPercentValue(percent));\n    }\n    function getRoundedValue(value) {\n        return Math.round((value - minValue) / step) * step + minValue;\n    }\n    function getPercentValue(percent) {\n        const val = percent * (maxValue - minValue) + minValue;\n        return (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.clamp)(getRoundedValue(val), minValue, maxValue);\n    }\n    function incrementThumb(index, stepSize = 1) {\n        let s = Math.max(stepSize, step);\n        updateValue(index, (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.snapValueToStep)(values[index] + s, minValue, maxValue, step));\n    }\n    function decrementThumb(index, stepSize = 1) {\n        let s = Math.max(stepSize, step);\n        updateValue(index, (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.snapValueToStep)(values[index] - s, minValue, maxValue, step));\n    }\n    return {\n        values: values,\n        getThumbValue: (index)=>values[index],\n        setThumbValue: updateValue,\n        setThumbPercent: setThumbPercent,\n        isThumbDragging: (index)=>isDraggings[index],\n        setThumbDragging: updateDragging,\n        focusedThumb: focusedIndex,\n        setFocusedThumb: setFocusedIndex,\n        getThumbPercent: (index)=>getValuePercent(values[index]),\n        getValuePercent: getValuePercent,\n        getThumbValueLabel: (index)=>getFormattedValue(values[index]),\n        getFormattedValue: getFormattedValue,\n        getThumbMinValue: getThumbMinValue,\n        getThumbMaxValue: getThumbMaxValue,\n        getPercentValue: getPercentValue,\n        isThumbEditable: isThumbEditable,\n        setThumbEditable: setThumbEditable,\n        incrementThumb: incrementThumb,\n        decrementThumb: decrementThumb,\n        step: step,\n        pageSize: pageSize,\n        orientation: orientation,\n        isDisabled: isDisabled\n    };\n}\nfunction $28f99e3e86e6ec45$var$replaceIndex(array, index, value) {\n    if (array[index] === value) return array;\n    return [\n        ...array.slice(0, index),\n        value,\n        ...array.slice(index + 1)\n    ];\n}\nfunction $28f99e3e86e6ec45$var$convertValue(value) {\n    if (value == null) return undefined;\n    return Array.isArray(value) ? value : [\n        value\n    ];\n}\nfunction $28f99e3e86e6ec45$var$createOnChange(value, defaultValue, onChange) {\n    return (newValue)=>{\n        if (typeof value === \"number\" || typeof defaultValue === \"number\") onChange === null || onChange === void 0 ? void 0 : onChange(newValue[0]);\n        else onChange === null || onChange === void 0 ? void 0 : onChange(newValue);\n    };\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvc2xpZGVyL2Rpc3QvaW1wb3J0Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBdUo7QUFDZDtBQUV6STs7Ozs7Ozs7OztDQVVDLEdBQUc7Ozs7Ozs7Ozs7Q0FVSCxHQUVELE1BQU1jLDBDQUEwQztBQUNoRCxNQUFNQywwQ0FBMEM7QUFDaEQsTUFBTUMsMkNBQTJDO0FBQ2pELFNBQVNDLDBDQUEwQ0MsS0FBSztJQUNwRCxNQUFNLEVBQUVDLFlBQVlBLGFBQWEsS0FBSyxFQUFFQyxVQUFVQSxXQUFXTix1Q0FBdUMsRUFBRU8sVUFBVUEsV0FBV04sdUNBQXVDLEVBQUVPLGlCQUFpQkMsU0FBUyxFQUFFQyxNQUFNQSxPQUFPUix3Q0FBd0MsRUFBRVMsYUFBYUEsY0FBYyxZQUFZLEVBQUUsR0FBR1A7SUFDblMsZ0ZBQWdGO0lBQ2hGLElBQUlRLFdBQVcsQ0FBQyxHQUFHbkIsMENBQWEsRUFBRztRQUMvQixJQUFJb0IsZUFBZSxDQUFDTixXQUFXRCxRQUFPLElBQUs7UUFDM0NPLGVBQWUsQ0FBQyxHQUFHMUIsaUVBQXFCLEVBQUcwQixjQUFjLEdBQUdBLGVBQWVILE1BQU1BO1FBQ2pGLE9BQU9JLEtBQUtDLEdBQUcsQ0FBQ0YsY0FBY0g7SUFDbEMsR0FBRztRQUNDQTtRQUNBSDtRQUNBRDtLQUNIO0lBQ0QsSUFBSVUsaUJBQWlCLENBQUMsR0FBR3JCLDhDQUFpQixFQUFHLENBQUNzQixTQUFTQSxXQUFXLFFBQVFBLFdBQVcsS0FBSyxJQUFJLEtBQUssSUFBSUEsT0FBT0MsR0FBRyxDQUFDLENBQUNDLEtBQUtDO1lBQ2hILElBQUlDLE1BQU1ELFFBQVEsSUFBSWQsV0FBV2EsR0FBRyxDQUFDQyxNQUFNLEVBQUU7WUFDN0MsSUFBSUwsTUFBTUssUUFBUUgsT0FBT0ssTUFBTSxHQUFHLElBQUlmLFdBQVdZLEdBQUcsQ0FBQ0MsTUFBTSxFQUFFO1lBQzdELE9BQU8sQ0FBQyxHQUFHakMsaUVBQXFCLEVBQUdnQyxL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LE9BQU83RCxVQUFVLFlBQVksT0FBT0UsaUJBQWlCLFVBQVVFLGFBQWEsUUFBUUEsYUFBYSxLQUFLLElBQUksS0FBSyxJQUFJQSxTQUFTeUQsUUFBUSxDQUFDLEVBQUU7YUFDdEl6RCxhQUFhLFFBQVFBLGFBQWEsS0FBSyxJQUFJLEtBQUssSUFBSUEsU0FBU3lEO0lBQ3RFO0FBQ0o7QUFLcUUsQ0FDckUsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGFuYW1vbm5leHRfdWkvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvc2xpZGVyL2Rpc3QvaW1wb3J0Lm1qcz84MTg3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7c25hcFZhbHVlVG9TdGVwIGFzICRhVHd1eCRzbmFwVmFsdWVUb1N0ZXAsIHVzZUNvbnRyb2xsZWRTdGF0ZSBhcyAkYVR3dXgkdXNlQ29udHJvbGxlZFN0YXRlLCBjbGFtcCBhcyAkYVR3dXgkY2xhbXB9IGZyb20gXCJAcmVhY3Qtc3RhdGVseS91dGlsc1wiO1xyXG5pbXBvcnQge3VzZU1lbW8gYXMgJGFUd3V4JHVzZU1lbW8sIHVzZUNhbGxiYWNrIGFzICRhVHd1eCR1c2VDYWxsYmFjaywgdXNlU3RhdGUgYXMgJGFUd3V4JHVzZVN0YXRlLCB1c2VSZWYgYXMgJGFUd3V4JHVzZVJlZn0gZnJvbSBcInJlYWN0XCI7XHJcblxyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxyXG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcclxuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXHJcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqLyAvKlxyXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxyXG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcclxuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXHJcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqLyBcclxuXHJcbmNvbnN0ICQyOGY5OWUzZTg2ZTZlYzQ1JHZhciRERUZBVUxUX01JTl9WQUxVRSA9IDA7XHJcbmNvbnN0ICQyOGY5OWUzZTg2ZTZlYzQ1JHZhciRERUZBVUxUX01BWF9WQUxVRSA9IDEwMDtcclxuY29uc3QgJDI4Zjk5ZTNlODZlNmVjNDUkdmFyJERFRkFVTFRfU1RFUF9WQUxVRSA9IDE7XHJcbmZ1bmN0aW9uICQyOGY5OWUzZTg2ZTZlYzQ1JGV4cG9ydCRlNWZkYTMyNDdmNWQ2N2Y5KHByb3BzKSB7XHJcbiAgICBjb25zdCB7IGlzRGlzYWJsZWQ6IGlzRGlzYWJsZWQgPSBmYWxzZSwgbWluVmFsdWU6IG1pblZhbHVlID0gJDI4Zjk5ZTNlODZlNmVjNDUkdmFyJERFRkFVTFRfTUlOX1ZBTFVFLCBtYXhWYWx1ZTogbWF4VmFsdWUgPSAkMjhmOTllM2U4NmU2ZWM0NSR2YXIkREVGQVVMVF9NQVhfVkFMVUUsIG51bWJlckZvcm1hdHRlcjogZm9ybWF0dGVyLCBzdGVwOiBzdGVwID0gJDI4Zjk5ZTNlODZlNmVjNDUkdmFyJERFRkFVTFRfU1RFUF9WQUxVRSwgb3JpZW50YXRpb246IG9yaWVudGF0aW9uID0gXCJob3Jpem9udGFsXCIgfSA9IHByb3BzO1xyXG4gICAgLy8gUGFnZSBzdGVwIHNob3VsZCBiZSBhdCBsZWFzdCBlcXVhbCB0byBzdGVwIGFuZCBhbHdheXMgYSBtdWx0aXBsZSBvZiB0aGUgc3RlcC5cclxuICAgIGxldCBwYWdlU2l6ZSA9ICgwLCAkYVR3dXgkdXNlTWVtbykoKCk9PntcclxuICAgICAgICBsZXQgY2FsY1BhZ2VTaXplID0gKG1heFZhbHVlIC0gbWluVmFsdWUpIC8gMTA7XHJcbiAgICAgICAgY2FsY1BhZ2VTaXplID0gKDAsICRhVHd1eCRzbmFwVmFsdWVUb1N0ZXApKGNhbGNQYWdlU2l6ZSwgMCwgY2FsY1BhZ2VTaXplICsgc3RlcCwgc3RlcCk7XHJcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KGNhbGNQYWdlU2l6ZSwgc3RlcCk7XHJcbiAgICB9LCBbXHJcbiAgICAgICAgc3RlcCxcclxuICAgICAgICBtYXhWYWx1ZSxcclxuICAgICAgICBtaW5WYWx1ZVxyXG4gICAgXSk7XHJcbiAgICBsZXQgcmVzdHJpY3RWYWx1ZXMgPSAoMCwgJGFUd3V4JHVzZUNhbGxiYWNrKSgodmFsdWVzKT0+dmFsdWVzID09PSBudWxsIHx8IHZhbHVlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsdWVzLm1hcCgodmFsLCBpZHgpPT57XHJcbiAgICAgICAgICAgIGxldCBtaW4gPSBpZHggPT09IDAgPyBtaW5WYWx1ZSA6IHZhbFtpZHggLSAxXTtcclxuICAgICAgICAgICAgbGV0IG1heCA9IGlkeCA9PT0gdmFsdWVzLmxlbmd0aCAtIDEgPyBtYXhWYWx1ZSA6IHZhbFtpZHggKyAxXTtcclxuICAgICAgICAgICAgcmV0dXJuICgwLCAkYVR3dXgkc25hcFZhbHVlVG9TdGVwKSh2YWwsIG1pbiwgbWF4LCBzdGVwKTtcclxuICAgICAgICB9KSwgW1xyXG4gICAgICAgIG1pblZhbHVlLFxyXG4gICAgICAgIG1heFZhbHVlLFxyXG4gICAgICAgIHN0ZXBcclxuICAgIF0pO1xyXG4gICAgbGV0IHZhbHVlID0gKDAsICRhVHd1eCR1c2VNZW1vKSgoKT0+cmVzdHJpY3RWYWx1ZXMoJDI4Zjk5ZTNlODZlNmVjNDUkdmFyJGNvbnZlcnRWYWx1ZShwcm9wcy52YWx1ZSkpLCBbXHJcbiAgICAgICAgcHJvcHMudmFsdWVcclxuICAgIF0pO1xyXG4gICAgbGV0IGRlZmF1bHRWYWx1ZSA9ICgwLCAkYVR3dXgkdXNlTWVtbykoKCk9PntcclxuICAgICAgICB2YXIgX2NvbnZlcnRWYWx1ZTtcclxuICAgICAgICByZXR1cm4gcmVzdHJpY3RWYWx1ZXMoKF9jb252ZXJ0VmFsdWUgPSAkMjhmOTllM2U4NmU2ZWM0NSR2YXIkY29udmVydFZhbHVlKHByb3BzLmRlZmF1bHRWYWx1ZSkpICE9PSBudWxsICYmIF9jb252ZXJ0VmFsdWUgIT09IHZvaWQgMCA/IF9jb252ZXJ0VmFsdWUgOiBbXHJcbiAgICAgICAgICAgIG1pblZhbHVlXHJcbiAgICAgICAgXSk7XHJcbiAgICB9LCBbXHJcbiAgICAgICAgcHJvcHMuZGVmYXVsdFZhbHVlLFxyXG4gICAgICAgIG1pblZhbHVlXHJcbiAgICBdKTtcclxuICAgIGxldCBvbkNoYW5nZSA9ICQyOGY5OWUzZTg2ZTZlYzQ1JHZhciRjcmVhdGVPbkNoYW5nZShwcm9wcy52YWx1ZSwgcHJvcHMuZGVmYXVsdFZhbHVlLCBwcm9wcy5vbkNoYW5nZSk7XHJcbiAgICBsZXQgb25DaGFuZ2VFbmQgPSAkMjhmOTllM2U4NmU2ZWM0NSR2YXIkY3JlYXRlT25DaGFuZ2UocHJvcHMudmFsdWUsIHByb3BzLmRlZmF1bHRWYWx1ZSwgcHJvcHMub25DaGFuZ2VFbmQpO1xyXG4gICAgY29uc3QgW3ZhbHVlcywgc2V0VmFsdWVzU3RhdGVdID0gKDAsICRhVHd1eCR1c2VDb250cm9sbGVkU3RhdGUpKHZhbHVlLCBkZWZhdWx0VmFsdWUsIG9uQ2hhbmdlKTtcclxuICAgIGNvbnN0IFtpc0RyYWdnaW5ncywgc2V0RHJhZ2dpbmdzU3RhdGVdID0gKDAsICRhVHd1eCR1c2VTdGF0ZSkobmV3IEFycmF5KHZhbHVlcy5sZW5ndGgpLmZpbGwoZmFsc2UpKTtcclxuICAgIGNvbnN0IGlzRWRpdGFibGVzUmVmID0gKDAsICRhVHd1eCR1c2VSZWYpKG5ldyBBcnJheSh2YWx1ZXMubGVuZ3RoKS5maWxsKHRydWUpKTtcclxuICAgIGNvbnN0IFtmb2N1c2VkSW5kZXgsIHNldEZvY3VzZWRJbmRleF0gPSAoMCwgJGFUd3V4JHVzZVN0YXRlKSh1bmRlZmluZWQpO1xyXG4gICAgY29uc3QgdmFsdWVzUmVmID0gKDAsICRhVHd1eCR1c2VSZWYpKHZhbHVlcyk7XHJcbiAgICBjb25zdCBpc0RyYWdnaW5nc1JlZiA9ICgwLCAkYVR3dXgkdXNlUmVmKShpc0RyYWdnaW5ncyk7XHJcbiAgICBsZXQgc2V0VmFsdWVzID0gKHZhbHVlcyk9PntcclxuICAgICAgICB2YWx1ZXNSZWYuY3VycmVudCA9IHZhbHVlcztcclxuICAgICAgICBzZXRWYWx1ZXNTdGF0ZSh2YWx1ZXMpO1xyXG4gICAgfTtcclxuICAgIGxldCBzZXREcmFnZ2luZ3MgPSAoZHJhZ2dpbmdzKT0+e1xyXG4gICAgICAgIGlzRHJhZ2dpbmdzUmVmLmN1cnJlbnQgPSBkcmFnZ2luZ3M7XHJcbiAgICAgICAgc2V0RHJhZ2dpbmdzU3RhdGUoZHJhZ2dpbmdzKTtcclxuICAgIH07XHJcbiAgICBmdW5jdGlvbiBnZXRWYWx1ZVBlcmNlbnQodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gKHZhbHVlIC0gbWluVmFsdWUpIC8gKG1heFZhbHVlIC0gbWluVmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZ2V0VGh1bWJNaW5WYWx1ZShpbmRleCkge1xyXG4gICAgICAgIHJldHVybiBpbmRleCA9PT0gMCA/IG1pblZhbHVlIDogdmFsdWVzW2luZGV4IC0gMV07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBnZXRUaHVtYk1heFZhbHVlKGluZGV4KSB7XHJcbiAgICAgICAgcmV0dXJuIGluZGV4ID09PSB2YWx1ZXMubGVuZ3RoIC0gMSA/IG1heFZhbHVlIDogdmFsdWVzW2luZGV4ICsgMV07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBpc1RodW1iRWRpdGFibGUoaW5kZXgpIHtcclxuICAgICAgICByZXR1cm4gaXNFZGl0YWJsZXNSZWYuY3VycmVudFtpbmRleF07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBzZXRUaHVtYkVkaXRhYmxlKGluZGV4LCBlZGl0YWJsZSkge1xyXG4gICAgICAgIGlzRWRpdGFibGVzUmVmLmN1cnJlbnRbaW5kZXhdID0gZWRpdGFibGU7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiB1cGRhdGVWYWx1ZShpbmRleCwgdmFsdWUpIHtcclxuICAgICAgICBpZiAoaXNEaXNhYmxlZCB8fCAhaXNUaHVtYkVkaXRhYmxlKGluZGV4KSkgcmV0dXJuO1xyXG4gICAgICAgIGNvbnN0IHRoaXNNaW4gPSBnZXRUaHVtYk1pblZhbHVlKGluZGV4KTtcclxuICAgICAgICBjb25zdCB0aGlzTWF4ID0gZ2V0VGh1bWJNYXhWYWx1ZShpbmRleCk7XHJcbiAgICAgICAgLy8gUm91bmQgdmFsdWUgdG8gbXVsdGlwbGUgb2Ygc3RlcCwgY2xhbXAgdmFsdWUgYmV0d2VlbiBtaW4gYW5kIG1heFxyXG4gICAgICAgIHZhbHVlID0gKDAsICRhVHd1eCRzbmFwVmFsdWVUb1N0ZXApKHZhbHVlLCB0aGlzTWluLCB0aGlzTWF4LCBzdGVwKTtcclxuICAgICAgICBsZXQgbmV3VmFsdWVzID0gJDI4Zjk5ZTNlODZlNmVjNDUkdmFyJHJlcGxhY2VJbmRleCh2YWx1ZXNSZWYuY3VycmVudCwgaW5kZXgsIHZhbHVlKTtcclxuICAgICAgICBzZXRWYWx1ZXMobmV3VmFsdWVzKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHVwZGF0ZURyYWdnaW5nKGluZGV4LCBkcmFnZ2luZykge1xyXG4gICAgICAgIGlmIChpc0Rpc2FibGVkIHx8ICFpc1RodW1iRWRpdGFibGUoaW5kZXgpKSByZXR1cm47XHJcbiAgICAgICAgY29uc3Qgd2FzRHJhZ2dpbmcgPSBpc0RyYWdnaW5nc1JlZi5jdXJyZW50W2luZGV4XTtcclxuICAgICAgICBpc0RyYWdnaW5nc1JlZi5jdXJyZW50ID0gJDI4Zjk5ZTNlODZlNmVjNDUkdmFyJHJlcGxhY2VJbmRleChpc0RyYWdnaW5nc1JlZi5jdXJyZW50LCBpbmRleCwgZHJhZ2dpbmcpO1xyXG4gICAgICAgIHNldERyYWdnaW5ncyhpc0RyYWdnaW5nc1JlZi5jdXJyZW50KTtcclxuICAgICAgICAvLyBDYWxsIG9uQ2hhbmdlRW5kIGlmIG5vIGhhbmRsZXMgYXJlIGRyYWdnaW5nLlxyXG4gICAgICAgIGlmIChvbkNoYW5nZUVuZCAmJiB3YXNEcmFnZ2luZyAmJiAhaXNEcmFnZ2luZ3NSZWYuY3VycmVudC5zb21lKEJvb2xlYW4pKSBvbkNoYW5nZUVuZCh2YWx1ZXNSZWYuY3VycmVudCk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBnZXRGb3JtYXR0ZWRWYWx1ZSh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBmb3JtYXR0ZXIuZm9ybWF0KHZhbHVlKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHNldFRodW1iUGVyY2VudChpbmRleCwgcGVyY2VudCkge1xyXG4gICAgICAgIHVwZGF0ZVZhbHVlKGluZGV4LCBnZXRQZXJjZW50VmFsdWUocGVyY2VudCkpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZ2V0Um91bmRlZFZhbHVlKHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoKHZhbHVlIC0gbWluVmFsdWUpIC8gc3RlcCkgKiBzdGVwICsgbWluVmFsdWU7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBnZXRQZXJjZW50VmFsdWUocGVyY2VudCkge1xyXG4gICAgICAgIGNvbnN0IHZhbCA9IHBlcmNlbnQgKiAobWF4VmFsdWUgLSBtaW5WYWx1ZSkgKyBtaW5WYWx1ZTtcclxuICAgICAgICByZXR1cm4gKDAsICRhVHd1eCRjbGFtcCkoZ2V0Um91bmRlZFZhbHVlKHZhbCksIG1pblZhbHVlLCBtYXhWYWx1ZSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBpbmNyZW1lbnRUaHVtYihpbmRleCwgc3RlcFNpemUgPSAxKSB7XHJcbiAgICAgICAgbGV0IHMgPSBNYXRoLm1heChzdGVwU2l6ZSwgc3RlcCk7XHJcbiAgICAgICAgdXBkYXRlVmFsdWUoaW5kZXgsICgwLCAkYVR3dXgkc25hcFZhbHVlVG9TdGVwKSh2YWx1ZXNbaW5kZXhdICsgcywgbWluVmFsdWUsIG1heFZhbHVlLCBzdGVwKSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBkZWNyZW1lbnRUaHVtYihpbmRleCwgc3RlcFNpemUgPSAxKSB7XHJcbiAgICAgICAgbGV0IHMgPSBNYXRoLm1heChzdGVwU2l6ZSwgc3RlcCk7XHJcbiAgICAgICAgdXBkYXRlVmFsdWUoaW5kZXgsICgwLCAkYVR3dXgkc25hcFZhbHVlVG9TdGVwKSh2YWx1ZXNbaW5kZXhdIC0gcywgbWluVmFsdWUsIG1heFZhbHVlLCBzdGVwKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHZhbHVlczogdmFsdWVzLFxyXG4gICAgICAgIGdldFRodW1iVmFsdWU6IChpbmRleCk9PnZhbHVlc1tpbmRleF0sXHJcbiAgICAgICAgc2V0VGh1bWJWYWx1ZTogdXBkYXRlVmFsdWUsXHJcbiAgICAgICAgc2V0VGh1bWJQZXJjZW50OiBzZXRUaHVtYlBlcmNlbnQsXHJcbiAgICAgICAgaXNUaHVtYkRyYWdnaW5nOiAoaW5kZXgpPT5pc0RyYWdnaW5nc1tpbmRleF0sXHJcbiAgICAgICAgc2V0VGh1bWJEcmFnZ2luZzogdXBkYXRlRHJhZ2dpbmcsXHJcbiAgICAgICAgZm9jdXNlZFRodW1iOiBmb2N1c2VkSW5kZXgsXHJcbiAgICAgICAgc2V0Rm9jdXNlZFRodW1iOiBzZXRGb2N1c2VkSW5kZXgsXHJcbiAgICAgICAgZ2V0VGh1bWJQZXJjZW50OiAoaW5kZXgpPT5nZXRWYWx1ZVBlcmNlbnQodmFsdWVzW2luZGV4XSksXHJcbiAgICAgICAgZ2V0VmFsdWVQZXJjZW50OiBnZXRWYWx1ZVBlcmNlbnQsXHJcbiAgICAgICAgZ2V0VGh1bWJWYWx1ZUxhYmVsOiAoaW5kZXgpPT5nZXRGb3JtYXR0ZWRWYWx1ZSh2YWx1ZXNbaW5kZXhdKSxcclxuICAgICAgICBnZXRGb3JtYXR0ZWRWYWx1ZTogZ2V0Rm9ybWF0dGVkVmFsdWUsXHJcbiAgICAgICAgZ2V0VGh1bWJNaW5WYWx1ZTogZ2V0VGh1bWJNaW5WYWx1ZSxcclxuICAgICAgICBnZXRUaHVtYk1heFZhbHVlOiBnZXRUaHVtYk1heFZhbHVlLFxyXG4gICAgICAgIGdldFBlcmNlbnRWYWx1ZTogZ2V0UGVyY2VudFZhbHVlLFxyXG4gICAgICAgIGlzVGh1bWJFZGl0YWJsZTogaXNUaHVtYkVkaXRhYmxlLFxyXG4gICAgICAgIHNldFRodW1iRWRpdGFibGU6IHNldFRodW1iRWRpdGFibGUsXHJcbiAgICAgICAgaW5jcmVtZW50VGh1bWI6IGluY3JlbWVudFRodW1iLFxyXG4gICAgICAgIGRlY3JlbWVudFRodW1iOiBkZWNyZW1lbnRUaHVtYixcclxuICAgICAgICBzdGVwOiBzdGVwLFxyXG4gICAgICAgIHBhZ2VTaXplOiBwYWdlU2l6ZSxcclxuICAgICAgICBvcmllbnRhdGlvbjogb3JpZW50YXRpb24sXHJcbiAgICAgICAgaXNEaXNhYmxlZDogaXNEaXNhYmxlZFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiAkMjhmOTllM2U4NmU2ZWM0NSR2YXIkcmVwbGFjZUluZGV4KGFycmF5LCBpbmRleCwgdmFsdWUpIHtcclxuICAgIGlmIChhcnJheVtpbmRleF0gPT09IHZhbHVlKSByZXR1cm4gYXJyYXk7XHJcbiAgICByZXR1cm4gW1xyXG4gICAgICAgIC4uLmFycmF5LnNsaWNlKDAsIGluZGV4KSxcclxuICAgICAgICB2YWx1ZSxcclxuICAgICAgICAuLi5hcnJheS5zbGljZShpbmRleCArIDEpXHJcbiAgICBdO1xyXG59XHJcbmZ1bmN0aW9uICQyOGY5OWUzZTg2ZTZlYzQ1JHZhciRjb252ZXJ0VmFsdWUodmFsdWUpIHtcclxuICAgIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbXHJcbiAgICAgICAgdmFsdWVcclxuICAgIF07XHJcbn1cclxuZnVuY3Rpb24gJDI4Zjk5ZTNlODZlNmVjNDUkdmFyJGNyZWF0ZU9uQ2hhbmdlKHZhbHVlLCBkZWZhdWx0VmFsdWUsIG9uQ2hhbmdlKSB7XHJcbiAgICByZXR1cm4gKG5ld1ZhbHVlKT0+e1xyXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIGRlZmF1bHRWYWx1ZSA9PT0gXCJudW1iZXJcIikgb25DaGFuZ2UgPT09IG51bGwgfHwgb25DaGFuZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uQ2hhbmdlKG5ld1ZhbHVlWzBdKTtcclxuICAgICAgICBlbHNlIG9uQ2hhbmdlID09PSBudWxsIHx8IG9uQ2hhbmdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbkNoYW5nZShuZXdWYWx1ZSk7XHJcbiAgICB9O1xyXG59XHJcblxyXG5cclxuXHJcblxyXG5leHBvcnQgeyQyOGY5OWUzZTg2ZTZlYzQ1JGV4cG9ydCRlNWZkYTMyNDdmNWQ2N2Y5IGFzIHVzZVNsaWRlclN0YXRlfTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxlLmpzLm1hcFxyXG4iXSwibmFtZXMiOlsic25hcFZhbHVlVG9TdGVwIiwiJGFUd3V4JHNuYXBWYWx1ZVRvU3RlcCIsInVzZUNvbnRyb2xsZWRTdGF0ZSIsIiRhVHd1eCR1c2VDb250cm9sbGVkU3RhdGUiLCJjbGFtcCIsIiRhVHd1eCRjbGFtcCIsInVzZU1lbW8iLCIkYVR3dXgkdXNlTWVtbyIsInVzZUNhbGxiYWNrIiwiJGFUd3V4JHVzZUNhbGxiYWNrIiwidXNlU3RhdGUiLCIkYVR3dXgkdXNlU3RhdGUiLCJ1c2VSZWYiLCIkYVR3dXgkdXNlUmVmIiwiJDI4Zjk5ZTNlODZlNmVjNDUkdmFyJERFRkFVTFRfTUlOX1ZBTFVFIiwiJDI4Zjk5ZTNlODZlNmVjNDUkdmFyJERFRkFVTFRfTUFYX1ZBTFVFIiwiJDI4Zjk5ZTNlODZlNmVjNDUkdmFyJERFRkFVTFRfU1RFUF9WQUxVRSIsIiQyOGY5OWUzZTg2ZTZlYzQ1JGV4cG9ydCRlNWZkYTMyNDdmNWQ2N2Y5IiwicHJvcHMiLCJpc0Rpc2FibGVkIiwibWluVmFsdWUiLCJtYXhWYWx1ZSIsIm51bWJlckZvcm1hdHRlciIsImZvcm1hdHRlciIsInN0ZXAiLCJvcmllbnRhdGlvbiIsInBhZ2VTaXplIiwiY2FsY1BhZ2VTaXplIiwiTWF0aCIsIm1heCIsInJlc3RyaWN0VmFsdWVzIiwidmFsdWVzIiwibWFwIiwidmFsIiwiaWR4IiwibWluIiwibGVuZ3RoIiwidmFsdWUiLCIkMjhmOTllM2U4NmU2ZWM0NSR2YXIkY29udmVydFZhbHVlIiwiZGVmYXVsdFZhbHVlIiwiX2NvbnZlcnRWYWx1ZSIsIm9uQ2hhbmdlIiwiJDI4Zjk5ZTNlODZlNmVjNDUkdmFyJGNyZWF0ZU9uQ2hhbmdlIiwib25DaGFuZ2VFbmQiLCJzZXRWYWx1ZXNTdGF0ZSIsImlzRHJhZ2dpbmdzIiwic2V0RHJhZ2dpbmdzU3RhdGUiLCJBcnJheSIsImZpbGwiLCJpc0VkaXRhYmxlc1JlZiIsImZvY3VzZWRJbmRleCIsInNldEZvY3VzZWRJbmRleCIsInVuZGVmaW5lZCIsInZhbHVlc1JlZiIsImlzRHJhZ2dpbmdzUmVmIiwic2V0VmFsdWVzIiwiY3VycmVudCIsInNldERyYWdnaW5ncyIsImRyYWdnaW5ncyIsImdldFZhbHVlUGVyY2VudCIsImdldFRodW1iTWluVmFsdWUiLCJpbmRleCIsImdldFRodW1iTWF4VmFsdWUiLCJpc1RodW1iRWRpdGFibGUiLCJzZXRUaHVtYkVkaXRhYmxlIiwiZWRpdGFibGUiLCJ1cGRhdGVWYWx1ZSIsInRoaXNNaW4iLCJ0aGlzTWF4IiwibmV3VmFsdWVzIiwiJDI4Zjk5ZTNlODZlNmVjNDUkdmFyJHJlcGxhY2VJbmRleCIsInVwZGF0ZURyYWdnaW5nIiwiZHJhZ2dpbmciLCJ3YXNEcmFnZ2luZyIsInNvbWUiLCJCb29sZWFuIiwiZ2V0Rm9ybWF0dGVkVmFsdWUiLCJmb3JtYXQiLCJzZXRUaHVtYlBlcmNlbnQiLCJwZXJjZW50IiwiZ2V0UGVyY2VudFZhbHVlIiwiZ2V0Um91bmRlZFZhbHVlIiwicm91bmQiLCJpbmNyZW1lbnRUaHVtYiIsInN0ZXBTaXplIiwicyIsImRlY3JlbWVudFRodW1iIiwiZ2V0VGh1bWJWYWx1ZSIsInNldFRodW1iVmFsdWUiLCJpc1RodW1iRHJhZ2dpbmciLCJzZXRUaHVtYkRyYWdnaW5nIiwiZm9jdXNlZFRodW1iIiwic2V0Rm9jdXNlZFRodW1iIiwiZ2V0VGh1bWJQZXJjZW50IiwiZ2V0VGh1bWJWYWx1ZUxhYmVsIiwiYXJyYXkiLCJzbGljZSIsImlzQXJyYXkiLCJuZXdWYWx1ZSIsInVzZVNsaWRlclN0YXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/slider/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/table/dist/import.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@react-stately/table/dist/import.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Cell: () => (/* binding */ $941d1d9a6a28982a$export$f6f0c3fe4ec306ea),\n/* harmony export */   Column: () => (/* binding */ $1cd244557c2f97d5$export$816b5d811295e6bc),\n/* harmony export */   Row: () => (/* binding */ $70d70eb16ea48428$export$b59bdbef9ce70de2),\n/* harmony export */   Section: () => (/* reexport safe */ _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.Section),\n/* harmony export */   TableBody: () => (/* binding */ $4ae5314bf50db1a3$export$76ccd210b9029917),\n/* harmony export */   TableCollection: () => (/* binding */ $788781baa30117fa$export$596e1b2e2cf93690),\n/* harmony export */   TableColumnLayout: () => (/* binding */ $a9e7ae544a4e41dd$export$7ff77a162970b30e),\n/* harmony export */   TableHeader: () => (/* binding */ $312ae3b56a94a86e$export$f850895b287ef28e),\n/* harmony export */   UNSTABLE_useTreeGridState: () => (/* binding */ $ee65a0057fd99531$export$34dfa8a1622185a4),\n/* harmony export */   buildHeaderRows: () => (/* binding */ $788781baa30117fa$export$7c127db850d4e81e),\n/* harmony export */   useTableColumnResizeState: () => (/* binding */ $292bc4e09cd0eb62$export$cb895dcf85db1319),\n/* harmony export */   useTableState: () => (/* binding */ $4a0dd036d492cee4$export$907bcc6c48325fd6)\n/* harmony export */ });\n/* harmony import */ var _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-stately/collections */ \"(ssr)/./node_modules/@react-stately/collections/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_stately_grid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/grid */ \"(ssr)/./node_modules/@react-stately/grid/dist/import.mjs\");\n/* harmony import */ var _react_stately_flags__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @react-stately/flags */ \"(ssr)/./node_modules/@react-stately/flags/dist/import.mjs\");\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\");\n\n\n\n\n\n/*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ /*\r\n * Copyright 2022 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ /*\r\n * Copyright 2022 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ /*\r\n * Copyright 2022 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ function $6818b1c4fc67028d$export$1994a077b98ee0d5(width) {\n    return width != null && (!isNaN(width) || String(width).match(/^(\\d+)(?=%$)/) !== null);\n}\nfunction $6818b1c4fc67028d$export$9078bad4c3934604(width) {\n    if (!width) return 1;\n    let match = width.match(/^(.+)(?=fr$)/);\n    // if width is the incorrect format, just default it to a 1fr\n    if (!match) {\n        console.warn(`width: ${width} is not a supported format, width should be a number (ex. 150), percentage (ex. '50%') or fr unit (ex. '2fr')`, \"defaulting to '1fr'\");\n        return 1;\n    }\n    return parseFloat(match[0]);\n}\nfunction $6818b1c4fc67028d$export$7bbad27896f7ae9f(width, tableWidth) {\n    if (typeof width === \"string\") {\n        let match = width.match(/^(\\d+)(?=%$)/);\n        if (!match) throw new Error(\"Only percentages or numbers are supported for static column widths\");\n        return tableWidth * (parseFloat(match[0]) / 100);\n    }\n    return width;\n}\nfunction $6818b1c4fc67028d$export$59185c62a7544aa0(maxWidth, tableWidth) {\n    return maxWidth != null ? $6818b1c4fc67028d$export$7bbad27896f7ae9f(maxWidth, tableWidth) : Number.MAX_SAFE_INTEGER;\n}\nfunction $6818b1c4fc67028d$export$f556054ce4358701(minWidth, tableWidth) {\n    return minWidth != null ? $6818b1c4fc67028d$export$7bbad27896f7ae9f(minWidth, tableWidth) : 0;\n}\nfunction $6818b1c4fc67028d$export$55d50dc687385491(availableWidth, columns, changedColumns, getDefaultWidth, getDefaultMinWidth) {\n    let hasNonFrozenItems = false;\n    let flexItems = columns.map((column, index)=>{\n        var _column_width, _ref, _ref1;\n        let width = changedColumns.get(column.key) != null ? changedColumns.get(column.key) : (_ref1 = (_ref = (_column_width = column.width) !== null && _column_width !== void 0 ? _column_width : column.defaultWidth) !== null && _ref !== void 0 ? _ref : getDefaultWidth === null || getDefaultWidth === void 0 ? void 0 : getDefaultWidth(index)) !== null && _ref1 !== void 0 ? _ref1 : \"1fr\";\n        let frozen = false;\n        let baseSize = 0;\n        let flex = 0;\n        let targetMainSize = null;\n        if ($6818b1c4fc67028d$export$1994a077b98ee0d5(width)) {\n            baseSize = $6818b1c4fc67028d$export$7bbad27896f7ae9f(width, availableWidth);\n            frozen = true;\n        } else {\n            flex = $6818b1c4fc67028d$export$9078bad4c3934604(width);\n            if (flex <= 0) frozen = true;\n        }\n        var _column_minWidth, _ref2;\n        let min = $6818b1c4fc67028d$export$f556054ce4358701((_ref2 = (_column_minWidth = column.minWidth) !== null && _column_minWidth !== void 0 ? _column_minWidth : getDefaultMinWidth === null || getDefaultMinWidth === void 0 ? void 0 : getDefaultMinWidth(index)) !== null && _ref2 !== void 0 ? _ref2 : 0, availableWidth);\n        let max = $6818b1c4fc67028d$export$59185c62a7544aa0(column.maxWidth, availableWidth);\n        let hypotheticalMainSize = Math.max(min, Math.min(baseSize, max));\n        // 9.7.1\n        // We don't make use of flex basis, it's always 0, so we are always in 'grow' mode.\n        // 9.7.2\n        if (frozen) targetMainSize = hypotheticalMainSize;\n        else if (baseSize > hypotheticalMainSize) {\n            frozen = true;\n            targetMainSize = hypotheticalMainSize;\n        }\n        // 9.7.3\n        if (!frozen) hasNonFrozenItems = true;\n        return {\n            frozen: frozen,\n            baseSize: baseSize,\n            hypotheticalMainSize: hypotheticalMainSize,\n            min: min,\n            max: max,\n            flex: flex,\n            targetMainSize: targetMainSize,\n            violation: 0\n        };\n    });\n    // 9.7.4\n    // 9.7.4.a\n    while(hasNonFrozenItems){\n        // 9.7.4.b\n        /**\r\n     * Calculate the remaining free space as for initial free space,\r\n     * above (9.7.3). If the sum of the unfrozen flex itemsâ€™ flex factors is\r\n     * less than one, multiply the initial free space by this sum (of flex factors).\r\n     * If the magnitude of this value is less than the magnitude of\r\n     * the remaining free space, use this as the remaining free space.\r\n     */ let usedWidth = 0;\n        let flexFactors = 0;\n        flexItems.forEach((item)=>{\n            if (item.frozen) usedWidth += item.targetMainSize;\n            else {\n                usedWidth += item.baseSize;\n                flexFactors += item.flex;\n            }\n        });\n        let remainingFreeSpace = availableWidth - usedWidth;\n        // we only support integer FR's, and because of hasNonFrozenItems, we know that flexFactors > 0\n        // so no need to check for flexFactors < 1\n        // 9.7.4.c\n        /**\r\n     * If the remaining free space is zero\r\n     * - Do nothing.\r\n     * Else // remember, we're always in grow mode\r\n     * - Find the ratio of the itemâ€™s flex grow factor to the\r\n     * sum of the flex grow factors of all unfrozen items on\r\n     * the line. Set the itemâ€™s target main size to its flex\r\n     * base size plus a fraction of the remaining free space\r\n     * proportional to the ratio.\r\n     */ if (remainingFreeSpace > 0) flexItems.forEach((item)=>{\n            if (!item.frozen) {\n                let ratio = item.flex / flexFactors;\n                item.targetMainSize = item.baseSize + ratio * remainingFreeSpace;\n            }\n        });\n        // 9.7.4.d\n        /**\r\n     * Fix min/max violations. Clamp each non-frozen itemâ€™s\r\n     * target main size by its used min and max main sizes\r\n     * and floor its content-box size at zero. If the itemâ€™s\r\n     * target main size was made smaller by this, itâ€™s a max\r\n     * violation. If the itemâ€™s target main size was made\r\n     * larger by this, itâ€™s a min violation.\r\n     */ let totalViolation = 0;\n        flexItems.forEach((item)=>{\n            item.violation = 0;\n            if (!item.frozen) {\n                let { min: min, max: max, targetMainSize: targetMainSize } = item;\n                item.targetMainSize = Math.max(min, Math.min(targetMainSize, max));\n                item.violation = item.targetMainSize - targetMainSize;\n                totalViolation += item.violation;\n            }\n        });\n        // 9.7.4.e\n        /**\r\n     * Freeze over-flexed items. The total violation is the\r\n     * sum of the adjustments from the previous step\r\n     * âˆ‘(clamped size - unclamped size). If the total violation is:\r\n     * Zero\r\n     * - Freeze all items.\r\n     *\r\n     * Positive\r\n     * - Freeze all the items with min violations.\r\n     *\r\n     * Negative\r\n     * - Freeze all the items with max violations.\r\n     */ hasNonFrozenItems = false;\n        flexItems.forEach((item)=>{\n            if (totalViolation === 0 || Math.sign(totalViolation) === Math.sign(item.violation)) item.frozen = true;\n            else if (!item.frozen) hasNonFrozenItems = true;\n        });\n    }\n    return $6818b1c4fc67028d$var$cascadeRounding(flexItems);\n}\nfunction $6818b1c4fc67028d$var$cascadeRounding(flexItems) {\n    /*\r\n  Given an array of floats that sum to an integer, this rounds the floats\r\n  and returns an array of integers with the same sum.\r\n  */ let fpTotal = 0;\n    let intTotal = 0;\n    let roundedArray = [];\n    flexItems.forEach(function(item) {\n        let float = item.targetMainSize;\n        let integer = Math.round(float + fpTotal) - intTotal;\n        fpTotal += float;\n        intTotal += integer;\n        roundedArray.push(integer);\n    });\n    return roundedArray;\n}\nclass $a9e7ae544a4e41dd$export$7ff77a162970b30e {\n    /** Takes an array of columns and splits it into 2 maps of columns with controlled and columns with uncontrolled widths. */ splitColumnsIntoControlledAndUncontrolled(columns) {\n        return columns.reduce((acc, col)=>{\n            if (col.props.width != null) acc[0].set(col.key, col);\n            else acc[1].set(col.key, col);\n            return acc;\n        }, [\n            new Map(),\n            new Map()\n        ]);\n    }\n    /** Takes uncontrolled and controlled widths and joins them into a single Map. */ recombineColumns(columns, uncontrolledWidths, uncontrolledColumns, controlledColumns) {\n        return new Map(columns.map((col)=>{\n            if (uncontrolledColumns.has(col.key)) return [\n                col.key,\n                uncontrolledWidths.get(col.key)\n            ];\n            else return [\n                col.key,\n                controlledColumns.get(col.key).props.width\n            ];\n        }));\n    }\n    /** Used to make an initial Map of the uncontrolled widths based on default widths. */ getInitialUncontrolledWidths(uncontrolledColumns) {\n        return new Map(Array.from(uncontrolledColumns).map(([key, col])=>{\n            var _this_getDefaultWidth, _this;\n            var _col_props_defaultWidth, _ref;\n            return [\n                key,\n                (_ref = (_col_props_defaultWidth = col.props.defaultWidth) !== null && _col_props_defaultWidth !== void 0 ? _col_props_defaultWidth : (_this_getDefaultWidth = (_this = this).getDefaultWidth) === null || _this_getDefaultWidth === void 0 ? void 0 : _this_getDefaultWidth.call(_this, col)) !== null && _ref !== void 0 ? _ref : \"1fr\"\n            ];\n        }));\n    }\n    getColumnWidth(key) {\n        var _this_columnWidths_get;\n        return (_this_columnWidths_get = this.columnWidths.get(key)) !== null && _this_columnWidths_get !== void 0 ? _this_columnWidths_get : 0;\n    }\n    getColumnMinWidth(key) {\n        var _this_columnMinWidths_get;\n        return (_this_columnMinWidths_get = this.columnMinWidths.get(key)) !== null && _this_columnMinWidths_get !== void 0 ? _this_columnMinWidths_get : 0;\n    }\n    getColumnMaxWidth(key) {\n        var _this_columnMaxWidths_get;\n        return (_this_columnMaxWidths_get = this.columnMaxWidths.get(key)) !== null && _this_columnMaxWidths_get !== void 0 ? _this_columnMaxWidths_get : 0;\n    }\n    resizeColumnWidth(tableWidth, collection, controlledWidths, uncontrolledWidths, col = null, width) {\n        let prevColumnWidths = this.columnWidths;\n        // resizing a column\n        let resizeIndex = Infinity;\n        let resizingChanged = new Map([\n            ...controlledWidths,\n            ...uncontrolledWidths\n        ]);\n        let percentKeys = new Map();\n        let frKeysToTheRight = new Map();\n        let minWidths = new Map();\n        // freeze columns to the left to their previous pixel value\n        collection.columns.forEach((column, i)=>{\n            var _column_props_width_endsWith, _column_props_width;\n            let frKey;\n            let frValue;\n            minWidths.set(column.key, this.getDefaultMinWidth(collection.columns[i]));\n            if (col !== column.key && !column.props.width && !(0, $6818b1c4fc67028d$export$1994a077b98ee0d5)(uncontrolledWidths.get(column.key))) {\n                // uncontrolled don't have props.width for us, so instead get from our state\n                frKey = column.key;\n                frValue = (0, $6818b1c4fc67028d$export$9078bad4c3934604)(uncontrolledWidths.get(column.key));\n            } else if (col !== column.key && !(0, $6818b1c4fc67028d$export$1994a077b98ee0d5)(column.props.width) && !uncontrolledWidths.get(column.key)) {\n                // controlledWidths will be the same in the collection\n                frKey = column.key;\n                frValue = (0, $6818b1c4fc67028d$export$9078bad4c3934604)(column.props.width);\n            } else if (col !== column.key && ((_column_props_width = column.props.width) === null || _column_props_width === void 0 ? void 0 : (_column_props_width_endsWith = _column_props_width.endsWith) === null || _column_props_width_endsWith === void 0 ? void 0 : _column_props_width_endsWith.call(_column_props_width, \"%\"))) percentKeys.set(column.key, column.props.width);\n            // don't freeze columns to the right of the resizing one\n            if (resizeIndex < i) {\n                if (frKey) frKeysToTheRight.set(frKey, frValue);\n                return;\n            }\n            // we already know the new size of the resizing column\n            if (column.key === col) {\n                resizeIndex = i;\n                resizingChanged.set(column.key, Math.floor(width));\n                return;\n            }\n            // freeze column to previous value\n            resizingChanged.set(column.key, prevColumnWidths.get(column.key));\n        });\n        // predict pixels sizes for all columns based on resize\n        let columnWidths = (0, $6818b1c4fc67028d$export$55d50dc687385491)(tableWidth, collection.columns.map((col)=>({\n                ...col.props,\n                key: col.key\n            })), resizingChanged, (i)=>this.getDefaultWidth(collection.columns[i]), (i)=>this.getDefaultMinWidth(collection.columns[i]));\n        // set all new column widths for onResize event\n        // columns going in will be the same order as the columns coming out\n        let newWidths = new Map();\n        // set all column widths based on calculateColumnSize\n        columnWidths.forEach((width, index)=>{\n            let key = collection.columns[index].key;\n            newWidths.set(key, width);\n        });\n        // add FR's back as they were to columns to the right\n        Array.from(frKeysToTheRight).forEach(([key])=>{\n            newWidths.set(key, `${frKeysToTheRight.get(key)}fr`);\n        });\n        // put back in percents\n        Array.from(percentKeys).forEach(([key, width])=>{\n            // resizing locks a column to a px width\n            if (key === col) return;\n            newWidths.set(key, width);\n        });\n        return newWidths;\n    }\n    buildColumnWidths(tableWidth, collection, widths) {\n        this.columnWidths = new Map();\n        this.columnMinWidths = new Map();\n        this.columnMaxWidths = new Map();\n        // initial layout or table/window resizing\n        let columnWidths = (0, $6818b1c4fc67028d$export$55d50dc687385491)(tableWidth, collection.columns.map((col)=>({\n                ...col.props,\n                key: col.key\n            })), widths, (i)=>this.getDefaultWidth(collection.columns[i]), (i)=>this.getDefaultMinWidth(collection.columns[i]));\n        // columns going in will be the same order as the columns coming out\n        columnWidths.forEach((width, index)=>{\n            let key = collection.columns[index].key;\n            let column = collection.columns[index];\n            this.columnWidths.set(key, width);\n            var _column_props_minWidth;\n            this.columnMinWidths.set(key, (0, $6818b1c4fc67028d$export$f556054ce4358701)((_column_props_minWidth = column.props.minWidth) !== null && _column_props_minWidth !== void 0 ? _column_props_minWidth : this.getDefaultMinWidth(column), tableWidth));\n            this.columnMaxWidths.set(key, (0, $6818b1c4fc67028d$export$59185c62a7544aa0)(column.props.maxWidth, tableWidth));\n        });\n        return this.columnWidths;\n    }\n    constructor(options){\n        this.columnWidths = new Map();\n        this.columnMinWidths = new Map();\n        this.columnMaxWidths = new Map();\n        var _options_getDefaultWidth;\n        this.getDefaultWidth = (_options_getDefaultWidth = options === null || options === void 0 ? void 0 : options.getDefaultWidth) !== null && _options_getDefaultWidth !== void 0 ? _options_getDefaultWidth : ()=>\"1fr\";\n        var _options_getDefaultMinWidth;\n        this.getDefaultMinWidth = (_options_getDefaultMinWidth = options === null || options === void 0 ? void 0 : options.getDefaultMinWidth) !== null && _options_getDefaultMinWidth !== void 0 ? _options_getDefaultMinWidth : ()=>75;\n    }\n}\nfunction $292bc4e09cd0eb62$export$cb895dcf85db1319(props, state) {\n    let { getDefaultWidth: getDefaultWidth, getDefaultMinWidth: getDefaultMinWidth, tableWidth: tableWidth = 0 } = props;\n    let [resizingColumn, setResizingColumn] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    let columnLayout = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>new (0, $a9e7ae544a4e41dd$export$7ff77a162970b30e)({\n            getDefaultWidth: getDefaultWidth,\n            getDefaultMinWidth: getDefaultMinWidth\n        }), [\n        getDefaultWidth,\n        getDefaultMinWidth\n    ]);\n    let [controlledColumns, uncontrolledColumns] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>columnLayout.splitColumnsIntoControlledAndUncontrolled(state.collection.columns), [\n        state.collection.columns,\n        columnLayout\n    ]);\n    // uncontrolled column widths\n    let [uncontrolledWidths, setUncontrolledWidths] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>columnLayout.getInitialUncontrolledWidths(uncontrolledColumns));\n    // Update uncontrolled widths if the columns changed.\n    let [lastColumns, setLastColumns] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(state.collection.columns);\n    if (state.collection.columns !== lastColumns) {\n        if (state.collection.columns.length !== lastColumns.length || state.collection.columns.some((c, i)=>c.key !== lastColumns[i].key)) {\n            let newUncontrolledWidths = columnLayout.getInitialUncontrolledWidths(uncontrolledColumns);\n            setUncontrolledWidths(newUncontrolledWidths);\n        }\n        setLastColumns(state.collection.columns);\n    }\n    // combine columns back into one map that maintains same order as the columns\n    let colWidths = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>columnLayout.recombineColumns(state.collection.columns, uncontrolledWidths, uncontrolledColumns, controlledColumns), [\n        state.collection.columns,\n        uncontrolledWidths,\n        uncontrolledColumns,\n        controlledColumns,\n        columnLayout\n    ]);\n    let startResize = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((key)=>{\n        setResizingColumn(key);\n    }, [\n        setResizingColumn\n    ]);\n    let updateResizedColumns = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((key, width)=>{\n        let newControlled = new Map(Array.from(controlledColumns).map(([key, entry])=>[\n                key,\n                entry.props.width\n            ]));\n        let newSizes = columnLayout.resizeColumnWidth(tableWidth, state.collection, newControlled, uncontrolledWidths, key, width);\n        let map = new Map(Array.from(uncontrolledColumns).map(([key])=>[\n                key,\n                newSizes.get(key)\n            ]));\n        map.set(key, width);\n        setUncontrolledWidths(map);\n        return newSizes;\n    }, [\n        controlledColumns,\n        uncontrolledColumns,\n        setUncontrolledWidths,\n        tableWidth,\n        columnLayout,\n        state.collection,\n        uncontrolledWidths\n    ]);\n    let endResize = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setResizingColumn(null);\n    }, [\n        setResizingColumn\n    ]);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>columnLayout.buildColumnWidths(tableWidth, state.collection, colWidths), [\n        tableWidth,\n        state.collection,\n        colWidths,\n        columnLayout\n    ]);\n    return (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            resizingColumn: resizingColumn,\n            updateResizedColumns: updateResizedColumns,\n            startResize: startResize,\n            endResize: endResize,\n            getColumnWidth: (key)=>columnLayout.getColumnWidth(key),\n            getColumnMinWidth: (key)=>columnLayout.getColumnMinWidth(key),\n            getColumnMaxWidth: (key)=>columnLayout.getColumnMaxWidth(key),\n            tableState: state\n        }), [\n        columnLayout,\n        resizingColumn,\n        updateResizedColumns,\n        startResize,\n        endResize,\n        state\n    ]);\n}\n/*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ /*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ const $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY = \"row-header-column-\" + Math.random().toString(36).slice(2);\nlet $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY_DRAG = \"row-header-column-\" + Math.random().toString(36).slice(2);\nwhile($788781baa30117fa$var$ROW_HEADER_COLUMN_KEY === $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY_DRAG)$788781baa30117fa$var$ROW_HEADER_COLUMN_KEY_DRAG = \"row-header-column-\" + Math.random().toString(36).slice(2);\nfunction $788781baa30117fa$export$7c127db850d4e81e(keyMap, columnNodes) {\n    if (columnNodes.length === 0) return [];\n    let columns = [];\n    let seen = new Map();\n    for (let column of columnNodes){\n        let parentKey = column.parentKey;\n        let col = [\n            column\n        ];\n        while(parentKey){\n            let parent = keyMap.get(parentKey);\n            if (!parent) break;\n            // If we've already seen this parent, than it is shared\n            // with a previous column. If the current column is taller\n            // than the previous column, than we need to shift the parent\n            // in the previous column so it's level with the current column.\n            if (seen.has(parent)) {\n                parent.colspan++;\n                let { column: column, index: index } = seen.get(parent);\n                if (index > col.length) break;\n                for(let i = index; i < col.length; i++)column.splice(i, 0, null);\n                // Adjust shifted indices\n                for(let i = col.length; i < column.length; i++)if (column[i] && seen.has(column[i])) seen.get(column[i]).index = i;\n            } else {\n                parent.colspan = 1;\n                col.push(parent);\n                seen.set(parent, {\n                    column: col,\n                    index: col.length - 1\n                });\n            }\n            parentKey = parent.parentKey;\n        }\n        columns.push(col);\n        column.index = columns.length - 1;\n    }\n    let maxLength = Math.max(...columns.map((c)=>c.length));\n    let headerRows = Array(maxLength).fill(0).map(()=>[]);\n    // Convert columns into rows.\n    let colIndex = 0;\n    for (let column of columns){\n        let i = maxLength - 1;\n        for (let item of column){\n            if (item) {\n                // Fill the space up until the current column with a placeholder\n                let row = headerRows[i];\n                let rowLength = row.reduce((p, c)=>p + c.colspan, 0);\n                if (rowLength < colIndex) {\n                    let placeholder = {\n                        type: \"placeholder\",\n                        key: \"placeholder-\" + item.key,\n                        colspan: colIndex - rowLength,\n                        index: rowLength,\n                        value: null,\n                        rendered: null,\n                        level: i,\n                        hasChildNodes: false,\n                        childNodes: [],\n                        textValue: null\n                    };\n                    // eslint-disable-next-line max-depth\n                    if (row.length > 0) {\n                        row[row.length - 1].nextKey = placeholder.key;\n                        placeholder.prevKey = row[row.length - 1].key;\n                    }\n                    row.push(placeholder);\n                }\n                if (row.length > 0) {\n                    row[row.length - 1].nextKey = item.key;\n                    item.prevKey = row[row.length - 1].key;\n                }\n                item.level = i;\n                item.colIndex = colIndex;\n                row.push(item);\n            }\n            i--;\n        }\n        colIndex++;\n    }\n    // Add placeholders at the end of each row that is shorter than the maximum\n    let i = 0;\n    for (let row of headerRows){\n        let rowLength = row.reduce((p, c)=>p + c.colspan, 0);\n        if (rowLength < columnNodes.length) {\n            let placeholder = {\n                type: \"placeholder\",\n                key: \"placeholder-\" + row[row.length - 1].key,\n                colspan: columnNodes.length - rowLength,\n                index: rowLength,\n                value: null,\n                rendered: null,\n                level: i,\n                hasChildNodes: false,\n                childNodes: [],\n                textValue: null,\n                prevKey: row[row.length - 1].key\n            };\n            row.push(placeholder);\n        }\n        i++;\n    }\n    return headerRows.map((childNodes, index)=>{\n        let row = {\n            type: \"headerrow\",\n            key: \"headerrow-\" + index,\n            index: index,\n            value: null,\n            rendered: null,\n            level: 0,\n            hasChildNodes: true,\n            childNodes: childNodes,\n            textValue: null\n        };\n        return row;\n    });\n}\nclass $788781baa30117fa$export$596e1b2e2cf93690 extends (0, _react_stately_grid__WEBPACK_IMPORTED_MODULE_1__.GridCollection) {\n    *[Symbol.iterator]() {\n        yield* this.body.childNodes;\n    }\n    get size() {\n        return this._size;\n    }\n    getKeys() {\n        return this.keyMap.keys();\n    }\n    getKeyBefore(key) {\n        let node = this.keyMap.get(key);\n        return node ? node.prevKey : null;\n    }\n    getKeyAfter(key) {\n        let node = this.keyMap.get(key);\n        return node ? node.nextKey : null;\n    }\n    getFirstKey() {\n        var _getFirstItem;\n        return (_getFirstItem = (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.getFirstItem)(this.body.childNodes)) === null || _getFirstItem === void 0 ? void 0 : _getFirstItem.key;\n    }\n    getLastKey() {\n        var _getLastItem;\n        return (_getLastItem = (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.getLastItem)(this.body.childNodes)) === null || _getLastItem === void 0 ? void 0 : _getLastItem.key;\n    }\n    getItem(key) {\n        return this.keyMap.get(key);\n    }\n    at(idx) {\n        const keys = [\n            ...this.getKeys()\n        ];\n        return this.getItem(keys[idx]);\n    }\n    getTextValue(key) {\n        let row = this.getItem(key);\n        if (!row) return \"\";\n        // If the row has a textValue, use that.\n        if (row.textValue) return row.textValue;\n        // Otherwise combine the text of each of the row header columns.\n        let rowHeaderColumnKeys = this.rowHeaderColumnKeys;\n        if (rowHeaderColumnKeys) {\n            let text = [];\n            for (let cell of row.childNodes){\n                let column = this.columns[cell.index];\n                if (rowHeaderColumnKeys.has(column.key) && cell.textValue) text.push(cell.textValue);\n                if (text.length === rowHeaderColumnKeys.size) break;\n            }\n            return text.join(\" \");\n        }\n        return \"\";\n    }\n    constructor(nodes, prev, opts){\n        let rowHeaderColumnKeys = new Set();\n        let body;\n        let columns = [];\n        // Add cell for selection checkboxes if needed.\n        if (opts === null || opts === void 0 ? void 0 : opts.showSelectionCheckboxes) {\n            let rowHeaderColumn = {\n                type: \"column\",\n                key: $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY,\n                value: null,\n                textValue: \"\",\n                level: 0,\n                index: (opts === null || opts === void 0 ? void 0 : opts.showDragButtons) ? 1 : 0,\n                hasChildNodes: false,\n                rendered: null,\n                childNodes: [],\n                props: {\n                    isSelectionCell: true\n                }\n            };\n            columns.unshift(rowHeaderColumn);\n        }\n        // Add cell for drag buttons if needed.\n        if (opts === null || opts === void 0 ? void 0 : opts.showDragButtons) {\n            let rowHeaderColumn = {\n                type: \"column\",\n                key: $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY_DRAG,\n                value: null,\n                textValue: \"\",\n                level: 0,\n                index: 0,\n                hasChildNodes: false,\n                rendered: null,\n                childNodes: [],\n                props: {\n                    isDragButtonCell: true\n                }\n            };\n            columns.unshift(rowHeaderColumn);\n        }\n        let rows = [];\n        let columnKeyMap = new Map();\n        let visit = (node)=>{\n            switch(node.type){\n                case \"body\":\n                    body = node;\n                    break;\n                case \"column\":\n                    columnKeyMap.set(node.key, node);\n                    if (!node.hasChildNodes) {\n                        columns.push(node);\n                        if (node.props.isRowHeader) rowHeaderColumnKeys.add(node.key);\n                    }\n                    break;\n                case \"item\":\n                    rows.push(node);\n                    return; // do not go into childNodes\n            }\n            for (let child of node.childNodes)visit(child);\n        };\n        for (let node of nodes)visit(node);\n        let headerRows = $788781baa30117fa$export$7c127db850d4e81e(columnKeyMap, columns);\n        headerRows.forEach((row, i)=>rows.splice(i, 0, row));\n        super({\n            columnCount: columns.length,\n            items: rows,\n            visitNode: (node)=>{\n                node.column = columns[node.index];\n                return node;\n            }\n        });\n        this._size = 0;\n        this.columns = columns;\n        this.rowHeaderColumnKeys = rowHeaderColumnKeys;\n        this.body = body;\n        this.headerRows = headerRows;\n        this._size = [\n            ...body.childNodes\n        ].length;\n        // Default row header column to the first one.\n        if (this.rowHeaderColumnKeys.size === 0) {\n            if (opts === null || opts === void 0 ? void 0 : opts.showSelectionCheckboxes) {\n                if (opts === null || opts === void 0 ? void 0 : opts.showDragButtons) this.rowHeaderColumnKeys.add(this.columns[2].key);\n                else this.rowHeaderColumnKeys.add(this.columns[1].key);\n            } else this.rowHeaderColumnKeys.add(this.columns[0].key);\n        }\n    }\n}\nconst $4a0dd036d492cee4$var$OPPOSITE_SORT_DIRECTION = {\n    ascending: \"descending\",\n    descending: \"ascending\"\n};\nfunction $4a0dd036d492cee4$export$907bcc6c48325fd6(props) {\n    let [isKeyboardNavigationDisabled, setKeyboardNavigationDisabled] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    let { selectionMode: selectionMode = \"none\", showSelectionCheckboxes: showSelectionCheckboxes, showDragButtons: showDragButtons } = props;\n    let context = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            showSelectionCheckboxes: showSelectionCheckboxes && selectionMode !== \"none\",\n            showDragButtons: showDragButtons,\n            selectionMode: selectionMode,\n            columns: []\n        }), [\n        props.children,\n        showSelectionCheckboxes,\n        selectionMode,\n        showDragButtons\n    ]);\n    let collection = (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.useCollection)(props, (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((nodes)=>new (0, $788781baa30117fa$export$596e1b2e2cf93690)(nodes, null, context), [\n        context\n    ]), context);\n    let { disabledKeys: disabledKeys, selectionManager: selectionManager } = (0, _react_stately_grid__WEBPACK_IMPORTED_MODULE_1__.useGridState)({\n        ...props,\n        collection: collection,\n        disabledBehavior: props.disabledBehavior || \"selection\"\n    });\n    return {\n        collection: collection,\n        disabledKeys: disabledKeys,\n        selectionManager: selectionManager,\n        showSelectionCheckboxes: props.showSelectionCheckboxes || false,\n        sortDescriptor: props.sortDescriptor,\n        isKeyboardNavigationDisabled: collection.size === 0 || isKeyboardNavigationDisabled,\n        setKeyboardNavigationDisabled: setKeyboardNavigationDisabled,\n        sort (columnKey, direction) {\n            var _props_sortDescriptor;\n            props.onSortChange({\n                column: columnKey,\n                direction: direction !== null && direction !== void 0 ? direction : ((_props_sortDescriptor = props.sortDescriptor) === null || _props_sortDescriptor === void 0 ? void 0 : _props_sortDescriptor.column) === columnKey ? $4a0dd036d492cee4$var$OPPOSITE_SORT_DIRECTION[props.sortDescriptor.direction] : \"ascending\"\n            });\n        }\n    };\n}\n/*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ function $312ae3b56a94a86e$var$TableHeader(props) {\n    return null;\n}\n$312ae3b56a94a86e$var$TableHeader.getCollectionNode = function* getCollectionNode(props, context) {\n    let { children: children, columns: columns } = props;\n    // Clear columns so they aren't double added in strict mode.\n    context.columns = [];\n    if (typeof children === \"function\") {\n        if (!columns) throw new Error(\"props.children was a function but props.columns is missing\");\n        for (let column of columns)yield {\n            type: \"column\",\n            value: column,\n            renderer: children\n        };\n    } else {\n        let columns = [];\n        (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.forEach(children, (column)=>{\n            columns.push({\n                type: \"column\",\n                element: column\n            });\n        });\n        yield* columns;\n    }\n};\n/**\r\n * A TableHeader is a container for the Column elements in a Table. Columns can be statically defined\r\n * as children, or generated dynamically using a function based on the data passed to the `columns` prop.\r\n */ // We don't want getCollectionNode to show up in the type definition\nlet $312ae3b56a94a86e$export$f850895b287ef28e = $312ae3b56a94a86e$var$TableHeader;\n/*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ function $4ae5314bf50db1a3$var$TableBody(props) {\n    return null;\n}\n$4ae5314bf50db1a3$var$TableBody.getCollectionNode = function* getCollectionNode(props) {\n    let { children: children, items: items } = props;\n    yield {\n        type: \"body\",\n        hasChildNodes: true,\n        props: props,\n        *childNodes () {\n            if (typeof children === \"function\") {\n                if (!items) throw new Error(\"props.children was a function but props.items is missing\");\n                for (let item of items)yield {\n                    type: \"item\",\n                    value: item,\n                    renderer: children\n                };\n            } else {\n                let items = [];\n                (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.forEach(children, (item)=>{\n                    items.push({\n                        type: \"item\",\n                        element: item\n                    });\n                });\n                yield* items;\n            }\n        }\n    };\n};\n/**\r\n * A TableBody is a container for the Row elements of a Table. Rows can be statically defined\r\n * as children, or generated dynamically using a function based on the data passed to the `items` prop.\r\n */ // We don't want getCollectionNode to show up in the type definition\nlet $4ae5314bf50db1a3$export$76ccd210b9029917 = $4ae5314bf50db1a3$var$TableBody;\n/*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ function $1cd244557c2f97d5$var$Column(props) {\n    return null;\n}\n$1cd244557c2f97d5$var$Column.getCollectionNode = function* getCollectionNode(props, context) {\n    let { title: title, children: children, childColumns: childColumns } = props;\n    let rendered = title || children;\n    let textValue = props.textValue || (typeof rendered === \"string\" ? rendered : \"\") || props[\"aria-label\"];\n    let fullNodes = yield {\n        type: \"column\",\n        hasChildNodes: !!childColumns || title && (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.count(children) > 0,\n        rendered: rendered,\n        textValue: textValue,\n        props: props,\n        *childNodes () {\n            if (childColumns) for (let child of childColumns)yield {\n                type: \"column\",\n                value: child\n            };\n            else if (title) {\n                let childColumns = [];\n                (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.forEach(children, (child)=>{\n                    childColumns.push({\n                        type: \"column\",\n                        element: child\n                    });\n                });\n                yield* childColumns;\n            }\n        },\n        shouldInvalidate (newContext) {\n            // This is a bit of a hack, but it works.\n            // If this method is called, then there's a cached version of this node available.\n            // But, we need to keep the list of columns in the new context up to date.\n            updateContext(newContext);\n            return false;\n        }\n    };\n    let updateContext = (context)=>{\n        // register leaf columns on the context so that <Row> can access them\n        for (let node of fullNodes)if (!node.hasChildNodes) context.columns.push(node);\n    };\n    updateContext(context);\n};\n/**\r\n * A Column represents a field of each item within a Table. Columns may also contain nested\r\n * Column elements to represent column groups. Nested columns can be statically defined as\r\n * children, or dynamically generated using a function based on the `childColumns` prop.\r\n */ // We don't want getCollectionNode to show up in the type definition\nlet $1cd244557c2f97d5$export$816b5d811295e6bc = $1cd244557c2f97d5$var$Column;\n/*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ function $70d70eb16ea48428$var$Row(props) {\n    return null;\n}\n$70d70eb16ea48428$var$Row.getCollectionNode = function* getCollectionNode(props, context) {\n    let { children: children, textValue: textValue, UNSTABLE_childItems: UNSTABLE_childItems } = props;\n    yield {\n        type: \"item\",\n        props: props,\n        textValue: textValue,\n        \"aria-label\": props[\"aria-label\"],\n        hasChildNodes: true,\n        *childNodes () {\n            // Process cells first\n            if (context.showDragButtons) yield {\n                type: \"cell\",\n                key: \"header-drag\",\n                props: {\n                    isDragButtonCell: true\n                }\n            };\n            if (context.showSelectionCheckboxes && context.selectionMode !== \"none\") yield {\n                type: \"cell\",\n                key: \"header\",\n                props: {\n                    isSelectionCell: true\n                }\n            };\n            if (typeof children === \"function\") {\n                for (let column of context.columns)yield {\n                    type: \"cell\",\n                    element: children(column.key),\n                    key: column.key // this is combined with the row key by CollectionBuilder\n                };\n                if (UNSTABLE_childItems) for (let child of UNSTABLE_childItems)// the parent renderer and use that to build the full node of this child row, using the value provided here to generate the cells\n                yield {\n                    type: \"item\",\n                    value: child\n                };\n            } else {\n                let cells = [];\n                let childRows = [];\n                (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.forEach(children, (node)=>{\n                    if (node.type === $70d70eb16ea48428$var$Row) {\n                        if (cells.length < context.columns.length) throw new Error(\"All of a Row's child Cells must be positioned before any child Rows.\");\n                        childRows.push({\n                            type: \"item\",\n                            element: node\n                        });\n                    } else cells.push({\n                        type: \"cell\",\n                        element: node\n                    });\n                });\n                if (cells.length !== context.columns.length) throw new Error(`Cell count must match column count. Found ${cells.length} cells and ${context.columns.length} columns.`);\n                yield* cells;\n                yield* childRows;\n            }\n        },\n        shouldInvalidate (newContext) {\n            // Invalidate all rows if the columns changed.\n            return newContext.columns.length !== context.columns.length || newContext.columns.some((c, i)=>c.key !== context.columns[i].key) || newContext.showSelectionCheckboxes !== context.showSelectionCheckboxes || newContext.showDragButtons !== context.showDragButtons || newContext.selectionMode !== context.selectionMode;\n        }\n    };\n};\n/**\r\n * A Row represents a single item in a Table and contains Cell elements for each column.\r\n * Cells can be statically defined as children, or generated dynamically using a function\r\n * based on the columns defined in the TableHeader.\r\n */ // We don't want getCollectionNode to show up in the type definition\nlet $70d70eb16ea48428$export$b59bdbef9ce70de2 = $70d70eb16ea48428$var$Row;\n/*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ function $941d1d9a6a28982a$var$Cell(props) {\n    return null;\n}\n$941d1d9a6a28982a$var$Cell.getCollectionNode = function* getCollectionNode(props) {\n    let { children: children } = props;\n    let textValue = props.textValue || (typeof children === \"string\" ? children : \"\") || props[\"aria-label\"] || \"\";\n    yield {\n        type: \"cell\",\n        props: props,\n        rendered: children,\n        textValue: textValue,\n        \"aria-label\": props[\"aria-label\"],\n        hasChildNodes: false\n    };\n};\n/**\r\n * A Cell represents the value of a single Column within a Table Row.\r\n */ // We don't want getCollectionNode to show up in the type definition\nlet $941d1d9a6a28982a$export$f6f0c3fe4ec306ea = $941d1d9a6a28982a$var$Cell;\n/*\r\n * Copyright 2023 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ function $ee65a0057fd99531$export$34dfa8a1622185a4(props) {\n    let { selectionMode: selectionMode = \"none\", showSelectionCheckboxes: showSelectionCheckboxes, showDragButtons: showDragButtons, UNSTABLE_expandedKeys: propExpandedKeys, UNSTABLE_defaultExpandedKeys: propDefaultExpandedKeys, UNSTABLE_onExpandedChange: UNSTABLE_onExpandedChange, children: children } = props;\n    if (!(0, _react_stately_flags__WEBPACK_IMPORTED_MODULE_3__.tableNestedRows)()) throw new Error(\"Feature flag for table nested rows must be enabled to use useTreeGridState.\");\n    let [expandedKeys, setExpandedKeys] = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_4__.useControlledState)(propExpandedKeys ? $ee65a0057fd99531$var$convertExpanded(propExpandedKeys) : undefined, propDefaultExpandedKeys ? $ee65a0057fd99531$var$convertExpanded(propDefaultExpandedKeys) : new Set(), UNSTABLE_onExpandedChange);\n    let context = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            showSelectionCheckboxes: showSelectionCheckboxes && selectionMode !== \"none\",\n            showDragButtons: showDragButtons,\n            selectionMode: selectionMode,\n            columns: []\n        }), [\n        children,\n        showSelectionCheckboxes,\n        selectionMode,\n        showDragButtons\n    ]);\n    let builder = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>new (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.CollectionBuilder)(), []);\n    let nodes = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>builder.build({\n            children: children\n        }, context), [\n        builder,\n        children,\n        context\n    ]);\n    let treeGridCollection = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return $ee65a0057fd99531$var$generateTreeGridCollection(nodes, {\n            showSelectionCheckboxes: showSelectionCheckboxes,\n            showDragButtons: showDragButtons,\n            expandedKeys: expandedKeys\n        });\n    }, [\n        nodes,\n        showSelectionCheckboxes,\n        showDragButtons,\n        expandedKeys\n    ]);\n    let onToggle = (key)=>{\n        setExpandedKeys($ee65a0057fd99531$var$toggleKey(expandedKeys, key, treeGridCollection));\n    };\n    let collection = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return new (0, $788781baa30117fa$export$596e1b2e2cf93690)(treeGridCollection.tableNodes, null, context);\n    }, [\n        context,\n        treeGridCollection.tableNodes\n    ]);\n    let tableState = (0, $4a0dd036d492cee4$export$907bcc6c48325fd6)({\n        ...props,\n        collection: collection\n    });\n    return {\n        ...tableState,\n        keyMap: treeGridCollection.keyMap,\n        userColumnCount: treeGridCollection.userColumnCount,\n        expandedKeys: expandedKeys,\n        toggleKey: onToggle\n    };\n}\nfunction $ee65a0057fd99531$var$toggleKey(currentExpandedKeys, key, collection) {\n    let updatedExpandedKeys;\n    if (currentExpandedKeys === \"all\") {\n        updatedExpandedKeys = new Set(collection.flattenedRows.filter((row)=>row.props.UNSTABLE_childItems || row.props.children.length > collection.userColumnCount).map((row)=>row.key));\n        updatedExpandedKeys.delete(key);\n    } else {\n        updatedExpandedKeys = new Set(currentExpandedKeys);\n        if (updatedExpandedKeys.has(key)) updatedExpandedKeys.delete(key);\n        else updatedExpandedKeys.add(key);\n    }\n    return updatedExpandedKeys;\n}\nfunction $ee65a0057fd99531$var$convertExpanded(expanded) {\n    if (!expanded) return new Set();\n    return expanded === \"all\" ? \"all\" : new Set(expanded);\n}\nfunction $ee65a0057fd99531$var$generateTreeGridCollection(nodes, opts) {\n    let { expandedKeys: expandedKeys = new Set() } = opts;\n    let body;\n    let flattenedRows = [];\n    let columnCount = 0;\n    let userColumnCount = 0;\n    let originalColumns = [];\n    let keyMap = new Map();\n    if (opts === null || opts === void 0 ? void 0 : opts.showSelectionCheckboxes) columnCount++;\n    if (opts === null || opts === void 0 ? void 0 : opts.showDragButtons) columnCount++;\n    let topLevelRows = [];\n    let visit = (node)=>{\n        switch(node.type){\n            case \"body\":\n                body = node;\n                keyMap.set(body.key, body);\n                break;\n            case \"column\":\n                if (!node.hasChildNodes) userColumnCount++;\n                break;\n            case \"item\":\n                topLevelRows.push(node);\n                return;\n        }\n        for (let child of node.childNodes)visit(child);\n    };\n    for (let node of nodes){\n        if (node.type === \"column\") originalColumns.push(node);\n        visit(node);\n    }\n    columnCount += userColumnCount;\n    // Update each grid node in the treegrid table with values specific to a treegrid structure. Also store a set of flattened row nodes for TableCollection to consume\n    let globalRowCount = 0;\n    let visitNode = (node, i)=>{\n        // Clone row node and its children so modifications to the node for treegrid specific values aren't applied on the nodes provided\n        // to TableCollection. Index, level, and parent keys are all changed to reflect a flattened row structure rather than the treegrid structure\n        // values automatically calculated via CollectionBuilder\n        if (node.type === \"item\") {\n            let childNodes = [];\n            for (let child of node.childNodes)if (child.type === \"cell\") {\n                let cellClone = {\n                    ...child\n                };\n                if (cellClone.index + 1 === columnCount) cellClone.nextKey = null;\n                childNodes.push({\n                    ...cellClone\n                });\n            }\n            let clone = {\n                ...node,\n                childNodes: childNodes,\n                parentKey: body.key,\n                level: 1,\n                index: globalRowCount++\n            };\n            flattenedRows.push(clone);\n        }\n        let newProps = {};\n        // Assign indexOfType to cells and rows for aria-posinset\n        if (node.type !== \"placeholder\" && node.type !== \"column\") newProps[\"indexOfType\"] = i;\n        // Use Object.assign instead of spread to preserve object reference for keyMap. Also ensures retrieving nodes\n        // via .childNodes returns the same object as the one found via keyMap look up\n        Object.assign(node, newProps);\n        keyMap.set(node.key, node);\n        let lastNode;\n        let rowIndex = 0;\n        for (let child of node.childNodes)if (!(child.type === \"item\" && expandedKeys !== \"all\" && !expandedKeys.has(node.key))) {\n            if (child.parentKey == null) child.parentKey = node.key;\n            if (lastNode) {\n                lastNode.nextKey = child.key;\n                child.prevKey = lastNode.key;\n            } else child.prevKey = null;\n            if (child.type === \"item\") visitNode(child, rowIndex++);\n            else visitNode(child, child.index);\n            lastNode = child;\n        }\n        if (lastNode) lastNode.nextKey = null;\n    };\n    let last;\n    topLevelRows.forEach((node, i)=>{\n        visitNode(node, i);\n        if (last) {\n            last.nextKey = node.key;\n            node.prevKey = last.key;\n        } else node.prevKey = null;\n        last = node;\n    });\n    if (last) last.nextKey = null;\n    return {\n        keyMap: keyMap,\n        userColumnCount: userColumnCount,\n        flattenedRows: flattenedRows,\n        tableNodes: [\n            ...originalColumns,\n            {\n                ...body,\n                childNodes: flattenedRows\n            }\n        ]\n    };\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvdGFibGUvZGlzdC9pbXBvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXdQO0FBQzFIO0FBQ2I7QUFDbEM7QUFDTTtBQUVyRjs7Ozs7Ozs7OztDQVVDLEdBQUc7Ozs7Ozs7Ozs7Q0FVSCxHQUFHOzs7Ozs7Ozs7O0NBVUgsR0FBRzs7Ozs7Ozs7OztDQVVILEdBQUcsU0FBU3lCLDBDQUEwQ0MsS0FBSztJQUN4RCxPQUFPQSxTQUFTLFFBQVMsRUFBQ0MsTUFBTUQsVUFBVUUsT0FBT0YsT0FBT0csS0FBSyxDQUFDLG9CQUFvQixJQUFHO0FBQ3pGO0FBQ0EsU0FBU0MsMENBQTBDSixLQUFLO0lBQ3BELElBQUksQ0FBQ0EsT0FBTyxPQUFPO0lBQ25CLElBQUlHLFFBQVFILE1BQU1HLEtBQUssQ0FBQztJQUN4Qiw2REFBNkQ7SUFDN0QsSUFBSSxDQUFDQSxPQUFPO1FBQ1JFLFFBQVFDLElBQUksQ0FBQyxDQUFDLE9BQU8sRUFBRU4sTUFBTSw2R0FBNkcsQ0FBQyxFQUFFO1FBQzdJLE9BQU87SUFDWDtJQUNBLE9BQU9PLFdBQVdKLEtBQUssQ0FBQyxFQUFFO0FBQzlCO0FBQ0EsU0FBU0ssMENBQTBDUixLQUFLLEVBQUVTLFVBQVU7SUFDaEUsSUFBSSxPQUFPVCxVQUFVLFVBQVU7UUFDM0IsSUFBSUcsUUFBUUgsTUFBTUcsS0FBSyxDQUFDO1FBQ3hCLElBQUksQ0FBQ0EsT0FBTyxNQUFNLElBQUlPLE1BQU07UUFDNUIsT0FBT0QsYUFBY0YsQ0FBQUEsV0FBV0osS0FBSyxDQUFDLEVBQUUsSUFBSSxHQUFFO0lBQ2xEO0lBQ0EsT0FBT0g7QUFDWDtBQUNBLFNBQVNXLDBDQUEwQ0MsUUFBUSxFQUFFSCxVQUFVO0lBQ25FLE9BQU9HLFlBQVksT0FBT0osMENBQTBDSSxVQUFVSCxjQUFjSSxPQUFPQyxnQkFBZ0I7QUFDdkg7QUFDQSxTQUFTQywwQ0FBMENDLFFBQVEsRUFBRVAsVUFBVTtJ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TUFBTUEsS0FBS3pILE9BQU8sR0FBRztJQUN6QixPQUFPO1FBQ0h0QixRQUFRQTtRQUNSNkgsaUJBQWlCQTtRQUNqQkksZUFBZUE7UUFDZkwsWUFBWTtlQUNMUztZQUNIO2dCQUNJLEdBQUcxRyxJQUFJO2dCQUNQUCxZQUFZNkc7WUFDaEI7U0FDSDtJQUNMO0FBQ0o7QUFLNHNCLENBQzVzQixrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYW5hbW9ubmV4dF91aS8uL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3RhdGVseS90YWJsZS9kaXN0L2ltcG9ydC5tanM/NmNkYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1NlY3Rpb24gYXMgJDY1NTUxMDRmZjA4NWJlZjQkcmVfZXhwb3J0JFNlY3Rpb24sIHVzZUNvbGxlY3Rpb24gYXMgJDFCZmpXJHVzZUNvbGxlY3Rpb24sIGdldEZpcnN0SXRlbSBhcyAkMUJmalckZ2V0Rmlyc3RJdGVtLCBnZXRMYXN0SXRlbSBhcyAkMUJmalckZ2V0TGFzdEl0ZW0sIENvbGxlY3Rpb25CdWlsZGVyIGFzICQxQmZqVyRDb2xsZWN0aW9uQnVpbGRlcn0gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L2NvbGxlY3Rpb25zXCI7XHJcbmltcG9ydCAkMUJmalckcmVhY3QsIHt1c2VTdGF0ZSBhcyAkMUJmalckdXNlU3RhdGUsIHVzZU1lbW8gYXMgJDFCZmpXJHVzZU1lbW8sIHVzZUNhbGxiYWNrIGFzICQxQmZqVyR1c2VDYWxsYmFja30gZnJvbSBcInJlYWN0XCI7XHJcbmltcG9ydCB7dXNlR3JpZFN0YXRlIGFzICQxQmZqVyR1c2VHcmlkU3RhdGUsIEdyaWRDb2xsZWN0aW9uIGFzICQxQmZqVyRHcmlkQ29sbGVjdGlvbn0gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L2dyaWRcIjtcclxuaW1wb3J0IHt0YWJsZU5lc3RlZFJvd3MgYXMgJDFCZmpXJHRhYmxlTmVzdGVkUm93c30gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L2ZsYWdzXCI7XHJcbmltcG9ydCB7dXNlQ29udHJvbGxlZFN0YXRlIGFzICQxQmZqVyR1c2VDb250cm9sbGVkU3RhdGV9IGZyb20gXCJAcmVhY3Qtc3RhdGVseS91dGlsc1wiO1xyXG5cclxuLypcclxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcclxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXHJcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxyXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi8gLypcclxuICogQ29weXJpZ2h0IDIwMjIgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcclxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXHJcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxyXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi8gLypcclxuICogQ29weXJpZ2h0IDIwMjIgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcclxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXHJcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxyXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi8gLypcclxuICogQ29weXJpZ2h0IDIwMjIgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcclxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXHJcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxyXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi8gZnVuY3Rpb24gJDY4MThiMWM0ZmM2NzAyOGQkZXhwb3J0JDE5OTRhMDc3Yjk4ZWUwZDUod2lkdGgpIHtcclxuICAgIHJldHVybiB3aWR0aCAhPSBudWxsICYmICghaXNOYU4od2lkdGgpIHx8IFN0cmluZyh3aWR0aCkubWF0Y2goL14oXFxkKykoPz0lJCkvKSAhPT0gbnVsbCk7XHJcbn1cclxuZnVuY3Rpb24gJDY4MThiMWM0ZmM2NzAyOGQkZXhwb3J0JDkwNzhiYWQ0YzM5MzQ2MDQod2lkdGgpIHtcclxuICAgIGlmICghd2lkdGgpIHJldHVybiAxO1xyXG4gICAgbGV0IG1hdGNoID0gd2lkdGgubWF0Y2goL14oLispKD89ZnIkKS8pO1xyXG4gICAgLy8gaWYgd2lkdGggaXMgdGhlIGluY29ycmVjdCBmb3JtYXQsIGp1c3QgZGVmYXVsdCBpdCB0byBhIDFmclxyXG4gICAgaWYgKCFtYXRjaCkge1xyXG4gICAgICAgIGNvbnNvbGUud2Fybihgd2lkdGg6ICR7d2lkdGh9IGlzIG5vdCBhIHN1cHBvcnRlZCBmb3JtYXQsIHdpZHRoIHNob3VsZCBiZSBhIG51bWJlciAoZXguIDE1MCksIHBlcmNlbnRhZ2UgKGV4LiAnNTAlJykgb3IgZnIgdW5pdCAoZXguICcyZnInKWAsIFwiZGVmYXVsdGluZyB0byAnMWZyJ1wiKTtcclxuICAgICAgICByZXR1cm4gMTtcclxuICAgIH1cclxuICAgIHJldHVybiBwYXJzZUZsb2F0KG1hdGNoWzBdKTtcclxufVxyXG5mdW5jdGlvbiAkNjgxOGIxYzRmYzY3MDI4ZCRleHBvcnQkN2JiYWQyNzg5NmY3YWU5Zih3aWR0aCwgdGFibGVXaWR0aCkge1xyXG4gICAgaWYgKHR5cGVvZiB3aWR0aCA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgIGxldCBtYXRjaCA9IHdpZHRoLm1hdGNoKC9eKFxcZCspKD89JSQpLyk7XHJcbiAgICAgICAgaWYgKCFtYXRjaCkgdGhyb3cgbmV3IEVycm9yKFwiT25seSBwZXJjZW50YWdlcyBvciBudW1iZXJzIGFyZSBzdXBwb3J0ZWQgZm9yIHN0YXRpYyBjb2x1bW4gd2lkdGhzXCIpO1xyXG4gICAgICAgIHJldHVybiB0YWJsZVdpZHRoICogKHBhcnNlRmxvYXQobWF0Y2hbMF0pIC8gMTAwKTtcclxuICAgIH1cclxuICAgIHJldHVybiB3aWR0aDtcclxufVxyXG5mdW5jdGlvbiAkNjgxOGIxYzRmYzY3MDI4ZCRleHBvcnQkNTkxODVjNjJhNzU0NGFhMChtYXhXaWR0aCwgdGFibGVXaWR0aCkge1xyXG4gICAgcmV0dXJuIG1heFdpZHRoICE9IG51bGwgPyAkNjgxOGIxYzRmYzY3MDI4ZCRleHBvcnQkN2JiYWQyNzg5NmY3YWU5ZihtYXhXaWR0aCwgdGFibGVXaWR0aCkgOiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcclxufVxyXG5mdW5jdGlvbiAkNjgxOGIxYzRmYzY3MDI4ZCRleHBvcnQkZjU1NjA1NGNlNDM1ODcwMShtaW5XaWR0aCwgdGFibGVXaWR0aCkge1xyXG4gICAgcmV0dXJuIG1pbldpZHRoICE9IG51bGwgPyAkNjgxOGIxYzRmYzY3MDI4ZCRleHBvcnQkN2JiYWQyNzg5NmY3YWU5ZihtaW5XaWR0aCwgdGFibGVXaWR0aCkgOiAwO1xyXG59XHJcbmZ1bmN0aW9uICQ2ODE4YjFjNGZjNjcwMjhkJGV4cG9ydCQ1NWQ1MGRjNjg3Mzg1NDkxKGF2YWlsYWJsZVdpZHRoLCBjb2x1bW5zLCBjaGFuZ2VkQ29sdW1ucywgZ2V0RGVmYXVsdFdpZHRoLCBnZXREZWZhdWx0TWluV2lkdGgpIHtcclxuICAgIGxldCBoYXNOb25Gcm96ZW5JdGVtcyA9IGZhbHNlO1xyXG4gICAgbGV0IGZsZXhJdGVtcyA9IGNvbHVtbnMubWFwKChjb2x1bW4sIGluZGV4KT0+e1xyXG4gICAgICAgIHZhciBfY29sdW1uX3dpZHRoLCBfcmVmLCBfcmVmMTtcclxuICAgICAgICBsZXQgd2lkdGggPSBjaGFuZ2VkQ29sdW1ucy5nZXQoY29sdW1uLmtleSkgIT0gbnVsbCA/IGNoYW5nZWRDb2x1bW5zLmdldChjb2x1bW4ua2V5KSA6IChfcmVmMSA9IChfcmVmID0gKF9jb2x1bW5fd2lkdGggPSBjb2x1bW4ud2lkdGgpICE9PSBudWxsICYmIF9jb2x1bW5fd2lkdGggIT09IHZvaWQgMCA/IF9jb2x1bW5fd2lkdGggOiBjb2x1bW4uZGVmYXVsdFdpZHRoKSAhPT0gbnVsbCAmJiBfcmVmICE9PSB2b2lkIDAgPyBfcmVmIDogZ2V0RGVmYXVsdFdpZHRoID09PSBudWxsIHx8IGdldERlZmF1bHRXaWR0aCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ2V0RGVmYXVsdFdpZHRoKGluZGV4KSkgIT09IG51bGwgJiYgX3JlZjEgIT09IHZvaWQgMCA/IF9yZWYxIDogXCIxZnJcIjtcclxuICAgICAgICBsZXQgZnJvemVuID0gZmFsc2U7XHJcbiAgICAgICAgbGV0IGJhc2VTaXplID0gMDtcclxuICAgICAgICBsZXQgZmxleCA9IDA7XHJcbiAgICAgICAgbGV0IHRhcmdldE1haW5TaXplID0gbnVsbDtcclxuICAgICAgICBpZiAoJDY4MThiMWM0ZmM2NzAyOGQkZXhwb3J0JDE5OTRhMDc3Yjk4ZWUwZDUod2lkdGgpKSB7XHJcbiAgICAgICAgICAgIGJhc2VTaXplID0gJDY4MThiMWM0ZmM2NzAyOGQkZXhwb3J0JDdiYmFkMjc4OTZmN2FlOWYod2lkdGgsIGF2YWlsYWJsZVdpZHRoKTtcclxuICAgICAgICAgICAgZnJvemVuID0gdHJ1ZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBmbGV4ID0gJDY4MThiMWM0ZmM2NzAyOGQkZXhwb3J0JDkwNzhiYWQ0YzM5MzQ2MDQod2lkdGgpO1xyXG4gICAgICAgICAgICBpZiAoZmxleCA8PSAwKSBmcm96ZW4gPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgX2NvbHVtbl9taW5XaWR0aCwgX3JlZjI7XHJcbiAgICAgICAgbGV0IG1pbiA9ICQ2ODE4YjFjNGZjNjcwMjhkJGV4cG9ydCRmNTU2MDU0Y2U0MzU4NzAxKChfcmVmMiA9IChfY29sdW1uX21pbldpZHRoID0gY29sdW1uLm1pbldpZHRoKSAhPT0gbnVsbCAmJiBfY29sdW1uX21pbldpZHRoICE9PSB2b2lkIDAgPyBfY29sdW1uX21pbldpZHRoIDogZ2V0RGVmYXVsdE1pbldpZHRoID09PSBudWxsIHx8IGdldERlZmF1bHRNaW5XaWR0aCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ2V0RGVmYXVsdE1pbldpZHRoKGluZGV4KSkgIT09IG51bGwgJiYgX3JlZjIgIT09IHZvaWQgMCA/IF9yZWYyIDogMCwgYXZhaWxhYmxlV2lkdGgpO1xyXG4gICAgICAgIGxldCBtYXggPSAkNjgxOGIxYzRmYzY3MDI4ZCRleHBvcnQkNTkxODVjNjJhNzU0NGFhMChjb2x1bW4ubWF4V2lkdGgsIGF2YWlsYWJsZVdpZHRoKTtcclxuICAgICAgICBsZXQgaHlwb3RoZXRpY2FsTWFpblNpemUgPSBNYXRoLm1heChtaW4sIE1hdGgubWluKGJhc2VTaXplLCBtYXgpKTtcclxuICAgICAgICAvLyA5LjcuMVxyXG4gICAgICAgIC8vIFdlIGRvbid0IG1ha2UgdXNlIG9mIGZsZXggYmFzaXMsIGl0J3MgYWx3YXlzIDAsIHNvIHdlIGFyZSBhbHdheXMgaW4gJ2dyb3cnIG1vZGUuXHJcbiAgICAgICAgLy8gOS43LjJcclxuICAgICAgICBpZiAoZnJvemVuKSB0YXJnZXRNYWluU2l6ZSA9IGh5cG90aGV0aWNhbE1haW5TaXplO1xyXG4gICAgICAgIGVsc2UgaWYgKGJhc2VTaXplID4gaHlwb3RoZXRpY2FsTWFpblNpemUpIHtcclxuICAgICAgICAgICAgZnJvemVuID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGFyZ2V0TWFpblNpemUgPSBoeXBvdGhldGljYWxNYWluU2l6ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gOS43LjNcclxuICAgICAgICBpZiAoIWZyb3plbikgaGFzTm9uRnJvemVuSXRlbXMgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGZyb3plbjogZnJvemVuLFxyXG4gICAgICAgICAgICBiYXNlU2l6ZTogYmFzZVNpemUsXHJcbiAgICAgICAgICAgIGh5cG90aGV0aWNhbE1haW5TaXplOiBoeXBvdGhldGljYWxNYWluU2l6ZSxcclxuICAgICAgICAgICAgbWluOiBtaW4sXHJcbiAgICAgICAgICAgIG1heDogbWF4LFxyXG4gICAgICAgICAgICBmbGV4OiBmbGV4LFxyXG4gICAgICAgICAgICB0YXJnZXRNYWluU2l6ZTogdGFyZ2V0TWFpblNpemUsXHJcbiAgICAgICAgICAgIHZpb2xhdGlvbjogMFxyXG4gICAgICAgIH07XHJcbiAgICB9KTtcclxuICAgIC8vIDkuNy40XHJcbiAgICAvLyA5LjcuNC5hXHJcbiAgICB3aGlsZShoYXNOb25Gcm96ZW5JdGVtcyl7XHJcbiAgICAgICAgLy8gOS43LjQuYlxyXG4gICAgICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlIHRoZSByZW1haW5pbmcgZnJlZSBzcGFjZSBhcyBmb3IgaW5pdGlhbCBmcmVlIHNwYWNlLFxyXG4gICAgICogYWJvdmUgKDkuNy4zKS4gSWYgdGhlIHN1bSBvZiB0aGUgdW5mcm96ZW4gZmxleCBpdGVtc+KAmSBmbGV4IGZhY3RvcnMgaXNcclxuICAgICAqIGxlc3MgdGhhbiBvbmUsIG11bHRpcGx5IHRoZSBpbml0aWFsIGZyZWUgc3BhY2UgYnkgdGhpcyBzdW0gKG9mIGZsZXggZmFjdG9ycykuXHJcbiAgICAgKiBJZiB0aGUgbWFnbml0dWRlIG9mIHRoaXMgdmFsdWUgaXMgbGVzcyB0aGFuIHRoZSBtYWduaXR1ZGUgb2ZcclxuICAgICAqIHRoZSByZW1haW5pbmcgZnJlZSBzcGFjZSwgdXNlIHRoaXMgYXMgdGhlIHJlbWFpbmluZyBmcmVlIHNwYWNlLlxyXG4gICAgICovIGxldCB1c2VkV2lkdGggPSAwO1xyXG4gICAgICAgIGxldCBmbGV4RmFjdG9ycyA9IDA7XHJcbiAgICAgICAgZmxleEl0ZW1zLmZvckVhY2goKGl0ZW0pPT57XHJcbiAgICAgICAgICAgIGlmIChpdGVtLmZyb3plbikgdXNlZFdpZHRoICs9IGl0ZW0udGFyZ2V0TWFpblNpemU7XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdXNlZFdpZHRoICs9IGl0ZW0uYmFzZVNpemU7XHJcbiAgICAgICAgICAgICAgICBmbGV4RmFjdG9ycyArPSBpdGVtLmZsZXg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBsZXQgcmVtYWluaW5nRnJlZVNwYWNlID0gYXZhaWxhYmxlV2lkdGggLSB1c2VkV2lkdGg7XHJcbiAgICAgICAgLy8gd2Ugb25seSBzdXBwb3J0IGludGVnZXIgRlIncywgYW5kIGJlY2F1c2Ugb2YgaGFzTm9uRnJvemVuSXRlbXMsIHdlIGtub3cgdGhhdCBmbGV4RmFjdG9ycyA+IDBcclxuICAgICAgICAvLyBzbyBubyBuZWVkIHRvIGNoZWNrIGZvciBmbGV4RmFjdG9ycyA8IDFcclxuICAgICAgICAvLyA5LjcuNC5jXHJcbiAgICAgICAgLyoqXHJcbiAgICAgKiBJZiB0aGUgcmVtYWluaW5nIGZyZWUgc3BhY2UgaXMgemVyb1xyXG4gICAgICogLSBEbyBub3RoaW5nLlxyXG4gICAgICogRWxzZSAvLyByZW1lbWJlciwgd2UncmUgYWx3YXlzIGluIGdyb3cgbW9kZVxyXG4gICAgICogLSBGaW5kIHRoZSByYXRpbyBvZiB0aGUgaXRlbeKAmXMgZmxleCBncm93IGZhY3RvciB0byB0aGVcclxuICAgICAqIHN1bSBvZiB0aGUgZmxleCBncm93IGZhY3RvcnMgb2YgYWxsIHVuZnJvemVuIGl0ZW1zIG9uXHJcbiAgICAgKiB0aGUgbGluZS4gU2V0IHRoZSBpdGVt4oCZcyB0YXJnZXQgbWFpbiBzaXplIHRvIGl0cyBmbGV4XHJcbiAgICAgKiBiYXNlIHNpemUgcGx1cyBhIGZyYWN0aW9uIG9mIHRoZSByZW1haW5pbmcgZnJlZSBzcGFjZVxyXG4gICAgICogcHJvcG9ydGlvbmFsIHRvIHRoZSByYXRpby5cclxuICAgICAqLyBpZiAocmVtYWluaW5nRnJlZVNwYWNlID4gMCkgZmxleEl0ZW1zLmZvckVhY2goKGl0ZW0pPT57XHJcbiAgICAgICAgICAgIGlmICghaXRlbS5mcm96ZW4pIHtcclxuICAgICAgICAgICAgICAgIGxldCByYXRpbyA9IGl0ZW0uZmxleCAvIGZsZXhGYWN0b3JzO1xyXG4gICAgICAgICAgICAgICAgaXRlbS50YXJnZXRNYWluU2l6ZSA9IGl0ZW0uYmFzZVNpemUgKyByYXRpbyAqIHJlbWFpbmluZ0ZyZWVTcGFjZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIDkuNy40LmRcclxuICAgICAgICAvKipcclxuICAgICAqIEZpeCBtaW4vbWF4IHZpb2xhdGlvbnMuIENsYW1wIGVhY2ggbm9uLWZyb3plbiBpdGVt4oCZc1xyXG4gICAgICogdGFyZ2V0IG1haW4gc2l6ZSBieSBpdHMgdXNlZCBtaW4gYW5kIG1heCBtYWluIHNpemVzXHJcbiAgICAgKiBhbmQgZmxvb3IgaXRzIGNvbnRlbnQtYm94IHNpemUgYXQgemVyby4gSWYgdGhlIGl0ZW3igJlzXHJcbiAgICAgKiB0YXJnZXQgbWFpbiBzaXplIHdhcyBtYWRlIHNtYWxsZXIgYnkgdGhpcywgaXTigJlzIGEgbWF4XHJcbiAgICAgKiB2aW9sYXRpb24uIElmIHRoZSBpdGVt4oCZcyB0YXJnZXQgbWFpbiBzaXplIHdhcyBtYWRlXHJcbiAgICAgKiBsYXJnZXIgYnkgdGhpcywgaXTigJlzIGEgbWluIHZpb2xhdGlvbi5cclxuICAgICAqLyBsZXQgdG90YWxWaW9sYXRpb24gPSAwO1xyXG4gICAgICAgIGZsZXhJdGVtcy5mb3JFYWNoKChpdGVtKT0+e1xyXG4gICAgICAgICAgICBpdGVtLnZpb2xhdGlvbiA9IDA7XHJcbiAgICAgICAgICAgIGlmICghaXRlbS5mcm96ZW4pIHtcclxuICAgICAgICAgICAgICAgIGxldCB7IG1pbjogbWluLCBtYXg6IG1heCwgdGFyZ2V0TWFpblNpemU6IHRhcmdldE1haW5TaXplIH0gPSBpdGVtO1xyXG4gICAgICAgICAgICAgICAgaXRlbS50YXJnZXRNYWluU2l6ZSA9IE1hdGgubWF4KG1pbiwgTWF0aC5taW4odGFyZ2V0TWFpblNpemUsIG1heCkpO1xyXG4gICAgICAgICAgICAgICAgaXRlbS52aW9sYXRpb24gPSBpdGVtLnRhcmdldE1haW5TaXplIC0gdGFyZ2V0TWFpblNpemU7XHJcbiAgICAgICAgICAgICAgICB0b3RhbFZpb2xhdGlvbiArPSBpdGVtLnZpb2xhdGlvbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIDkuNy40LmVcclxuICAgICAgICAvKipcclxuICAgICAqIEZyZWV6ZSBvdmVyLWZsZXhlZCBpdGVtcy4gVGhlIHRvdGFsIHZpb2xhdGlvbiBpcyB0aGVcclxuICAgICAqIHN1bSBvZiB0aGUgYWRqdXN0bWVudHMgZnJvbSB0aGUgcHJldmlvdXMgc3RlcFxyXG4gICAgICog4oiRKGNsYW1wZWQgc2l6ZSAtIHVuY2xhbXBlZCBzaXplKS4gSWYgdGhlIHRvdGFsIHZpb2xhdGlvbiBpczpcclxuICAgICAqIFplcm9cclxuICAgICAqIC0gRnJlZXplIGFsbCBpdGVtcy5cclxuICAgICAqXHJcbiAgICAgKiBQb3NpdGl2ZVxyXG4gICAgICogLSBGcmVlemUgYWxsIHRoZSBpdGVtcyB3aXRoIG1pbiB2aW9sYXRpb25zLlxyXG4gICAgICpcclxuICAgICAqIE5lZ2F0aXZlXHJcbiAgICAgKiAtIEZyZWV6ZSBhbGwgdGhlIGl0ZW1zIHdpdGggbWF4IHZpb2xhdGlvbnMuXHJcbiAgICAgKi8gaGFzTm9uRnJvemVuSXRlbXMgPSBmYWxzZTtcclxuICAgICAgICBmbGV4SXRlbXMuZm9yRWFjaCgoaXRlbSk9PntcclxuICAgICAgICAgICAgaWYgKHRvdGFsVmlvbGF0aW9uID09PSAwIHx8IE1hdGguc2lnbih0b3RhbFZpb2xhdGlvbikgPT09IE1hdGguc2lnbihpdGVtLnZpb2xhdGlvbikpIGl0ZW0uZnJvemVuID0gdHJ1ZTtcclxuICAgICAgICAgICAgZWxzZSBpZiAoIWl0ZW0uZnJvemVuKSBoYXNOb25Gcm96ZW5JdGVtcyA9IHRydWU7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gJDY4MThiMWM0ZmM2NzAyOGQkdmFyJGNhc2NhZGVSb3VuZGluZyhmbGV4SXRlbXMpO1xyXG59XHJcbmZ1bmN0aW9uICQ2ODE4YjFjNGZjNjcwMjhkJHZhciRjYXNjYWRlUm91bmRpbmcoZmxleEl0ZW1zKSB7XHJcbiAgICAvKlxyXG4gIEdpdmVuIGFuIGFycmF5IG9mIGZsb2F0cyB0aGF0IHN1bSB0byBhbiBpbnRlZ2VyLCB0aGlzIHJvdW5kcyB0aGUgZmxvYXRzXHJcbiAgYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgaW50ZWdlcnMgd2l0aCB0aGUgc2FtZSBzdW0uXHJcbiAgKi8gbGV0IGZwVG90YWwgPSAwO1xyXG4gICAgbGV0IGludFRvdGFsID0gMDtcclxuICAgIGxldCByb3VuZGVkQXJyYXkgPSBbXTtcclxuICAgIGZsZXhJdGVtcy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcclxuICAgICAgICBsZXQgZmxvYXQgPSBpdGVtLnRhcmdldE1haW5TaXplO1xyXG4gICAgICAgIGxldCBpbnRlZ2VyID0gTWF0aC5yb3VuZChmbG9hdCArIGZwVG90YWwpIC0gaW50VG90YWw7XHJcbiAgICAgICAgZnBUb3RhbCArPSBmbG9hdDtcclxuICAgICAgICBpbnRUb3RhbCArPSBpbnRlZ2VyO1xyXG4gICAgICAgIHJvdW5kZWRBcnJheS5wdXNoKGludGVnZXIpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcm91bmRlZEFycmF5O1xyXG59XHJcblxyXG5cclxuY2xhc3MgJGE5ZTdhZTU0NGE0ZTQxZGQkZXhwb3J0JDdmZjc3YTE2Mjk3MGIzMGUge1xyXG4gICAgLyoqIFRha2VzIGFuIGFycmF5IG9mIGNvbHVtbnMgYW5kIHNwbGl0cyBpdCBpbnRvIDIgbWFwcyBvZiBjb2x1bW5zIHdpdGggY29udHJvbGxlZCBhbmQgY29sdW1ucyB3aXRoIHVuY29udHJvbGxlZCB3aWR0aHMuICovIHNwbGl0Q29sdW1uc0ludG9Db250cm9sbGVkQW5kVW5jb250cm9sbGVkKGNvbHVtbnMpIHtcclxuICAgICAgICByZXR1cm4gY29sdW1ucy5yZWR1Y2UoKGFjYywgY29sKT0+e1xyXG4gICAgICAgICAgICBpZiAoY29sLnByb3BzLndpZHRoICE9IG51bGwpIGFjY1swXS5zZXQoY29sLmtleSwgY29sKTtcclxuICAgICAgICAgICAgZWxzZSBhY2NbMV0uc2V0KGNvbC5rZXksIGNvbCk7XHJcbiAgICAgICAgICAgIHJldHVybiBhY2M7XHJcbiAgICAgICAgfSwgW1xyXG4gICAgICAgICAgICBuZXcgTWFwKCksXHJcbiAgICAgICAgICAgIG5ldyBNYXAoKVxyXG4gICAgICAgIF0pO1xyXG4gICAgfVxyXG4gICAgLyoqIFRha2VzIHVuY29udHJvbGxlZCBhbmQgY29udHJvbGxlZCB3aWR0aHMgYW5kIGpvaW5zIHRoZW0gaW50byBhIHNpbmdsZSBNYXAuICovIHJlY29tYmluZUNvbHVtbnMoY29sdW1ucywgdW5jb250cm9sbGVkV2lkdGhzLCB1bmNvbnRyb2xsZWRDb2x1bW5zLCBjb250cm9sbGVkQ29sdW1ucykge1xyXG4gICAgICAgIHJldHVybiBuZXcgTWFwKGNvbHVtbnMubWFwKChjb2wpPT57XHJcbiAgICAgICAgICAgIGlmICh1bmNvbnRyb2xsZWRDb2x1bW5zLmhhcyhjb2wua2V5KSkgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgIGNvbC5rZXksXHJcbiAgICAgICAgICAgICAgICB1bmNvbnRyb2xsZWRXaWR0aHMuZ2V0KGNvbC5rZXkpXHJcbiAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgIGVsc2UgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgIGNvbC5rZXksXHJcbiAgICAgICAgICAgICAgICBjb250cm9sbGVkQ29sdW1ucy5nZXQoY29sLmtleSkucHJvcHMud2lkdGhcclxuICAgICAgICAgICAgXTtcclxuICAgICAgICB9KSk7XHJcbiAgICB9XHJcbiAgICAvKiogVXNlZCB0byBtYWtlIGFuIGluaXRpYWwgTWFwIG9mIHRoZSB1bmNvbnRyb2xsZWQgd2lkdGhzIGJhc2VkIG9uIGRlZmF1bHQgd2lkdGhzLiAqLyBnZXRJbml0aWFsVW5jb250cm9sbGVkV2lkdGhzKHVuY29udHJvbGxlZENvbHVtbnMpIHtcclxuICAgICAgICByZXR1cm4gbmV3IE1hcChBcnJheS5mcm9tKHVuY29udHJvbGxlZENvbHVtbnMpLm1hcCgoW2tleSwgY29sXSk9PntcclxuICAgICAgICAgICAgdmFyIF90aGlzX2dldERlZmF1bHRXaWR0aCwgX3RoaXM7XHJcbiAgICAgICAgICAgIHZhciBfY29sX3Byb3BzX2RlZmF1bHRXaWR0aCwgX3JlZjtcclxuICAgICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgIGtleSxcclxuICAgICAgICAgICAgICAgIChfcmVmID0gKF9jb2xfcHJvcHNfZGVmYXVsdFdpZHRoID0gY29sLnByb3BzLmRlZmF1bHRXaWR0aCkgIT09IG51bGwgJiYgX2NvbF9wcm9wc19kZWZhdWx0V2lkdGggIT09IHZvaWQgMCA/IF9jb2xfcHJvcHNfZGVmYXVsdFdpZHRoIDogKF90aGlzX2dldERlZmF1bHRXaWR0aCA9IChfdGhpcyA9IHRoaXMpLmdldERlZmF1bHRXaWR0aCkgPT09IG51bGwgfHwgX3RoaXNfZ2V0RGVmYXVsdFdpZHRoID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpc19nZXREZWZhdWx0V2lkdGguY2FsbChfdGhpcywgY29sKSkgIT09IG51bGwgJiYgX3JlZiAhPT0gdm9pZCAwID8gX3JlZiA6IFwiMWZyXCJcclxuICAgICAgICAgICAgXTtcclxuICAgICAgICB9KSk7XHJcbiAgICB9XHJcbiAgICBnZXRDb2x1bW5XaWR0aChrZXkpIHtcclxuICAgICAgICB2YXIgX3RoaXNfY29sdW1uV2lkdGhzX2dldDtcclxuICAgICAgICByZXR1cm4gKF90aGlzX2NvbHVtbldpZHRoc19nZXQgPSB0aGlzLmNvbHVtbldpZHRocy5nZXQoa2V5KSkgIT09IG51bGwgJiYgX3RoaXNfY29sdW1uV2lkdGhzX2dldCAhPT0gdm9pZCAwID8gX3RoaXNfY29sdW1uV2lkdGhzX2dldCA6IDA7XHJcbiAgICB9XHJcbiAgICBnZXRDb2x1bW5NaW5XaWR0aChrZXkpIHtcclxuICAgICAgICB2YXIgX3RoaXNfY29sdW1uTWluV2lkdGhzX2dldDtcclxuICAgICAgICByZXR1cm4gKF90aGlzX2NvbHVtbk1pbldpZHRoc19nZXQgPSB0aGlzLmNvbHVtbk1pbldpZHRocy5nZXQoa2V5KSkgIT09IG51bGwgJiYgX3RoaXNfY29sdW1uTWluV2lkdGhzX2dldCAhPT0gdm9pZCAwID8gX3RoaXNfY29sdW1uTWluV2lkdGhzX2dldCA6IDA7XHJcbiAgICB9XHJcbiAgICBnZXRDb2x1bW5NYXhXaWR0aChrZXkpIHtcclxuICAgICAgICB2YXIgX3RoaXNfY29sdW1uTWF4V2lkdGhzX2dldDtcclxuICAgICAgICByZXR1cm4gKF90aGlzX2NvbHVtbk1heFdpZHRoc19nZXQgPSB0aGlzLmNvbHVtbk1heFdpZHRocy5nZXQoa2V5KSkgIT09IG51bGwgJiYgX3RoaXNfY29sdW1uTWF4V2lkdGhzX2dldCAhPT0gdm9pZCAwID8gX3RoaXNfY29sdW1uTWF4V2lkdGhzX2dldCA6IDA7XHJcbiAgICB9XHJcbiAgICByZXNpemVDb2x1bW5XaWR0aCh0YWJsZVdpZHRoLCBjb2xsZWN0aW9uLCBjb250cm9sbGVkV2lkdGhzLCB1bmNvbnRyb2xsZWRXaWR0aHMsIGNvbCA9IG51bGwsIHdpZHRoKSB7XHJcbiAgICAgICAgbGV0IHByZXZDb2x1bW5XaWR0aHMgPSB0aGlzLmNvbHVtbldpZHRocztcclxuICAgICAgICAvLyByZXNpemluZyBhIGNvbHVtblxyXG4gICAgICAgIGxldCByZXNpemVJbmRleCA9IEluZmluaXR5O1xyXG4gICAgICAgIGxldCByZXNpemluZ0NoYW5nZWQgPSBuZXcgTWFwKFtcclxuICAgICAgICAgICAgLi4uY29udHJvbGxlZFdpZHRocyxcclxuICAgICAgICAgICAgLi4udW5jb250cm9sbGVkV2lkdGhzXHJcbiAgICAgICAgXSk7XHJcbiAgICAgICAgbGV0IHBlcmNlbnRLZXlzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIGxldCBmcktleXNUb1RoZVJpZ2h0ID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIGxldCBtaW5XaWR0aHMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgLy8gZnJlZXplIGNvbHVtbnMgdG8gdGhlIGxlZnQgdG8gdGhlaXIgcHJldmlvdXMgcGl4ZWwgdmFsdWVcclxuICAgICAgICBjb2xsZWN0aW9uLmNvbHVtbnMuZm9yRWFjaCgoY29sdW1uLCBpKT0+e1xyXG4gICAgICAgICAgICB2YXIgX2NvbHVtbl9wcm9wc193aWR0aF9lbmRzV2l0aCwgX2NvbHVtbl9wcm9wc193aWR0aDtcclxuICAgICAgICAgICAgbGV0IGZyS2V5O1xyXG4gICAgICAgICAgICBsZXQgZnJWYWx1ZTtcclxuICAgICAgICAgICAgbWluV2lkdGhzLnNldChjb2x1bW4ua2V5LCB0aGlzLmdldERlZmF1bHRNaW5XaWR0aChjb2xsZWN0aW9uLmNvbHVtbnNbaV0pKTtcclxuICAgICAgICAgICAgaWYgKGNvbCAhPT0gY29sdW1uLmtleSAmJiAhY29sdW1uLnByb3BzLndpZHRoICYmICEoMCwgJDY4MThiMWM0ZmM2NzAyOGQkZXhwb3J0JDE5OTRhMDc3Yjk4ZWUwZDUpKHVuY29udHJvbGxlZFdpZHRocy5nZXQoY29sdW1uLmtleSkpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB1bmNvbnRyb2xsZWQgZG9uJ3QgaGF2ZSBwcm9wcy53aWR0aCBmb3IgdXMsIHNvIGluc3RlYWQgZ2V0IGZyb20gb3VyIHN0YXRlXHJcbiAgICAgICAgICAgICAgICBmcktleSA9IGNvbHVtbi5rZXk7XHJcbiAgICAgICAgICAgICAgICBmclZhbHVlID0gKDAsICQ2ODE4YjFjNGZjNjcwMjhkJGV4cG9ydCQ5MDc4YmFkNGMzOTM0NjA0KSh1bmNvbnRyb2xsZWRXaWR0aHMuZ2V0KGNvbHVtbi5rZXkpKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChjb2wgIT09IGNvbHVtbi5rZXkgJiYgISgwLCAkNjgxOGIxYzRmYzY3MDI4ZCRleHBvcnQkMTk5NGEwNzdiOThlZTBkNSkoY29sdW1uLnByb3BzLndpZHRoKSAmJiAhdW5jb250cm9sbGVkV2lkdGhzLmdldChjb2x1bW4ua2V5KSkge1xyXG4gICAgICAgICAgICAgICAgLy8gY29udHJvbGxlZFdpZHRocyB3aWxsIGJlIHRoZSBzYW1lIGluIHRoZSBjb2xsZWN0aW9uXHJcbiAgICAgICAgICAgICAgICBmcktleSA9IGNvbHVtbi5rZXk7XHJcbiAgICAgICAgICAgICAgICBmclZhbHVlID0gKDAsICQ2ODE4YjFjNGZjNjcwMjhkJGV4cG9ydCQ5MDc4YmFkNGMzOTM0NjA0KShjb2x1bW4ucHJvcHMud2lkdGgpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvbCAhPT0gY29sdW1uLmtleSAmJiAoKF9jb2x1bW5fcHJvcHNfd2lkdGggPSBjb2x1bW4ucHJvcHMud2lkdGgpID09PSBudWxsIHx8IF9jb2x1bW5fcHJvcHNfd2lkdGggPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfY29sdW1uX3Byb3BzX3dpZHRoX2VuZHNXaXRoID0gX2NvbHVtbl9wcm9wc193aWR0aC5lbmRzV2l0aCkgPT09IG51bGwgfHwgX2NvbHVtbl9wcm9wc193aWR0aF9lbmRzV2l0aCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2NvbHVtbl9wcm9wc193aWR0aF9lbmRzV2l0aC5jYWxsKF9jb2x1bW5fcHJvcHNfd2lkdGgsIFwiJVwiKSkpIHBlcmNlbnRLZXlzLnNldChjb2x1bW4ua2V5LCBjb2x1bW4ucHJvcHMud2lkdGgpO1xyXG4gICAgICAgICAgICAvLyBkb24ndCBmcmVlemUgY29sdW1ucyB0byB0aGUgcmlnaHQgb2YgdGhlIHJlc2l6aW5nIG9uZVxyXG4gICAgICAgICAgICBpZiAocmVzaXplSW5kZXggPCBpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZnJLZXkpIGZyS2V5c1RvVGhlUmlnaHQuc2V0KGZyS2V5LCBmclZhbHVlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyB3ZSBhbHJlYWR5IGtub3cgdGhlIG5ldyBzaXplIG9mIHRoZSByZXNpemluZyBjb2x1bW5cclxuICAgICAgICAgICAgaWYgKGNvbHVtbi5rZXkgPT09IGNvbCkge1xyXG4gICAgICAgICAgICAgICAgcmVzaXplSW5kZXggPSBpO1xyXG4gICAgICAgICAgICAgICAgcmVzaXppbmdDaGFuZ2VkLnNldChjb2x1bW4ua2V5LCBNYXRoLmZsb29yKHdpZHRoKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gZnJlZXplIGNvbHVtbiB0byBwcmV2aW91cyB2YWx1ZVxyXG4gICAgICAgICAgICByZXNpemluZ0NoYW5nZWQuc2V0KGNvbHVtbi5rZXksIHByZXZDb2x1bW5XaWR0aHMuZ2V0KGNvbHVtbi5rZXkpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBwcmVkaWN0IHBpeGVscyBzaXplcyBmb3IgYWxsIGNvbHVtbnMgYmFzZWQgb24gcmVzaXplXHJcbiAgICAgICAgbGV0IGNvbHVtbldpZHRocyA9ICgwLCAkNjgxOGIxYzRmYzY3MDI4ZCRleHBvcnQkNTVkNTBkYzY4NzM4NTQ5MSkodGFibGVXaWR0aCwgY29sbGVjdGlvbi5jb2x1bW5zLm1hcCgoY29sKT0+KHtcclxuICAgICAgICAgICAgICAgIC4uLmNvbC5wcm9wcyxcclxuICAgICAgICAgICAgICAgIGtleTogY29sLmtleVxyXG4gICAgICAgICAgICB9KSksIHJlc2l6aW5nQ2hhbmdlZCwgKGkpPT50aGlzLmdldERlZmF1bHRXaWR0aChjb2xsZWN0aW9uLmNvbHVtbnNbaV0pLCAoaSk9PnRoaXMuZ2V0RGVmYXVsdE1pbldpZHRoKGNvbGxlY3Rpb24uY29sdW1uc1tpXSkpO1xyXG4gICAgICAgIC8vIHNldCBhbGwgbmV3IGNvbHVtbiB3aWR0aHMgZm9yIG9uUmVzaXplIGV2ZW50XHJcbiAgICAgICAgLy8gY29sdW1ucyBnb2luZyBpbiB3aWxsIGJlIHRoZSBzYW1lIG9yZGVyIGFzIHRoZSBjb2x1bW5zIGNvbWluZyBvdXRcclxuICAgICAgICBsZXQgbmV3V2lkdGhzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIC8vIHNldCBhbGwgY29sdW1uIHdpZHRocyBiYXNlZCBvbiBjYWxjdWxhdGVDb2x1bW5TaXplXHJcbiAgICAgICAgY29sdW1uV2lkdGhzLmZvckVhY2goKHdpZHRoLCBpbmRleCk9PntcclxuICAgICAgICAgICAgbGV0IGtleSA9IGNvbGxlY3Rpb24uY29sdW1uc1tpbmRleF0ua2V5O1xyXG4gICAgICAgICAgICBuZXdXaWR0aHMuc2V0KGtleSwgd2lkdGgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIGFkZCBGUidzIGJhY2sgYXMgdGhleSB3ZXJlIHRvIGNvbHVtbnMgdG8gdGhlIHJpZ2h0XHJcbiAgICAgICAgQXJyYXkuZnJvbShmcktleXNUb1RoZVJpZ2h0KS5mb3JFYWNoKChba2V5XSk9PntcclxuICAgICAgICAgICAgbmV3V2lkdGhzLnNldChrZXksIGAke2ZyS2V5c1RvVGhlUmlnaHQuZ2V0KGtleSl9ZnJgKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBwdXQgYmFjayBpbiBwZXJjZW50c1xyXG4gICAgICAgIEFycmF5LmZyb20ocGVyY2VudEtleXMpLmZvckVhY2goKFtrZXksIHdpZHRoXSk9PntcclxuICAgICAgICAgICAgLy8gcmVzaXppbmcgbG9ja3MgYSBjb2x1bW4gdG8gYSBweCB3aWR0aFxyXG4gICAgICAgICAgICBpZiAoa2V5ID09PSBjb2wpIHJldHVybjtcclxuICAgICAgICAgICAgbmV3V2lkdGhzLnNldChrZXksIHdpZHRoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbmV3V2lkdGhzO1xyXG4gICAgfVxyXG4gICAgYnVpbGRDb2x1bW5XaWR0aHModGFibGVXaWR0aCwgY29sbGVjdGlvbiwgd2lkdGhzKSB7XHJcbiAgICAgICAgdGhpcy5jb2x1bW5XaWR0aHMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5jb2x1bW5NaW5XaWR0aHMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5jb2x1bW5NYXhXaWR0aHMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgLy8gaW5pdGlhbCBsYXlvdXQgb3IgdGFibGUvd2luZG93IHJlc2l6aW5nXHJcbiAgICAgICAgbGV0IGNvbHVtbldpZHRocyA9ICgwLCAkNjgxOGIxYzRmYzY3MDI4ZCRleHBvcnQkNTVkNTBkYzY4NzM4NTQ5MSkodGFibGVXaWR0aCwgY29sbGVjdGlvbi5jb2x1bW5zLm1hcCgoY29sKT0+KHtcclxuICAgICAgICAgICAgICAgIC4uLmNvbC5wcm9wcyxcclxuICAgICAgICAgICAgICAgIGtleTogY29sLmtleVxyXG4gICAgICAgICAgICB9KSksIHdpZHRocywgKGkpPT50aGlzLmdldERlZmF1bHRXaWR0aChjb2xsZWN0aW9uLmNvbHVtbnNbaV0pLCAoaSk9PnRoaXMuZ2V0RGVmYXVsdE1pbldpZHRoKGNvbGxlY3Rpb24uY29sdW1uc1tpXSkpO1xyXG4gICAgICAgIC8vIGNvbHVtbnMgZ29pbmcgaW4gd2lsbCBiZSB0aGUgc2FtZSBvcmRlciBhcyB0aGUgY29sdW1ucyBjb21pbmcgb3V0XHJcbiAgICAgICAgY29sdW1uV2lkdGhzLmZvckVhY2goKHdpZHRoLCBpbmRleCk9PntcclxuICAgICAgICAgICAgbGV0IGtleSA9IGNvbGxlY3Rpb24uY29sdW1uc1tpbmRleF0ua2V5O1xyXG4gICAgICAgICAgICBsZXQgY29sdW1uID0gY29sbGVjdGlvbi5jb2x1bW5zW2luZGV4XTtcclxuICAgICAgICAgICAgdGhpcy5jb2x1bW5XaWR0aHMuc2V0KGtleSwgd2lkdGgpO1xyXG4gICAgICAgICAgICB2YXIgX2NvbHVtbl9wcm9wc19taW5XaWR0aDtcclxuICAgICAgICAgICAgdGhpcy5jb2x1bW5NaW5XaWR0aHMuc2V0KGtleSwgKDAsICQ2ODE4YjFjNGZjNjcwMjhkJGV4cG9ydCRmNTU2MDU0Y2U0MzU4NzAxKSgoX2NvbHVtbl9wcm9wc19taW5XaWR0aCA9IGNvbHVtbi5wcm9wcy5taW5XaWR0aCkgIT09IG51bGwgJiYgX2NvbHVtbl9wcm9wc19taW5XaWR0aCAhPT0gdm9pZCAwID8gX2NvbHVtbl9wcm9wc19taW5XaWR0aCA6IHRoaXMuZ2V0RGVmYXVsdE1pbldpZHRoKGNvbHVtbiksIHRhYmxlV2lkdGgpKTtcclxuICAgICAgICAgICAgdGhpcy5jb2x1bW5NYXhXaWR0aHMuc2V0KGtleSwgKDAsICQ2ODE4YjFjNGZjNjcwMjhkJGV4cG9ydCQ1OTE4NWM2MmE3NTQ0YWEwKShjb2x1bW4ucHJvcHMubWF4V2lkdGgsIHRhYmxlV2lkdGgpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5XaWR0aHM7XHJcbiAgICB9XHJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKXtcclxuICAgICAgICB0aGlzLmNvbHVtbldpZHRocyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLmNvbHVtbk1pbldpZHRocyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLmNvbHVtbk1heFdpZHRocyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB2YXIgX29wdGlvbnNfZ2V0RGVmYXVsdFdpZHRoO1xyXG4gICAgICAgIHRoaXMuZ2V0RGVmYXVsdFdpZHRoID0gKF9vcHRpb25zX2dldERlZmF1bHRXaWR0aCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5nZXREZWZhdWx0V2lkdGgpICE9PSBudWxsICYmIF9vcHRpb25zX2dldERlZmF1bHRXaWR0aCAhPT0gdm9pZCAwID8gX29wdGlvbnNfZ2V0RGVmYXVsdFdpZHRoIDogKCk9PlwiMWZyXCI7XHJcbiAgICAgICAgdmFyIF9vcHRpb25zX2dldERlZmF1bHRNaW5XaWR0aDtcclxuICAgICAgICB0aGlzLmdldERlZmF1bHRNaW5XaWR0aCA9IChfb3B0aW9uc19nZXREZWZhdWx0TWluV2lkdGggPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZ2V0RGVmYXVsdE1pbldpZHRoKSAhPT0gbnVsbCAmJiBfb3B0aW9uc19nZXREZWZhdWx0TWluV2lkdGggIT09IHZvaWQgMCA/IF9vcHRpb25zX2dldERlZmF1bHRNaW5XaWR0aCA6ICgpPT43NTtcclxuICAgIH1cclxufVxyXG5cclxuXHJcblxyXG5mdW5jdGlvbiAkMjkyYmM0ZTA5Y2QwZWI2MiRleHBvcnQkY2I4OTVkY2Y4NWRiMTMxOShwcm9wcywgc3RhdGUpIHtcclxuICAgIGxldCB7IGdldERlZmF1bHRXaWR0aDogZ2V0RGVmYXVsdFdpZHRoLCBnZXREZWZhdWx0TWluV2lkdGg6IGdldERlZmF1bHRNaW5XaWR0aCwgdGFibGVXaWR0aDogdGFibGVXaWR0aCA9IDAgfSA9IHByb3BzO1xyXG4gICAgbGV0IFtyZXNpemluZ0NvbHVtbiwgc2V0UmVzaXppbmdDb2x1bW5dID0gKDAsICQxQmZqVyR1c2VTdGF0ZSkobnVsbCk7XHJcbiAgICBsZXQgY29sdW1uTGF5b3V0ID0gKDAsICQxQmZqVyR1c2VNZW1vKSgoKT0+bmV3ICgwLCAkYTllN2FlNTQ0YTRlNDFkZCRleHBvcnQkN2ZmNzdhMTYyOTcwYjMwZSkoe1xyXG4gICAgICAgICAgICBnZXREZWZhdWx0V2lkdGg6IGdldERlZmF1bHRXaWR0aCxcclxuICAgICAgICAgICAgZ2V0RGVmYXVsdE1pbldpZHRoOiBnZXREZWZhdWx0TWluV2lkdGhcclxuICAgICAgICB9KSwgW1xyXG4gICAgICAgIGdldERlZmF1bHRXaWR0aCxcclxuICAgICAgICBnZXREZWZhdWx0TWluV2lkdGhcclxuICAgIF0pO1xyXG4gICAgbGV0IFtjb250cm9sbGVkQ29sdW1ucywgdW5jb250cm9sbGVkQ29sdW1uc10gPSAoMCwgJDFCZmpXJHVzZU1lbW8pKCgpPT5jb2x1bW5MYXlvdXQuc3BsaXRDb2x1bW5zSW50b0NvbnRyb2xsZWRBbmRVbmNvbnRyb2xsZWQoc3RhdGUuY29sbGVjdGlvbi5jb2x1bW5zKSwgW1xyXG4gICAgICAgIHN0YXRlLmNvbGxlY3Rpb24uY29sdW1ucyxcclxuICAgICAgICBjb2x1bW5MYXlvdXRcclxuICAgIF0pO1xyXG4gICAgLy8gdW5jb250cm9sbGVkIGNvbHVtbiB3aWR0aHNcclxuICAgIGxldCBbdW5jb250cm9sbGVkV2lkdGhzLCBzZXRVbmNvbnRyb2xsZWRXaWR0aHNdID0gKDAsICQxQmZqVyR1c2VTdGF0ZSkoKCk9PmNvbHVtbkxheW91dC5nZXRJbml0aWFsVW5jb250cm9sbGVkV2lkdGhzKHVuY29udHJvbGxlZENvbHVtbnMpKTtcclxuICAgIC8vIFVwZGF0ZSB1bmNvbnRyb2xsZWQgd2lkdGhzIGlmIHRoZSBjb2x1bW5zIGNoYW5nZWQuXHJcbiAgICBsZXQgW2xhc3RDb2x1bW5zLCBzZXRMYXN0Q29sdW1uc10gPSAoMCwgJDFCZmpXJHVzZVN0YXRlKShzdGF0ZS5jb2xsZWN0aW9uLmNvbHVtbnMpO1xyXG4gICAgaWYgKHN0YXRlLmNvbGxlY3Rpb24uY29sdW1ucyAhPT0gbGFzdENvbHVtbnMpIHtcclxuICAgICAgICBpZiAoc3RhdGUuY29sbGVjdGlvbi5jb2x1bW5zLmxlbmd0aCAhPT0gbGFzdENvbHVtbnMubGVuZ3RoIHx8IHN0YXRlLmNvbGxlY3Rpb24uY29sdW1ucy5zb21lKChjLCBpKT0+Yy5rZXkgIT09IGxhc3RDb2x1bW5zW2ldLmtleSkpIHtcclxuICAgICAgICAgICAgbGV0IG5ld1VuY29udHJvbGxlZFdpZHRocyA9IGNvbHVtbkxheW91dC5nZXRJbml0aWFsVW5jb250cm9sbGVkV2lkdGhzKHVuY29udHJvbGxlZENvbHVtbnMpO1xyXG4gICAgICAgICAgICBzZXRVbmNvbnRyb2xsZWRXaWR0aHMobmV3VW5jb250cm9sbGVkV2lkdGhzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0TGFzdENvbHVtbnMoc3RhdGUuY29sbGVjdGlvbi5jb2x1bW5zKTtcclxuICAgIH1cclxuICAgIC8vIGNvbWJpbmUgY29sdW1ucyBiYWNrIGludG8gb25lIG1hcCB0aGF0IG1haW50YWlucyBzYW1lIG9yZGVyIGFzIHRoZSBjb2x1bW5zXHJcbiAgICBsZXQgY29sV2lkdGhzID0gKDAsICQxQmZqVyR1c2VNZW1vKSgoKT0+Y29sdW1uTGF5b3V0LnJlY29tYmluZUNvbHVtbnMoc3RhdGUuY29sbGVjdGlvbi5jb2x1bW5zLCB1bmNvbnRyb2xsZWRXaWR0aHMsIHVuY29udHJvbGxlZENvbHVtbnMsIGNvbnRyb2xsZWRDb2x1bW5zKSwgW1xyXG4gICAgICAgIHN0YXRlLmNvbGxlY3Rpb24uY29sdW1ucyxcclxuICAgICAgICB1bmNvbnRyb2xsZWRXaWR0aHMsXHJcbiAgICAgICAgdW5jb250cm9sbGVkQ29sdW1ucyxcclxuICAgICAgICBjb250cm9sbGVkQ29sdW1ucyxcclxuICAgICAgICBjb2x1bW5MYXlvdXRcclxuICAgIF0pO1xyXG4gICAgbGV0IHN0YXJ0UmVzaXplID0gKDAsICQxQmZqVyR1c2VDYWxsYmFjaykoKGtleSk9PntcclxuICAgICAgICBzZXRSZXNpemluZ0NvbHVtbihrZXkpO1xyXG4gICAgfSwgW1xyXG4gICAgICAgIHNldFJlc2l6aW5nQ29sdW1uXHJcbiAgICBdKTtcclxuICAgIGxldCB1cGRhdGVSZXNpemVkQ29sdW1ucyA9ICgwLCAkMUJmalckdXNlQ2FsbGJhY2spKChrZXksIHdpZHRoKT0+e1xyXG4gICAgICAgIGxldCBuZXdDb250cm9sbGVkID0gbmV3IE1hcChBcnJheS5mcm9tKGNvbnRyb2xsZWRDb2x1bW5zKS5tYXAoKFtrZXksIGVudHJ5XSk9PltcclxuICAgICAgICAgICAgICAgIGtleSxcclxuICAgICAgICAgICAgICAgIGVudHJ5LnByb3BzLndpZHRoXHJcbiAgICAgICAgICAgIF0pKTtcclxuICAgICAgICBsZXQgbmV3U2l6ZXMgPSBjb2x1bW5MYXlvdXQucmVzaXplQ29sdW1uV2lkdGgodGFibGVXaWR0aCwgc3RhdGUuY29sbGVjdGlvbiwgbmV3Q29udHJvbGxlZCwgdW5jb250cm9sbGVkV2lkdGhzLCBrZXksIHdpZHRoKTtcclxuICAgICAgICBsZXQgbWFwID0gbmV3IE1hcChBcnJheS5mcm9tKHVuY29udHJvbGxlZENvbHVtbnMpLm1hcCgoW2tleV0pPT5bXHJcbiAgICAgICAgICAgICAgICBrZXksXHJcbiAgICAgICAgICAgICAgICBuZXdTaXplcy5nZXQoa2V5KVxyXG4gICAgICAgICAgICBdKSk7XHJcbiAgICAgICAgbWFwLnNldChrZXksIHdpZHRoKTtcclxuICAgICAgICBzZXRVbmNvbnRyb2xsZWRXaWR0aHMobWFwKTtcclxuICAgICAgICByZXR1cm4gbmV3U2l6ZXM7XHJcbiAgICB9LCBbXHJcbiAgICAgICAgY29udHJvbGxlZENvbHVtbnMsXHJcbiAgICAgICAgdW5jb250cm9sbGVkQ29sdW1ucyxcclxuICAgICAgICBzZXRVbmNvbnRyb2xsZWRXaWR0aHMsXHJcbiAgICAgICAgdGFibGVXaWR0aCxcclxuICAgICAgICBjb2x1bW5MYXlvdXQsXHJcbiAgICAgICAgc3RhdGUuY29sbGVjdGlvbixcclxuICAgICAgICB1bmNvbnRyb2xsZWRXaWR0aHNcclxuICAgIF0pO1xyXG4gICAgbGV0IGVuZFJlc2l6ZSA9ICgwLCAkMUJmalckdXNlQ2FsbGJhY2spKCgpPT57XHJcbiAgICAgICAgc2V0UmVzaXppbmdDb2x1bW4obnVsbCk7XHJcbiAgICB9LCBbXHJcbiAgICAgICAgc2V0UmVzaXppbmdDb2x1bW5cclxuICAgIF0pO1xyXG4gICAgKDAsICQxQmZqVyR1c2VNZW1vKSgoKT0+Y29sdW1uTGF5b3V0LmJ1aWxkQ29sdW1uV2lkdGhzKHRhYmxlV2lkdGgsIHN0YXRlLmNvbGxlY3Rpb24sIGNvbFdpZHRocyksIFtcclxuICAgICAgICB0YWJsZVdpZHRoLFxyXG4gICAgICAgIHN0YXRlLmNvbGxlY3Rpb24sXHJcbiAgICAgICAgY29sV2lkdGhzLFxyXG4gICAgICAgIGNvbHVtbkxheW91dFxyXG4gICAgXSk7XHJcbiAgICByZXR1cm4gKDAsICQxQmZqVyR1c2VNZW1vKSgoKT0+KHtcclxuICAgICAgICAgICAgcmVzaXppbmdDb2x1bW46IHJlc2l6aW5nQ29sdW1uLFxyXG4gICAgICAgICAgICB1cGRhdGVSZXNpemVkQ29sdW1uczogdXBkYXRlUmVzaXplZENvbHVtbnMsXHJcbiAgICAgICAgICAgIHN0YXJ0UmVzaXplOiBzdGFydFJlc2l6ZSxcclxuICAgICAgICAgICAgZW5kUmVzaXplOiBlbmRSZXNpemUsXHJcbiAgICAgICAgICAgIGdldENvbHVtbldpZHRoOiAoa2V5KT0+Y29sdW1uTGF5b3V0LmdldENvbHVtbldpZHRoKGtleSksXHJcbiAgICAgICAgICAgIGdldENvbHVtbk1pbldpZHRoOiAoa2V5KT0+Y29sdW1uTGF5b3V0LmdldENvbHVtbk1pbldpZHRoKGtleSksXHJcbiAgICAgICAgICAgIGdldENvbHVtbk1heFdpZHRoOiAoa2V5KT0+Y29sdW1uTGF5b3V0LmdldENvbHVtbk1heFdpZHRoKGtleSksXHJcbiAgICAgICAgICAgIHRhYmxlU3RhdGU6IHN0YXRlXHJcbiAgICAgICAgfSksIFtcclxuICAgICAgICBjb2x1bW5MYXlvdXQsXHJcbiAgICAgICAgcmVzaXppbmdDb2x1bW4sXHJcbiAgICAgICAgdXBkYXRlUmVzaXplZENvbHVtbnMsXHJcbiAgICAgICAgc3RhcnRSZXNpemUsXHJcbiAgICAgICAgZW5kUmVzaXplLFxyXG4gICAgICAgIHN0YXRlXHJcbiAgICBdKTtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XHJcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXHJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xyXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcclxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovIFxyXG5cclxuLypcclxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcclxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXHJcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxyXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi8gXHJcblxyXG5jb25zdCAkNzg4NzgxYmFhMzAxMTdmYSR2YXIkUk9XX0hFQURFUl9DT0xVTU5fS0VZID0gXCJyb3ctaGVhZGVyLWNvbHVtbi1cIiArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpO1xyXG5sZXQgJDc4ODc4MWJhYTMwMTE3ZmEkdmFyJFJPV19IRUFERVJfQ09MVU1OX0tFWV9EUkFHID0gXCJyb3ctaGVhZGVyLWNvbHVtbi1cIiArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpO1xyXG53aGlsZSgkNzg4NzgxYmFhMzAxMTdmYSR2YXIkUk9XX0hFQURFUl9DT0xVTU5fS0VZID09PSAkNzg4NzgxYmFhMzAxMTdmYSR2YXIkUk9XX0hFQURFUl9DT0xVTU5fS0VZX0RSQUcpJDc4ODc4MWJhYTMwMTE3ZmEkdmFyJFJPV19IRUFERVJfQ09MVU1OX0tFWV9EUkFHID0gXCJyb3ctaGVhZGVyLWNvbHVtbi1cIiArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpO1xyXG5mdW5jdGlvbiAkNzg4NzgxYmFhMzAxMTdmYSRleHBvcnQkN2MxMjdkYjg1MGQ0ZTgxZShrZXlNYXAsIGNvbHVtbk5vZGVzKSB7XHJcbiAgICBpZiAoY29sdW1uTm9kZXMubGVuZ3RoID09PSAwKSByZXR1cm4gW107XHJcbiAgICBsZXQgY29sdW1ucyA9IFtdO1xyXG4gICAgbGV0IHNlZW4gPSBuZXcgTWFwKCk7XHJcbiAgICBmb3IgKGxldCBjb2x1bW4gb2YgY29sdW1uTm9kZXMpe1xyXG4gICAgICAgIGxldCBwYXJlbnRLZXkgPSBjb2x1bW4ucGFyZW50S2V5O1xyXG4gICAgICAgIGxldCBjb2wgPSBbXHJcbiAgICAgICAgICAgIGNvbHVtblxyXG4gICAgICAgIF07XHJcbiAgICAgICAgd2hpbGUocGFyZW50S2V5KXtcclxuICAgICAgICAgICAgbGV0IHBhcmVudCA9IGtleU1hcC5nZXQocGFyZW50S2V5KTtcclxuICAgICAgICAgICAgaWYgKCFwYXJlbnQpIGJyZWFrO1xyXG4gICAgICAgICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IHNlZW4gdGhpcyBwYXJlbnQsIHRoYW4gaXQgaXMgc2hhcmVkXHJcbiAgICAgICAgICAgIC8vIHdpdGggYSBwcmV2aW91cyBjb2x1bW4uIElmIHRoZSBjdXJyZW50IGNvbHVtbiBpcyB0YWxsZXJcclxuICAgICAgICAgICAgLy8gdGhhbiB0aGUgcHJldmlvdXMgY29sdW1uLCB0aGFuIHdlIG5lZWQgdG8gc2hpZnQgdGhlIHBhcmVudFxyXG4gICAgICAgICAgICAvLyBpbiB0aGUgcHJldmlvdXMgY29sdW1uIHNvIGl0J3MgbGV2ZWwgd2l0aCB0aGUgY3VycmVudCBjb2x1bW4uXHJcbiAgICAgICAgICAgIGlmIChzZWVuLmhhcyhwYXJlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnQuY29sc3BhbisrO1xyXG4gICAgICAgICAgICAgICAgbGV0IHsgY29sdW1uOiBjb2x1bW4sIGluZGV4OiBpbmRleCB9ID0gc2Vlbi5nZXQocGFyZW50KTtcclxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA+IGNvbC5sZW5ndGgpIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZm9yKGxldCBpID0gaW5kZXg7IGkgPCBjb2wubGVuZ3RoOyBpKyspY29sdW1uLnNwbGljZShpLCAwLCBudWxsKTtcclxuICAgICAgICAgICAgICAgIC8vIEFkanVzdCBzaGlmdGVkIGluZGljZXNcclxuICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IGNvbC5sZW5ndGg7IGkgPCBjb2x1bW4ubGVuZ3RoOyBpKyspLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1kZXB0aFxyXG4gICAgICAgICAgICAgICAgaWYgKGNvbHVtbltpXSAmJiBzZWVuLmhhcyhjb2x1bW5baV0pKSBzZWVuLmdldChjb2x1bW5baV0pLmluZGV4ID0gaTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHBhcmVudC5jb2xzcGFuID0gMTtcclxuICAgICAgICAgICAgICAgIGNvbC5wdXNoKHBhcmVudCk7XHJcbiAgICAgICAgICAgICAgICBzZWVuLnNldChwYXJlbnQsIHtcclxuICAgICAgICAgICAgICAgICAgICBjb2x1bW46IGNvbCxcclxuICAgICAgICAgICAgICAgICAgICBpbmRleDogY29sLmxlbmd0aCAtIDFcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHBhcmVudEtleSA9IHBhcmVudC5wYXJlbnRLZXk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbHVtbnMucHVzaChjb2wpO1xyXG4gICAgICAgIGNvbHVtbi5pbmRleCA9IGNvbHVtbnMubGVuZ3RoIC0gMTtcclxuICAgIH1cclxuICAgIGxldCBtYXhMZW5ndGggPSBNYXRoLm1heCguLi5jb2x1bW5zLm1hcCgoYyk9PmMubGVuZ3RoKSk7XHJcbiAgICBsZXQgaGVhZGVyUm93cyA9IEFycmF5KG1heExlbmd0aCkuZmlsbCgwKS5tYXAoKCk9PltdKTtcclxuICAgIC8vIENvbnZlcnQgY29sdW1ucyBpbnRvIHJvd3MuXHJcbiAgICBsZXQgY29sSW5kZXggPSAwO1xyXG4gICAgZm9yIChsZXQgY29sdW1uIG9mIGNvbHVtbnMpe1xyXG4gICAgICAgIGxldCBpID0gbWF4TGVuZ3RoIC0gMTtcclxuICAgICAgICBmb3IgKGxldCBpdGVtIG9mIGNvbHVtbil7XHJcbiAgICAgICAgICAgIGlmIChpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBGaWxsIHRoZSBzcGFjZSB1cCB1bnRpbCB0aGUgY3VycmVudCBjb2x1bW4gd2l0aCBhIHBsYWNlaG9sZGVyXHJcbiAgICAgICAgICAgICAgICBsZXQgcm93ID0gaGVhZGVyUm93c1tpXTtcclxuICAgICAgICAgICAgICAgIGxldCByb3dMZW5ndGggPSByb3cucmVkdWNlKChwLCBjKT0+cCArIGMuY29sc3BhbiwgMCk7XHJcbiAgICAgICAgICAgICAgICBpZiAocm93TGVuZ3RoIDwgY29sSW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgcGxhY2Vob2xkZXIgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwicGxhY2Vob2xkZXJcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBcInBsYWNlaG9sZGVyLVwiICsgaXRlbS5rZXksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHNwYW46IGNvbEluZGV4IC0gcm93TGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogcm93TGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyZWQ6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldmVsOiBpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNDaGlsZE5vZGVzOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGROb2RlczogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRWYWx1ZTogbnVsbFxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1kZXB0aFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyb3cubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByb3dbcm93Lmxlbmd0aCAtIDFdLm5leHRLZXkgPSBwbGFjZWhvbGRlci5rZXk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyLnByZXZLZXkgPSByb3dbcm93Lmxlbmd0aCAtIDFdLmtleTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcm93LnB1c2gocGxhY2Vob2xkZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHJvdy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcm93W3Jvdy5sZW5ndGggLSAxXS5uZXh0S2V5ID0gaXRlbS5rZXk7XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5wcmV2S2V5ID0gcm93W3Jvdy5sZW5ndGggLSAxXS5rZXk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpdGVtLmxldmVsID0gaTtcclxuICAgICAgICAgICAgICAgIGl0ZW0uY29sSW5kZXggPSBjb2xJbmRleDtcclxuICAgICAgICAgICAgICAgIHJvdy5wdXNoKGl0ZW0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGktLTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29sSW5kZXgrKztcclxuICAgIH1cclxuICAgIC8vIEFkZCBwbGFjZWhvbGRlcnMgYXQgdGhlIGVuZCBvZiBlYWNoIHJvdyB0aGF0IGlzIHNob3J0ZXIgdGhhbiB0aGUgbWF4aW11bVxyXG4gICAgbGV0IGkgPSAwO1xyXG4gICAgZm9yIChsZXQgcm93IG9mIGhlYWRlclJvd3Mpe1xyXG4gICAgICAgIGxldCByb3dMZW5ndGggPSByb3cucmVkdWNlKChwLCBjKT0+cCArIGMuY29sc3BhbiwgMCk7XHJcbiAgICAgICAgaWYgKHJvd0xlbmd0aCA8IGNvbHVtbk5vZGVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBsZXQgcGxhY2Vob2xkZXIgPSB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcInBsYWNlaG9sZGVyXCIsXHJcbiAgICAgICAgICAgICAgICBrZXk6IFwicGxhY2Vob2xkZXItXCIgKyByb3dbcm93Lmxlbmd0aCAtIDFdLmtleSxcclxuICAgICAgICAgICAgICAgIGNvbHNwYW46IGNvbHVtbk5vZGVzLmxlbmd0aCAtIHJvd0xlbmd0aCxcclxuICAgICAgICAgICAgICAgIGluZGV4OiByb3dMZW5ndGgsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbCxcclxuICAgICAgICAgICAgICAgIHJlbmRlcmVkOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgbGV2ZWw6IGksXHJcbiAgICAgICAgICAgICAgICBoYXNDaGlsZE5vZGVzOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGNoaWxkTm9kZXM6IFtdLFxyXG4gICAgICAgICAgICAgICAgdGV4dFZhbHVlOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgcHJldktleTogcm93W3Jvdy5sZW5ndGggLSAxXS5rZXlcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcm93LnB1c2gocGxhY2Vob2xkZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpKys7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaGVhZGVyUm93cy5tYXAoKGNoaWxkTm9kZXMsIGluZGV4KT0+e1xyXG4gICAgICAgIGxldCByb3cgPSB7XHJcbiAgICAgICAgICAgIHR5cGU6IFwiaGVhZGVycm93XCIsXHJcbiAgICAgICAgICAgIGtleTogXCJoZWFkZXJyb3ctXCIgKyBpbmRleCxcclxuICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxyXG4gICAgICAgICAgICB2YWx1ZTogbnVsbCxcclxuICAgICAgICAgICAgcmVuZGVyZWQ6IG51bGwsXHJcbiAgICAgICAgICAgIGxldmVsOiAwLFxyXG4gICAgICAgICAgICBoYXNDaGlsZE5vZGVzOiB0cnVlLFxyXG4gICAgICAgICAgICBjaGlsZE5vZGVzOiBjaGlsZE5vZGVzLFxyXG4gICAgICAgICAgICB0ZXh0VmFsdWU6IG51bGxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiByb3c7XHJcbiAgICB9KTtcclxufVxyXG5jbGFzcyAkNzg4NzgxYmFhMzAxMTdmYSRleHBvcnQkNTk2ZTFiMmUyY2Y5MzY5MCBleHRlbmRzICgwLCAkMUJmalckR3JpZENvbGxlY3Rpb24pIHtcclxuICAgICpbU3ltYm9sLml0ZXJhdG9yXSgpIHtcclxuICAgICAgICB5aWVsZCogdGhpcy5ib2R5LmNoaWxkTm9kZXM7XHJcbiAgICB9XHJcbiAgICBnZXQgc2l6ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZTtcclxuICAgIH1cclxuICAgIGdldEtleXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5TWFwLmtleXMoKTtcclxuICAgIH1cclxuICAgIGdldEtleUJlZm9yZShrZXkpIHtcclxuICAgICAgICBsZXQgbm9kZSA9IHRoaXMua2V5TWFwLmdldChrZXkpO1xyXG4gICAgICAgIHJldHVybiBub2RlID8gbm9kZS5wcmV2S2V5IDogbnVsbDtcclxuICAgIH1cclxuICAgIGdldEtleUFmdGVyKGtleSkge1xyXG4gICAgICAgIGxldCBub2RlID0gdGhpcy5rZXlNYXAuZ2V0KGtleSk7XHJcbiAgICAgICAgcmV0dXJuIG5vZGUgPyBub2RlLm5leHRLZXkgOiBudWxsO1xyXG4gICAgfVxyXG4gICAgZ2V0Rmlyc3RLZXkoKSB7XHJcbiAgICAgICAgdmFyIF9nZXRGaXJzdEl0ZW07XHJcbiAgICAgICAgcmV0dXJuIChfZ2V0Rmlyc3RJdGVtID0gKDAsICQxQmZqVyRnZXRGaXJzdEl0ZW0pKHRoaXMuYm9keS5jaGlsZE5vZGVzKSkgPT09IG51bGwgfHwgX2dldEZpcnN0SXRlbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2dldEZpcnN0SXRlbS5rZXk7XHJcbiAgICB9XHJcbiAgICBnZXRMYXN0S2V5KCkge1xyXG4gICAgICAgIHZhciBfZ2V0TGFzdEl0ZW07XHJcbiAgICAgICAgcmV0dXJuIChfZ2V0TGFzdEl0ZW0gPSAoMCwgJDFCZmpXJGdldExhc3RJdGVtKSh0aGlzLmJvZHkuY2hpbGROb2RlcykpID09PSBudWxsIHx8IF9nZXRMYXN0SXRlbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2dldExhc3RJdGVtLmtleTtcclxuICAgIH1cclxuICAgIGdldEl0ZW0oa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5TWFwLmdldChrZXkpO1xyXG4gICAgfVxyXG4gICAgYXQoaWR4KSB7XHJcbiAgICAgICAgY29uc3Qga2V5cyA9IFtcclxuICAgICAgICAgICAgLi4udGhpcy5nZXRLZXlzKClcclxuICAgICAgICBdO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldEl0ZW0oa2V5c1tpZHhdKTtcclxuICAgIH1cclxuICAgIGdldFRleHRWYWx1ZShrZXkpIHtcclxuICAgICAgICBsZXQgcm93ID0gdGhpcy5nZXRJdGVtKGtleSk7XHJcbiAgICAgICAgaWYgKCFyb3cpIHJldHVybiBcIlwiO1xyXG4gICAgICAgIC8vIElmIHRoZSByb3cgaGFzIGEgdGV4dFZhbHVlLCB1c2UgdGhhdC5cclxuICAgICAgICBpZiAocm93LnRleHRWYWx1ZSkgcmV0dXJuIHJvdy50ZXh0VmFsdWU7XHJcbiAgICAgICAgLy8gT3RoZXJ3aXNlIGNvbWJpbmUgdGhlIHRleHQgb2YgZWFjaCBvZiB0aGUgcm93IGhlYWRlciBjb2x1bW5zLlxyXG4gICAgICAgIGxldCByb3dIZWFkZXJDb2x1bW5LZXlzID0gdGhpcy5yb3dIZWFkZXJDb2x1bW5LZXlzO1xyXG4gICAgICAgIGlmIChyb3dIZWFkZXJDb2x1bW5LZXlzKSB7XHJcbiAgICAgICAgICAgIGxldCB0ZXh0ID0gW107XHJcbiAgICAgICAgICAgIGZvciAobGV0IGNlbGwgb2Ygcm93LmNoaWxkTm9kZXMpe1xyXG4gICAgICAgICAgICAgICAgbGV0IGNvbHVtbiA9IHRoaXMuY29sdW1uc1tjZWxsLmluZGV4XTtcclxuICAgICAgICAgICAgICAgIGlmIChyb3dIZWFkZXJDb2x1bW5LZXlzLmhhcyhjb2x1bW4ua2V5KSAmJiBjZWxsLnRleHRWYWx1ZSkgdGV4dC5wdXNoKGNlbGwudGV4dFZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA9PT0gcm93SGVhZGVyQ29sdW1uS2V5cy5zaXplKSBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGV4dC5qb2luKFwiIFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFwiXCI7XHJcbiAgICB9XHJcbiAgICBjb25zdHJ1Y3Rvcihub2RlcywgcHJldiwgb3B0cyl7XHJcbiAgICAgICAgbGV0IHJvd0hlYWRlckNvbHVtbktleXMgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgbGV0IGJvZHk7XHJcbiAgICAgICAgbGV0IGNvbHVtbnMgPSBbXTtcclxuICAgICAgICAvLyBBZGQgY2VsbCBmb3Igc2VsZWN0aW9uIGNoZWNrYm94ZXMgaWYgbmVlZGVkLlxyXG4gICAgICAgIGlmIChvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMuc2hvd1NlbGVjdGlvbkNoZWNrYm94ZXMpIHtcclxuICAgICAgICAgICAgbGV0IHJvd0hlYWRlckNvbHVtbiA9IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwiY29sdW1uXCIsXHJcbiAgICAgICAgICAgICAgICBrZXk6ICQ3ODg3ODFiYWEzMDExN2ZhJHZhciRST1dfSEVBREVSX0NPTFVNTl9LRVksXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbCxcclxuICAgICAgICAgICAgICAgIHRleHRWYWx1ZTogXCJcIixcclxuICAgICAgICAgICAgICAgIGxldmVsOiAwLFxyXG4gICAgICAgICAgICAgICAgaW5kZXg6IChvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMuc2hvd0RyYWdCdXR0b25zKSA/IDEgOiAwLFxyXG4gICAgICAgICAgICAgICAgaGFzQ2hpbGROb2RlczogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICByZW5kZXJlZDogbnVsbCxcclxuICAgICAgICAgICAgICAgIGNoaWxkTm9kZXM6IFtdLFxyXG4gICAgICAgICAgICAgICAgcHJvcHM6IHtcclxuICAgICAgICAgICAgICAgICAgICBpc1NlbGVjdGlvbkNlbGw6IHRydWVcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29sdW1ucy51bnNoaWZ0KHJvd0hlYWRlckNvbHVtbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEFkZCBjZWxsIGZvciBkcmFnIGJ1dHRvbnMgaWYgbmVlZGVkLlxyXG4gICAgICAgIGlmIChvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMuc2hvd0RyYWdCdXR0b25zKSB7XHJcbiAgICAgICAgICAgIGxldCByb3dIZWFkZXJDb2x1bW4gPSB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcImNvbHVtblwiLFxyXG4gICAgICAgICAgICAgICAga2V5OiAkNzg4NzgxYmFhMzAxMTdmYSR2YXIkUk9XX0hFQURFUl9DT0xVTU5fS0VZX0RSQUcsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbCxcclxuICAgICAgICAgICAgICAgIHRleHRWYWx1ZTogXCJcIixcclxuICAgICAgICAgICAgICAgIGxldmVsOiAwLFxyXG4gICAgICAgICAgICAgICAgaW5kZXg6IDAsXHJcbiAgICAgICAgICAgICAgICBoYXNDaGlsZE5vZGVzOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHJlbmRlcmVkOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgY2hpbGROb2RlczogW10sXHJcbiAgICAgICAgICAgICAgICBwcm9wczoge1xyXG4gICAgICAgICAgICAgICAgICAgIGlzRHJhZ0J1dHRvbkNlbGw6IHRydWVcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29sdW1ucy51bnNoaWZ0KHJvd0hlYWRlckNvbHVtbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCByb3dzID0gW107XHJcbiAgICAgICAgbGV0IGNvbHVtbktleU1hcCA9IG5ldyBNYXAoKTtcclxuICAgICAgICBsZXQgdmlzaXQgPSAobm9kZSk9PntcclxuICAgICAgICAgICAgc3dpdGNoKG5vZGUudHlwZSl7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiYm9keVwiOlxyXG4gICAgICAgICAgICAgICAgICAgIGJvZHkgPSBub2RlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcImNvbHVtblwiOlxyXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbktleU1hcC5zZXQobm9kZS5rZXksIG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9kZS5oYXNDaGlsZE5vZGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbnMucHVzaChub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUucHJvcHMuaXNSb3dIZWFkZXIpIHJvd0hlYWRlckNvbHVtbktleXMuYWRkKG5vZGUua2V5KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiaXRlbVwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHJvd3MucHVzaChub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIGRvIG5vdCBnbyBpbnRvIGNoaWxkTm9kZXNcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiBub2RlLmNoaWxkTm9kZXMpdmlzaXQoY2hpbGQpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgZm9yIChsZXQgbm9kZSBvZiBub2Rlcyl2aXNpdChub2RlKTtcclxuICAgICAgICBsZXQgaGVhZGVyUm93cyA9ICQ3ODg3ODFiYWEzMDExN2ZhJGV4cG9ydCQ3YzEyN2RiODUwZDRlODFlKGNvbHVtbktleU1hcCwgY29sdW1ucyk7XHJcbiAgICAgICAgaGVhZGVyUm93cy5mb3JFYWNoKChyb3csIGkpPT5yb3dzLnNwbGljZShpLCAwLCByb3cpKTtcclxuICAgICAgICBzdXBlcih7XHJcbiAgICAgICAgICAgIGNvbHVtbkNvdW50OiBjb2x1bW5zLmxlbmd0aCxcclxuICAgICAgICAgICAgaXRlbXM6IHJvd3MsXHJcbiAgICAgICAgICAgIHZpc2l0Tm9kZTogKG5vZGUpPT57XHJcbiAgICAgICAgICAgICAgICBub2RlLmNvbHVtbiA9IGNvbHVtbnNbbm9kZS5pbmRleF07XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX3NpemUgPSAwO1xyXG4gICAgICAgIHRoaXMuY29sdW1ucyA9IGNvbHVtbnM7XHJcbiAgICAgICAgdGhpcy5yb3dIZWFkZXJDb2x1bW5LZXlzID0gcm93SGVhZGVyQ29sdW1uS2V5cztcclxuICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xyXG4gICAgICAgIHRoaXMuaGVhZGVyUm93cyA9IGhlYWRlclJvd3M7XHJcbiAgICAgICAgdGhpcy5fc2l6ZSA9IFtcclxuICAgICAgICAgICAgLi4uYm9keS5jaGlsZE5vZGVzXHJcbiAgICAgICAgXS5sZW5ndGg7XHJcbiAgICAgICAgLy8gRGVmYXVsdCByb3cgaGVhZGVyIGNvbHVtbiB0byB0aGUgZmlyc3Qgb25lLlxyXG4gICAgICAgIGlmICh0aGlzLnJvd0hlYWRlckNvbHVtbktleXMuc2l6ZSA9PT0gMCkge1xyXG4gICAgICAgICAgICBpZiAob3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLnNob3dTZWxlY3Rpb25DaGVja2JveGVzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLnNob3dEcmFnQnV0dG9ucykgdGhpcy5yb3dIZWFkZXJDb2x1bW5LZXlzLmFkZCh0aGlzLmNvbHVtbnNbMl0ua2V5KTtcclxuICAgICAgICAgICAgICAgIGVsc2UgdGhpcy5yb3dIZWFkZXJDb2x1bW5LZXlzLmFkZCh0aGlzLmNvbHVtbnNbMV0ua2V5KTtcclxuICAgICAgICAgICAgfSBlbHNlIHRoaXMucm93SGVhZGVyQ29sdW1uS2V5cy5hZGQodGhpcy5jb2x1bW5zWzBdLmtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5cclxuXHJcbmNvbnN0ICQ0YTBkZDAzNmQ0OTJjZWU0JHZhciRPUFBPU0lURV9TT1JUX0RJUkVDVElPTiA9IHtcclxuICAgIGFzY2VuZGluZzogXCJkZXNjZW5kaW5nXCIsXHJcbiAgICBkZXNjZW5kaW5nOiBcImFzY2VuZGluZ1wiXHJcbn07XHJcbmZ1bmN0aW9uICQ0YTBkZDAzNmQ0OTJjZWU0JGV4cG9ydCQ5MDdiY2M2YzQ4MzI1ZmQ2KHByb3BzKSB7XHJcbiAgICBsZXQgW2lzS2V5Ym9hcmROYXZpZ2F0aW9uRGlzYWJsZWQsIHNldEtleWJvYXJkTmF2aWdhdGlvbkRpc2FibGVkXSA9ICgwLCAkMUJmalckdXNlU3RhdGUpKGZhbHNlKTtcclxuICAgIGxldCB7IHNlbGVjdGlvbk1vZGU6IHNlbGVjdGlvbk1vZGUgPSBcIm5vbmVcIiwgc2hvd1NlbGVjdGlvbkNoZWNrYm94ZXM6IHNob3dTZWxlY3Rpb25DaGVja2JveGVzLCBzaG93RHJhZ0J1dHRvbnM6IHNob3dEcmFnQnV0dG9ucyB9ID0gcHJvcHM7XHJcbiAgICBsZXQgY29udGV4dCA9ICgwLCAkMUJmalckdXNlTWVtbykoKCk9Pih7XHJcbiAgICAgICAgICAgIHNob3dTZWxlY3Rpb25DaGVja2JveGVzOiBzaG93U2VsZWN0aW9uQ2hlY2tib3hlcyAmJiBzZWxlY3Rpb25Nb2RlICE9PSBcIm5vbmVcIixcclxuICAgICAgICAgICAgc2hvd0RyYWdCdXR0b25zOiBzaG93RHJhZ0J1dHRvbnMsXHJcbiAgICAgICAgICAgIHNlbGVjdGlvbk1vZGU6IHNlbGVjdGlvbk1vZGUsXHJcbiAgICAgICAgICAgIGNvbHVtbnM6IFtdXHJcbiAgICAgICAgfSksIFtcclxuICAgICAgICBwcm9wcy5jaGlsZHJlbixcclxuICAgICAgICBzaG93U2VsZWN0aW9uQ2hlY2tib3hlcyxcclxuICAgICAgICBzZWxlY3Rpb25Nb2RlLFxyXG4gICAgICAgIHNob3dEcmFnQnV0dG9uc1xyXG4gICAgXSk7XHJcbiAgICBsZXQgY29sbGVjdGlvbiA9ICgwLCAkMUJmalckdXNlQ29sbGVjdGlvbikocHJvcHMsICgwLCAkMUJmalckdXNlQ2FsbGJhY2spKChub2Rlcyk9Pm5ldyAoMCwgJDc4ODc4MWJhYTMwMTE3ZmEkZXhwb3J0JDU5NmUxYjJlMmNmOTM2OTApKG5vZGVzLCBudWxsLCBjb250ZXh0KSwgW1xyXG4gICAgICAgIGNvbnRleHRcclxuICAgIF0pLCBjb250ZXh0KTtcclxuICAgIGxldCB7IGRpc2FibGVkS2V5czogZGlzYWJsZWRLZXlzLCBzZWxlY3Rpb25NYW5hZ2VyOiBzZWxlY3Rpb25NYW5hZ2VyIH0gPSAoMCwgJDFCZmpXJHVzZUdyaWRTdGF0ZSkoe1xyXG4gICAgICAgIC4uLnByb3BzLFxyXG4gICAgICAgIGNvbGxlY3Rpb246IGNvbGxlY3Rpb24sXHJcbiAgICAgICAgZGlzYWJsZWRCZWhhdmlvcjogcHJvcHMuZGlzYWJsZWRCZWhhdmlvciB8fCBcInNlbGVjdGlvblwiXHJcbiAgICB9KTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgY29sbGVjdGlvbjogY29sbGVjdGlvbixcclxuICAgICAgICBkaXNhYmxlZEtleXM6IGRpc2FibGVkS2V5cyxcclxuICAgICAgICBzZWxlY3Rpb25NYW5hZ2VyOiBzZWxlY3Rpb25NYW5hZ2VyLFxyXG4gICAgICAgIHNob3dTZWxlY3Rpb25DaGVja2JveGVzOiBwcm9wcy5zaG93U2VsZWN0aW9uQ2hlY2tib3hlcyB8fCBmYWxzZSxcclxuICAgICAgICBzb3J0RGVzY3JpcHRvcjogcHJvcHMuc29ydERlc2NyaXB0b3IsXHJcbiAgICAgICAgaXNLZXlib2FyZE5hdmlnYXRpb25EaXNhYmxlZDogY29sbGVjdGlvbi5zaXplID09PSAwIHx8IGlzS2V5Ym9hcmROYXZpZ2F0aW9uRGlzYWJsZWQsXHJcbiAgICAgICAgc2V0S2V5Ym9hcmROYXZpZ2F0aW9uRGlzYWJsZWQ6IHNldEtleWJvYXJkTmF2aWdhdGlvbkRpc2FibGVkLFxyXG4gICAgICAgIHNvcnQgKGNvbHVtbktleSwgZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHZhciBfcHJvcHNfc29ydERlc2NyaXB0b3I7XHJcbiAgICAgICAgICAgIHByb3BzLm9uU29ydENoYW5nZSh7XHJcbiAgICAgICAgICAgICAgICBjb2x1bW46IGNvbHVtbktleSxcclxuICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uICE9PSBudWxsICYmIGRpcmVjdGlvbiAhPT0gdm9pZCAwID8gZGlyZWN0aW9uIDogKChfcHJvcHNfc29ydERlc2NyaXB0b3IgPSBwcm9wcy5zb3J0RGVzY3JpcHRvcikgPT09IG51bGwgfHwgX3Byb3BzX3NvcnREZXNjcmlwdG9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcHJvcHNfc29ydERlc2NyaXB0b3IuY29sdW1uKSA9PT0gY29sdW1uS2V5ID8gJDRhMGRkMDM2ZDQ5MmNlZTQkdmFyJE9QUE9TSVRFX1NPUlRfRElSRUNUSU9OW3Byb3BzLnNvcnREZXNjcmlwdG9yLmRpcmVjdGlvbl0gOiBcImFzY2VuZGluZ1wiXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxyXG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcclxuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXHJcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqLyBcclxuZnVuY3Rpb24gJDMxMmFlM2I1NmE5NGE4NmUkdmFyJFRhYmxlSGVhZGVyKHByb3BzKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG4kMzEyYWUzYjU2YTk0YTg2ZSR2YXIkVGFibGVIZWFkZXIuZ2V0Q29sbGVjdGlvbk5vZGUgPSBmdW5jdGlvbiogZ2V0Q29sbGVjdGlvbk5vZGUocHJvcHMsIGNvbnRleHQpIHtcclxuICAgIGxldCB7IGNoaWxkcmVuOiBjaGlsZHJlbiwgY29sdW1uczogY29sdW1ucyB9ID0gcHJvcHM7XHJcbiAgICAvLyBDbGVhciBjb2x1bW5zIHNvIHRoZXkgYXJlbid0IGRvdWJsZSBhZGRlZCBpbiBzdHJpY3QgbW9kZS5cclxuICAgIGNvbnRleHQuY29sdW1ucyA9IFtdO1xyXG4gICAgaWYgKHR5cGVvZiBjaGlsZHJlbiA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgaWYgKCFjb2x1bW5zKSB0aHJvdyBuZXcgRXJyb3IoXCJwcm9wcy5jaGlsZHJlbiB3YXMgYSBmdW5jdGlvbiBidXQgcHJvcHMuY29sdW1ucyBpcyBtaXNzaW5nXCIpO1xyXG4gICAgICAgIGZvciAobGV0IGNvbHVtbiBvZiBjb2x1bW5zKXlpZWxkIHtcclxuICAgICAgICAgICAgdHlwZTogXCJjb2x1bW5cIixcclxuICAgICAgICAgICAgdmFsdWU6IGNvbHVtbixcclxuICAgICAgICAgICAgcmVuZGVyZXI6IGNoaWxkcmVuXHJcbiAgICAgICAgfTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbGV0IGNvbHVtbnMgPSBbXTtcclxuICAgICAgICAoMCwgJDFCZmpXJHJlYWN0KS5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCAoY29sdW1uKT0+e1xyXG4gICAgICAgICAgICBjb2x1bW5zLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJjb2x1bW5cIixcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGNvbHVtblxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB5aWVsZCogY29sdW1ucztcclxuICAgIH1cclxufTtcclxuLyoqXHJcbiAqIEEgVGFibGVIZWFkZXIgaXMgYSBjb250YWluZXIgZm9yIHRoZSBDb2x1bW4gZWxlbWVudHMgaW4gYSBUYWJsZS4gQ29sdW1ucyBjYW4gYmUgc3RhdGljYWxseSBkZWZpbmVkXHJcbiAqIGFzIGNoaWxkcmVuLCBvciBnZW5lcmF0ZWQgZHluYW1pY2FsbHkgdXNpbmcgYSBmdW5jdGlvbiBiYXNlZCBvbiB0aGUgZGF0YSBwYXNzZWQgdG8gdGhlIGBjb2x1bW5zYCBwcm9wLlxyXG4gKi8gLy8gV2UgZG9uJ3Qgd2FudCBnZXRDb2xsZWN0aW9uTm9kZSB0byBzaG93IHVwIGluIHRoZSB0eXBlIGRlZmluaXRpb25cclxubGV0ICQzMTJhZTNiNTZhOTRhODZlJGV4cG9ydCRmODUwODk1YjI4N2VmMjhlID0gJDMxMmFlM2I1NmE5NGE4NmUkdmFyJFRhYmxlSGVhZGVyO1xyXG5cclxuXHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XHJcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXHJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xyXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcclxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovIFxyXG5mdW5jdGlvbiAkNGFlNTMxNGJmNTBkYjFhMyR2YXIkVGFibGVCb2R5KHByb3BzKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG4kNGFlNTMxNGJmNTBkYjFhMyR2YXIkVGFibGVCb2R5LmdldENvbGxlY3Rpb25Ob2RlID0gZnVuY3Rpb24qIGdldENvbGxlY3Rpb25Ob2RlKHByb3BzKSB7XHJcbiAgICBsZXQgeyBjaGlsZHJlbjogY2hpbGRyZW4sIGl0ZW1zOiBpdGVtcyB9ID0gcHJvcHM7XHJcbiAgICB5aWVsZCB7XHJcbiAgICAgICAgdHlwZTogXCJib2R5XCIsXHJcbiAgICAgICAgaGFzQ2hpbGROb2RlczogdHJ1ZSxcclxuICAgICAgICBwcm9wczogcHJvcHMsXHJcbiAgICAgICAgKmNoaWxkTm9kZXMgKCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNoaWxkcmVuID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgIGlmICghaXRlbXMpIHRocm93IG5ldyBFcnJvcihcInByb3BzLmNoaWxkcmVuIHdhcyBhIGZ1bmN0aW9uIGJ1dCBwcm9wcy5pdGVtcyBpcyBtaXNzaW5nXCIpO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaXRlbSBvZiBpdGVtcyl5aWVsZCB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJpdGVtXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGl0ZW0sXHJcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZXI6IGNoaWxkcmVuXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbGV0IGl0ZW1zID0gW107XHJcbiAgICAgICAgICAgICAgICAoMCwgJDFCZmpXJHJlYWN0KS5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCAoaXRlbSk9PntcclxuICAgICAgICAgICAgICAgICAgICBpdGVtcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJpdGVtXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGl0ZW1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgeWllbGQqIGl0ZW1zO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufTtcclxuLyoqXHJcbiAqIEEgVGFibGVCb2R5IGlzIGEgY29udGFpbmVyIGZvciB0aGUgUm93IGVsZW1lbnRzIG9mIGEgVGFibGUuIFJvd3MgY2FuIGJlIHN0YXRpY2FsbHkgZGVmaW5lZFxyXG4gKiBhcyBjaGlsZHJlbiwgb3IgZ2VuZXJhdGVkIGR5bmFtaWNhbGx5IHVzaW5nIGEgZnVuY3Rpb24gYmFzZWQgb24gdGhlIGRhdGEgcGFzc2VkIHRvIHRoZSBgaXRlbXNgIHByb3AuXHJcbiAqLyAvLyBXZSBkb24ndCB3YW50IGdldENvbGxlY3Rpb25Ob2RlIHRvIHNob3cgdXAgaW4gdGhlIHR5cGUgZGVmaW5pdGlvblxyXG5sZXQgJDRhZTUzMTRiZjUwZGIxYTMkZXhwb3J0JDc2Y2NkMjEwYjkwMjk5MTcgPSAkNGFlNTMxNGJmNTBkYjFhMyR2YXIkVGFibGVCb2R5O1xyXG5cclxuXHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XHJcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXHJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xyXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcclxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovIFxyXG5mdW5jdGlvbiAkMWNkMjQ0NTU3YzJmOTdkNSR2YXIkQ29sdW1uKHByb3BzKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG4kMWNkMjQ0NTU3YzJmOTdkNSR2YXIkQ29sdW1uLmdldENvbGxlY3Rpb25Ob2RlID0gZnVuY3Rpb24qIGdldENvbGxlY3Rpb25Ob2RlKHByb3BzLCBjb250ZXh0KSB7XHJcbiAgICBsZXQgeyB0aXRsZTogdGl0bGUsIGNoaWxkcmVuOiBjaGlsZHJlbiwgY2hpbGRDb2x1bW5zOiBjaGlsZENvbHVtbnMgfSA9IHByb3BzO1xyXG4gICAgbGV0IHJlbmRlcmVkID0gdGl0bGUgfHwgY2hpbGRyZW47XHJcbiAgICBsZXQgdGV4dFZhbHVlID0gcHJvcHMudGV4dFZhbHVlIHx8ICh0eXBlb2YgcmVuZGVyZWQgPT09IFwic3RyaW5nXCIgPyByZW5kZXJlZCA6IFwiXCIpIHx8IHByb3BzW1wiYXJpYS1sYWJlbFwiXTtcclxuICAgIGxldCBmdWxsTm9kZXMgPSB5aWVsZCB7XHJcbiAgICAgICAgdHlwZTogXCJjb2x1bW5cIixcclxuICAgICAgICBoYXNDaGlsZE5vZGVzOiAhIWNoaWxkQ29sdW1ucyB8fCB0aXRsZSAmJiAoMCwgJDFCZmpXJHJlYWN0KS5DaGlsZHJlbi5jb3VudChjaGlsZHJlbikgPiAwLFxyXG4gICAgICAgIHJlbmRlcmVkOiByZW5kZXJlZCxcclxuICAgICAgICB0ZXh0VmFsdWU6IHRleHRWYWx1ZSxcclxuICAgICAgICBwcm9wczogcHJvcHMsXHJcbiAgICAgICAgKmNoaWxkTm9kZXMgKCkge1xyXG4gICAgICAgICAgICBpZiAoY2hpbGRDb2x1bW5zKSBmb3IgKGxldCBjaGlsZCBvZiBjaGlsZENvbHVtbnMpeWllbGQge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJjb2x1bW5cIixcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBjaGlsZFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBlbHNlIGlmICh0aXRsZSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkQ29sdW1ucyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgKDAsICQxQmZqVyRyZWFjdCkuQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgKGNoaWxkKT0+e1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkQ29sdW1ucy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJjb2x1bW5cIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogY2hpbGRcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgeWllbGQqIGNoaWxkQ29sdW1ucztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2hvdWxkSW52YWxpZGF0ZSAobmV3Q29udGV4dCkge1xyXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgYml0IG9mIGEgaGFjaywgYnV0IGl0IHdvcmtzLlxyXG4gICAgICAgICAgICAvLyBJZiB0aGlzIG1ldGhvZCBpcyBjYWxsZWQsIHRoZW4gdGhlcmUncyBhIGNhY2hlZCB2ZXJzaW9uIG9mIHRoaXMgbm9kZSBhdmFpbGFibGUuXHJcbiAgICAgICAgICAgIC8vIEJ1dCwgd2UgbmVlZCB0byBrZWVwIHRoZSBsaXN0IG9mIGNvbHVtbnMgaW4gdGhlIG5ldyBjb250ZXh0IHVwIHRvIGRhdGUuXHJcbiAgICAgICAgICAgIHVwZGF0ZUNvbnRleHQobmV3Q29udGV4dCk7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgbGV0IHVwZGF0ZUNvbnRleHQgPSAoY29udGV4dCk9PntcclxuICAgICAgICAvLyByZWdpc3RlciBsZWFmIGNvbHVtbnMgb24gdGhlIGNvbnRleHQgc28gdGhhdCA8Um93PiBjYW4gYWNjZXNzIHRoZW1cclxuICAgICAgICBmb3IgKGxldCBub2RlIG9mIGZ1bGxOb2RlcylpZiAoIW5vZGUuaGFzQ2hpbGROb2RlcykgY29udGV4dC5jb2x1bW5zLnB1c2gobm9kZSk7XHJcbiAgICB9O1xyXG4gICAgdXBkYXRlQ29udGV4dChjb250ZXh0KTtcclxufTtcclxuLyoqXHJcbiAqIEEgQ29sdW1uIHJlcHJlc2VudHMgYSBmaWVsZCBvZiBlYWNoIGl0ZW0gd2l0aGluIGEgVGFibGUuIENvbHVtbnMgbWF5IGFsc28gY29udGFpbiBuZXN0ZWRcclxuICogQ29sdW1uIGVsZW1lbnRzIHRvIHJlcHJlc2VudCBjb2x1bW4gZ3JvdXBzLiBOZXN0ZWQgY29sdW1ucyBjYW4gYmUgc3RhdGljYWxseSBkZWZpbmVkIGFzXHJcbiAqIGNoaWxkcmVuLCBvciBkeW5hbWljYWxseSBnZW5lcmF0ZWQgdXNpbmcgYSBmdW5jdGlvbiBiYXNlZCBvbiB0aGUgYGNoaWxkQ29sdW1uc2AgcHJvcC5cclxuICovIC8vIFdlIGRvbid0IHdhbnQgZ2V0Q29sbGVjdGlvbk5vZGUgdG8gc2hvdyB1cCBpbiB0aGUgdHlwZSBkZWZpbml0aW9uXHJcbmxldCAkMWNkMjQ0NTU3YzJmOTdkNSRleHBvcnQkODE2YjVkODExMjk1ZTZiYyA9ICQxY2QyNDQ1NTdjMmY5N2Q1JHZhciRDb2x1bW47XHJcblxyXG5cclxuLypcclxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcclxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXHJcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxyXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi8gXHJcbmZ1bmN0aW9uICQ3MGQ3MGViMTZlYTQ4NDI4JHZhciRSb3cocHJvcHMpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcbiQ3MGQ3MGViMTZlYTQ4NDI4JHZhciRSb3cuZ2V0Q29sbGVjdGlvbk5vZGUgPSBmdW5jdGlvbiogZ2V0Q29sbGVjdGlvbk5vZGUocHJvcHMsIGNvbnRleHQpIHtcclxuICAgIGxldCB7IGNoaWxkcmVuOiBjaGlsZHJlbiwgdGV4dFZhbHVlOiB0ZXh0VmFsdWUsIFVOU1RBQkxFX2NoaWxkSXRlbXM6IFVOU1RBQkxFX2NoaWxkSXRlbXMgfSA9IHByb3BzO1xyXG4gICAgeWllbGQge1xyXG4gICAgICAgIHR5cGU6IFwiaXRlbVwiLFxyXG4gICAgICAgIHByb3BzOiBwcm9wcyxcclxuICAgICAgICB0ZXh0VmFsdWU6IHRleHRWYWx1ZSxcclxuICAgICAgICBcImFyaWEtbGFiZWxcIjogcHJvcHNbXCJhcmlhLWxhYmVsXCJdLFxyXG4gICAgICAgIGhhc0NoaWxkTm9kZXM6IHRydWUsXHJcbiAgICAgICAgKmNoaWxkTm9kZXMgKCkge1xyXG4gICAgICAgICAgICAvLyBQcm9jZXNzIGNlbGxzIGZpcnN0XHJcbiAgICAgICAgICAgIGlmIChjb250ZXh0LnNob3dEcmFnQnV0dG9ucykgeWllbGQge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJjZWxsXCIsXHJcbiAgICAgICAgICAgICAgICBrZXk6IFwiaGVhZGVyLWRyYWdcIixcclxuICAgICAgICAgICAgICAgIHByb3BzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNEcmFnQnV0dG9uQ2VsbDogdHJ1ZVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBpZiAoY29udGV4dC5zaG93U2VsZWN0aW9uQ2hlY2tib3hlcyAmJiBjb250ZXh0LnNlbGVjdGlvbk1vZGUgIT09IFwibm9uZVwiKSB5aWVsZCB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcImNlbGxcIixcclxuICAgICAgICAgICAgICAgIGtleTogXCJoZWFkZXJcIixcclxuICAgICAgICAgICAgICAgIHByb3BzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNTZWxlY3Rpb25DZWxsOiB0cnVlXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2hpbGRyZW4gPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgY29sdW1uIG9mIGNvbnRleHQuY29sdW1ucyl5aWVsZCB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJjZWxsXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogY2hpbGRyZW4oY29sdW1uLmtleSksXHJcbiAgICAgICAgICAgICAgICAgICAga2V5OiBjb2x1bW4ua2V5IC8vIHRoaXMgaXMgY29tYmluZWQgd2l0aCB0aGUgcm93IGtleSBieSBDb2xsZWN0aW9uQnVpbGRlclxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGlmIChVTlNUQUJMRV9jaGlsZEl0ZW1zKSBmb3IgKGxldCBjaGlsZCBvZiBVTlNUQUJMRV9jaGlsZEl0ZW1zKS8vIE5vdGU6IGluIG9yZGVyIHRvIHJldXNlIHRoZSByZW5kZXIgZnVuY3Rpb24gb2YgVGFibGVCb2R5IGZvciBvdXIgY2hpbGQgcm93cywgd2UganVzdCBuZWVkIHRvIHlpZWxkIGEgdHlwZSBhbmQgYSB2YWx1ZSBoZXJlLiBDb2xsZWN0aW9uQnVpbGRlciB3aWxsIHRoZW4gbG9vayB1cFxyXG4gICAgICAgICAgICAgICAgLy8gdGhlIHBhcmVudCByZW5kZXJlciBhbmQgdXNlIHRoYXQgdG8gYnVpbGQgdGhlIGZ1bGwgbm9kZSBvZiB0aGlzIGNoaWxkIHJvdywgdXNpbmcgdGhlIHZhbHVlIHByb3ZpZGVkIGhlcmUgdG8gZ2VuZXJhdGUgdGhlIGNlbGxzXHJcbiAgICAgICAgICAgICAgICB5aWVsZCB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJpdGVtXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNoaWxkXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbGV0IGNlbGxzID0gW107XHJcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGRSb3dzID0gW107XHJcbiAgICAgICAgICAgICAgICAoMCwgJDFCZmpXJHJlYWN0KS5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCAobm9kZSk9PntcclxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSAkNzBkNzBlYjE2ZWE0ODQyOCR2YXIkUm93KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjZWxscy5sZW5ndGggPCBjb250ZXh0LmNvbHVtbnMubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoXCJBbGwgb2YgYSBSb3cncyBjaGlsZCBDZWxscyBtdXN0IGJlIHBvc2l0aW9uZWQgYmVmb3JlIGFueSBjaGlsZCBSb3dzLlwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRSb3dzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJpdGVtXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiBub2RlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBjZWxscy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJjZWxsXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IG5vZGVcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNlbGxzLmxlbmd0aCAhPT0gY29udGV4dC5jb2x1bW5zLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKGBDZWxsIGNvdW50IG11c3QgbWF0Y2ggY29sdW1uIGNvdW50LiBGb3VuZCAke2NlbGxzLmxlbmd0aH0gY2VsbHMgYW5kICR7Y29udGV4dC5jb2x1bW5zLmxlbmd0aH0gY29sdW1ucy5gKTtcclxuICAgICAgICAgICAgICAgIHlpZWxkKiBjZWxscztcclxuICAgICAgICAgICAgICAgIHlpZWxkKiBjaGlsZFJvd3M7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHNob3VsZEludmFsaWRhdGUgKG5ld0NvbnRleHQpIHtcclxuICAgICAgICAgICAgLy8gSW52YWxpZGF0ZSBhbGwgcm93cyBpZiB0aGUgY29sdW1ucyBjaGFuZ2VkLlxyXG4gICAgICAgICAgICByZXR1cm4gbmV3Q29udGV4dC5jb2x1bW5zLmxlbmd0aCAhPT0gY29udGV4dC5jb2x1bW5zLmxlbmd0aCB8fCBuZXdDb250ZXh0LmNvbHVtbnMuc29tZSgoYywgaSk9PmMua2V5ICE9PSBjb250ZXh0LmNvbHVtbnNbaV0ua2V5KSB8fCBuZXdDb250ZXh0LnNob3dTZWxlY3Rpb25DaGVja2JveGVzICE9PSBjb250ZXh0LnNob3dTZWxlY3Rpb25DaGVja2JveGVzIHx8IG5ld0NvbnRleHQuc2hvd0RyYWdCdXR0b25zICE9PSBjb250ZXh0LnNob3dEcmFnQnV0dG9ucyB8fCBuZXdDb250ZXh0LnNlbGVjdGlvbk1vZGUgIT09IGNvbnRleHQuc2VsZWN0aW9uTW9kZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59O1xyXG4vKipcclxuICogQSBSb3cgcmVwcmVzZW50cyBhIHNpbmdsZSBpdGVtIGluIGEgVGFibGUgYW5kIGNvbnRhaW5zIENlbGwgZWxlbWVudHMgZm9yIGVhY2ggY29sdW1uLlxyXG4gKiBDZWxscyBjYW4gYmUgc3RhdGljYWxseSBkZWZpbmVkIGFzIGNoaWxkcmVuLCBvciBnZW5lcmF0ZWQgZHluYW1pY2FsbHkgdXNpbmcgYSBmdW5jdGlvblxyXG4gKiBiYXNlZCBvbiB0aGUgY29sdW1ucyBkZWZpbmVkIGluIHRoZSBUYWJsZUhlYWRlci5cclxuICovIC8vIFdlIGRvbid0IHdhbnQgZ2V0Q29sbGVjdGlvbk5vZGUgdG8gc2hvdyB1cCBpbiB0aGUgdHlwZSBkZWZpbml0aW9uXHJcbmxldCAkNzBkNzBlYjE2ZWE0ODQyOCRleHBvcnQkYjU5YmRiZWY5Y2U3MGRlMiA9ICQ3MGQ3MGViMTZlYTQ4NDI4JHZhciRSb3c7XHJcblxyXG5cclxuLypcclxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcclxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXHJcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxyXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi8gZnVuY3Rpb24gJDk0MWQxZDlhNmEyODk4MmEkdmFyJENlbGwocHJvcHMpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcbiQ5NDFkMWQ5YTZhMjg5ODJhJHZhciRDZWxsLmdldENvbGxlY3Rpb25Ob2RlID0gZnVuY3Rpb24qIGdldENvbGxlY3Rpb25Ob2RlKHByb3BzKSB7XHJcbiAgICBsZXQgeyBjaGlsZHJlbjogY2hpbGRyZW4gfSA9IHByb3BzO1xyXG4gICAgbGV0IHRleHRWYWx1ZSA9IHByb3BzLnRleHRWYWx1ZSB8fCAodHlwZW9mIGNoaWxkcmVuID09PSBcInN0cmluZ1wiID8gY2hpbGRyZW4gOiBcIlwiKSB8fCBwcm9wc1tcImFyaWEtbGFiZWxcIl0gfHwgXCJcIjtcclxuICAgIHlpZWxkIHtcclxuICAgICAgICB0eXBlOiBcImNlbGxcIixcclxuICAgICAgICBwcm9wczogcHJvcHMsXHJcbiAgICAgICAgcmVuZGVyZWQ6IGNoaWxkcmVuLFxyXG4gICAgICAgIHRleHRWYWx1ZTogdGV4dFZhbHVlLFxyXG4gICAgICAgIFwiYXJpYS1sYWJlbFwiOiBwcm9wc1tcImFyaWEtbGFiZWxcIl0sXHJcbiAgICAgICAgaGFzQ2hpbGROb2RlczogZmFsc2VcclxuICAgIH07XHJcbn07XHJcbi8qKlxyXG4gKiBBIENlbGwgcmVwcmVzZW50cyB0aGUgdmFsdWUgb2YgYSBzaW5nbGUgQ29sdW1uIHdpdGhpbiBhIFRhYmxlIFJvdy5cclxuICovIC8vIFdlIGRvbid0IHdhbnQgZ2V0Q29sbGVjdGlvbk5vZGUgdG8gc2hvdyB1cCBpbiB0aGUgdHlwZSBkZWZpbml0aW9uXHJcbmxldCAkOTQxZDFkOWE2YTI4OTgyYSRleHBvcnQkZjZmMGMzZmU0ZWMzMDZlYSA9ICQ5NDFkMWQ5YTZhMjg5ODJhJHZhciRDZWxsO1xyXG5cclxuXHJcblxyXG5cclxuXHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDIzIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XHJcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXHJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xyXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcclxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovIFxyXG5cclxuXHJcblxyXG5cclxuXHJcbmZ1bmN0aW9uICRlZTY1YTAwNTdmZDk5NTMxJGV4cG9ydCQzNGRmYThhMTYyMjE4NWE0KHByb3BzKSB7XHJcbiAgICBsZXQgeyBzZWxlY3Rpb25Nb2RlOiBzZWxlY3Rpb25Nb2RlID0gXCJub25lXCIsIHNob3dTZWxlY3Rpb25DaGVja2JveGVzOiBzaG93U2VsZWN0aW9uQ2hlY2tib3hlcywgc2hvd0RyYWdCdXR0b25zOiBzaG93RHJhZ0J1dHRvbnMsIFVOU1RBQkxFX2V4cGFuZGVkS2V5czogcHJvcEV4cGFuZGVkS2V5cywgVU5TVEFCTEVfZGVmYXVsdEV4cGFuZGVkS2V5czogcHJvcERlZmF1bHRFeHBhbmRlZEtleXMsIFVOU1RBQkxFX29uRXhwYW5kZWRDaGFuZ2U6IFVOU1RBQkxFX29uRXhwYW5kZWRDaGFuZ2UsIGNoaWxkcmVuOiBjaGlsZHJlbiB9ID0gcHJvcHM7XHJcbiAgICBpZiAoISgwLCAkMUJmalckdGFibGVOZXN0ZWRSb3dzKSgpKSB0aHJvdyBuZXcgRXJyb3IoXCJGZWF0dXJlIGZsYWcgZm9yIHRhYmxlIG5lc3RlZCByb3dzIG11c3QgYmUgZW5hYmxlZCB0byB1c2UgdXNlVHJlZUdyaWRTdGF0ZS5cIik7XHJcbiAgICBsZXQgW2V4cGFuZGVkS2V5cywgc2V0RXhwYW5kZWRLZXlzXSA9ICgwLCAkMUJmalckdXNlQ29udHJvbGxlZFN0YXRlKShwcm9wRXhwYW5kZWRLZXlzID8gJGVlNjVhMDA1N2ZkOTk1MzEkdmFyJGNvbnZlcnRFeHBhbmRlZChwcm9wRXhwYW5kZWRLZXlzKSA6IHVuZGVmaW5lZCwgcHJvcERlZmF1bHRFeHBhbmRlZEtleXMgPyAkZWU2NWEwMDU3ZmQ5OTUzMSR2YXIkY29udmVydEV4cGFuZGVkKHByb3BEZWZhdWx0RXhwYW5kZWRLZXlzKSA6IG5ldyBTZXQoKSwgVU5TVEFCTEVfb25FeHBhbmRlZENoYW5nZSk7XHJcbiAgICBsZXQgY29udGV4dCA9ICgwLCAkMUJmalckdXNlTWVtbykoKCk9Pih7XHJcbiAgICAgICAgICAgIHNob3dTZWxlY3Rpb25DaGVja2JveGVzOiBzaG93U2VsZWN0aW9uQ2hlY2tib3hlcyAmJiBzZWxlY3Rpb25Nb2RlICE9PSBcIm5vbmVcIixcclxuICAgICAgICAgICAgc2hvd0RyYWdCdXR0b25zOiBzaG93RHJhZ0J1dHRvbnMsXHJcbiAgICAgICAgICAgIHNlbGVjdGlvbk1vZGU6IHNlbGVjdGlvbk1vZGUsXHJcbiAgICAgICAgICAgIGNvbHVtbnM6IFtdXHJcbiAgICAgICAgfSksIFtcclxuICAgICAgICBjaGlsZHJlbixcclxuICAgICAgICBzaG93U2VsZWN0aW9uQ2hlY2tib3hlcyxcclxuICAgICAgICBzZWxlY3Rpb25Nb2RlLFxyXG4gICAgICAgIHNob3dEcmFnQnV0dG9uc1xyXG4gICAgXSk7XHJcbiAgICBsZXQgYnVpbGRlciA9ICgwLCAkMUJmalckdXNlTWVtbykoKCk9Pm5ldyAoMCwgJDFCZmpXJENvbGxlY3Rpb25CdWlsZGVyKSgpLCBbXSk7XHJcbiAgICBsZXQgbm9kZXMgPSAoMCwgJDFCZmpXJHVzZU1lbW8pKCgpPT5idWlsZGVyLmJ1aWxkKHtcclxuICAgICAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuXHJcbiAgICAgICAgfSwgY29udGV4dCksIFtcclxuICAgICAgICBidWlsZGVyLFxyXG4gICAgICAgIGNoaWxkcmVuLFxyXG4gICAgICAgIGNvbnRleHRcclxuICAgIF0pO1xyXG4gICAgbGV0IHRyZWVHcmlkQ29sbGVjdGlvbiA9ICgwLCAkMUJmalckdXNlTWVtbykoKCk9PntcclxuICAgICAgICByZXR1cm4gJGVlNjVhMDA1N2ZkOTk1MzEkdmFyJGdlbmVyYXRlVHJlZUdyaWRDb2xsZWN0aW9uKG5vZGVzLCB7XHJcbiAgICAgICAgICAgIHNob3dTZWxlY3Rpb25DaGVja2JveGVzOiBzaG93U2VsZWN0aW9uQ2hlY2tib3hlcyxcclxuICAgICAgICAgICAgc2hvd0RyYWdCdXR0b25zOiBzaG93RHJhZ0J1dHRvbnMsXHJcbiAgICAgICAgICAgIGV4cGFuZGVkS2V5czogZXhwYW5kZWRLZXlzXHJcbiAgICAgICAgfSk7XHJcbiAgICB9LCBbXHJcbiAgICAgICAgbm9kZXMsXHJcbiAgICAgICAgc2hvd1NlbGVjdGlvbkNoZWNrYm94ZXMsXHJcbiAgICAgICAgc2hvd0RyYWdCdXR0b25zLFxyXG4gICAgICAgIGV4cGFuZGVkS2V5c1xyXG4gICAgXSk7XHJcbiAgICBsZXQgb25Ub2dnbGUgPSAoa2V5KT0+e1xyXG4gICAgICAgIHNldEV4cGFuZGVkS2V5cygkZWU2NWEwMDU3ZmQ5OTUzMSR2YXIkdG9nZ2xlS2V5KGV4cGFuZGVkS2V5cywga2V5LCB0cmVlR3JpZENvbGxlY3Rpb24pKTtcclxuICAgIH07XHJcbiAgICBsZXQgY29sbGVjdGlvbiA9ICgwLCAkMUJmalckdXNlTWVtbykoKCk9PntcclxuICAgICAgICByZXR1cm4gbmV3ICgwLCAkNzg4NzgxYmFhMzAxMTdmYSRleHBvcnQkNTk2ZTFiMmUyY2Y5MzY5MCkodHJlZUdyaWRDb2xsZWN0aW9uLnRhYmxlTm9kZXMsIG51bGwsIGNvbnRleHQpO1xyXG4gICAgfSwgW1xyXG4gICAgICAgIGNvbnRleHQsXHJcbiAgICAgICAgdHJlZUdyaWRDb2xsZWN0aW9uLnRhYmxlTm9kZXNcclxuICAgIF0pO1xyXG4gICAgbGV0IHRhYmxlU3RhdGUgPSAoMCwgJDRhMGRkMDM2ZDQ5MmNlZTQkZXhwb3J0JDkwN2JjYzZjNDgzMjVmZDYpKHtcclxuICAgICAgICAuLi5wcm9wcyxcclxuICAgICAgICBjb2xsZWN0aW9uOiBjb2xsZWN0aW9uXHJcbiAgICB9KTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgLi4udGFibGVTdGF0ZSxcclxuICAgICAgICBrZXlNYXA6IHRyZWVHcmlkQ29sbGVjdGlvbi5rZXlNYXAsXHJcbiAgICAgICAgdXNlckNvbHVtbkNvdW50OiB0cmVlR3JpZENvbGxlY3Rpb24udXNlckNvbHVtbkNvdW50LFxyXG4gICAgICAgIGV4cGFuZGVkS2V5czogZXhwYW5kZWRLZXlzLFxyXG4gICAgICAgIHRvZ2dsZUtleTogb25Ub2dnbGVcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gJGVlNjVhMDA1N2ZkOTk1MzEkdmFyJHRvZ2dsZUtleShjdXJyZW50RXhwYW5kZWRLZXlzLCBrZXksIGNvbGxlY3Rpb24pIHtcclxuICAgIGxldCB1cGRhdGVkRXhwYW5kZWRLZXlzO1xyXG4gICAgaWYgKGN1cnJlbnRFeHBhbmRlZEtleXMgPT09IFwiYWxsXCIpIHtcclxuICAgICAgICB1cGRhdGVkRXhwYW5kZWRLZXlzID0gbmV3IFNldChjb2xsZWN0aW9uLmZsYXR0ZW5lZFJvd3MuZmlsdGVyKChyb3cpPT5yb3cucHJvcHMuVU5TVEFCTEVfY2hpbGRJdGVtcyB8fCByb3cucHJvcHMuY2hpbGRyZW4ubGVuZ3RoID4gY29sbGVjdGlvbi51c2VyQ29sdW1uQ291bnQpLm1hcCgocm93KT0+cm93LmtleSkpO1xyXG4gICAgICAgIHVwZGF0ZWRFeHBhbmRlZEtleXMuZGVsZXRlKGtleSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHVwZGF0ZWRFeHBhbmRlZEtleXMgPSBuZXcgU2V0KGN1cnJlbnRFeHBhbmRlZEtleXMpO1xyXG4gICAgICAgIGlmICh1cGRhdGVkRXhwYW5kZWRLZXlzLmhhcyhrZXkpKSB1cGRhdGVkRXhwYW5kZWRLZXlzLmRlbGV0ZShrZXkpO1xyXG4gICAgICAgIGVsc2UgdXBkYXRlZEV4cGFuZGVkS2V5cy5hZGQoa2V5KTtcclxuICAgIH1cclxuICAgIHJldHVybiB1cGRhdGVkRXhwYW5kZWRLZXlzO1xyXG59XHJcbmZ1bmN0aW9uICRlZTY1YTAwNTdmZDk5NTMxJHZhciRjb252ZXJ0RXhwYW5kZWQoZXhwYW5kZWQpIHtcclxuICAgIGlmICghZXhwYW5kZWQpIHJldHVybiBuZXcgU2V0KCk7XHJcbiAgICByZXR1cm4gZXhwYW5kZWQgPT09IFwiYWxsXCIgPyBcImFsbFwiIDogbmV3IFNldChleHBhbmRlZCk7XHJcbn1cclxuZnVuY3Rpb24gJGVlNjVhMDA1N2ZkOTk1MzEkdmFyJGdlbmVyYXRlVHJlZUdyaWRDb2xsZWN0aW9uKG5vZGVzLCBvcHRzKSB7XHJcbiAgICBsZXQgeyBleHBhbmRlZEtleXM6IGV4cGFuZGVkS2V5cyA9IG5ldyBTZXQoKSB9ID0gb3B0cztcclxuICAgIGxldCBib2R5O1xyXG4gICAgbGV0IGZsYXR0ZW5lZFJvd3MgPSBbXTtcclxuICAgIGxldCBjb2x1bW5Db3VudCA9IDA7XHJcbiAgICBsZXQgdXNlckNvbHVtbkNvdW50ID0gMDtcclxuICAgIGxldCBvcmlnaW5hbENvbHVtbnMgPSBbXTtcclxuICAgIGxldCBrZXlNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICBpZiAob3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLnNob3dTZWxlY3Rpb25DaGVja2JveGVzKSBjb2x1bW5Db3VudCsrO1xyXG4gICAgaWYgKG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5zaG93RHJhZ0J1dHRvbnMpIGNvbHVtbkNvdW50Kys7XHJcbiAgICBsZXQgdG9wTGV2ZWxSb3dzID0gW107XHJcbiAgICBsZXQgdmlzaXQgPSAobm9kZSk9PntcclxuICAgICAgICBzd2l0Y2gobm9kZS50eXBlKXtcclxuICAgICAgICAgICAgY2FzZSBcImJvZHlcIjpcclxuICAgICAgICAgICAgICAgIGJvZHkgPSBub2RlO1xyXG4gICAgICAgICAgICAgICAga2V5TWFwLnNldChib2R5LmtleSwgYm9keSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcImNvbHVtblwiOlxyXG4gICAgICAgICAgICAgICAgaWYgKCFub2RlLmhhc0NoaWxkTm9kZXMpIHVzZXJDb2x1bW5Db3VudCsrO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJpdGVtXCI6XHJcbiAgICAgICAgICAgICAgICB0b3BMZXZlbFJvd3MucHVzaChub2RlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQgY2hpbGQgb2Ygbm9kZS5jaGlsZE5vZGVzKXZpc2l0KGNoaWxkKTtcclxuICAgIH07XHJcbiAgICBmb3IgKGxldCBub2RlIG9mIG5vZGVzKXtcclxuICAgICAgICBpZiAobm9kZS50eXBlID09PSBcImNvbHVtblwiKSBvcmlnaW5hbENvbHVtbnMucHVzaChub2RlKTtcclxuICAgICAgICB2aXNpdChub2RlKTtcclxuICAgIH1cclxuICAgIGNvbHVtbkNvdW50ICs9IHVzZXJDb2x1bW5Db3VudDtcclxuICAgIC8vIFVwZGF0ZSBlYWNoIGdyaWQgbm9kZSBpbiB0aGUgdHJlZWdyaWQgdGFibGUgd2l0aCB2YWx1ZXMgc3BlY2lmaWMgdG8gYSB0cmVlZ3JpZCBzdHJ1Y3R1cmUuIEFsc28gc3RvcmUgYSBzZXQgb2YgZmxhdHRlbmVkIHJvdyBub2RlcyBmb3IgVGFibGVDb2xsZWN0aW9uIHRvIGNvbnN1bWVcclxuICAgIGxldCBnbG9iYWxSb3dDb3VudCA9IDA7XHJcbiAgICBsZXQgdmlzaXROb2RlID0gKG5vZGUsIGkpPT57XHJcbiAgICAgICAgLy8gQ2xvbmUgcm93IG5vZGUgYW5kIGl0cyBjaGlsZHJlbiBzbyBtb2RpZmljYXRpb25zIHRvIHRoZSBub2RlIGZvciB0cmVlZ3JpZCBzcGVjaWZpYyB2YWx1ZXMgYXJlbid0IGFwcGxpZWQgb24gdGhlIG5vZGVzIHByb3ZpZGVkXHJcbiAgICAgICAgLy8gdG8gVGFibGVDb2xsZWN0aW9uLiBJbmRleCwgbGV2ZWwsIGFuZCBwYXJlbnQga2V5cyBhcmUgYWxsIGNoYW5nZWQgdG8gcmVmbGVjdCBhIGZsYXR0ZW5lZCByb3cgc3RydWN0dXJlIHJhdGhlciB0aGFuIHRoZSB0cmVlZ3JpZCBzdHJ1Y3R1cmVcclxuICAgICAgICAvLyB2YWx1ZXMgYXV0b21hdGljYWxseSBjYWxjdWxhdGVkIHZpYSBDb2xsZWN0aW9uQnVpbGRlclxyXG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09IFwiaXRlbVwiKSB7XHJcbiAgICAgICAgICAgIGxldCBjaGlsZE5vZGVzID0gW107XHJcbiAgICAgICAgICAgIGZvciAobGV0IGNoaWxkIG9mIG5vZGUuY2hpbGROb2RlcylpZiAoY2hpbGQudHlwZSA9PT0gXCJjZWxsXCIpIHtcclxuICAgICAgICAgICAgICAgIGxldCBjZWxsQ2xvbmUgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLi4uY2hpbGRcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBpZiAoY2VsbENsb25lLmluZGV4ICsgMSA9PT0gY29sdW1uQ291bnQpIGNlbGxDbG9uZS5uZXh0S2V5ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGNoaWxkTm9kZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgLi4uY2VsbENsb25lXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgY2xvbmUgPSB7XHJcbiAgICAgICAgICAgICAgICAuLi5ub2RlLFxyXG4gICAgICAgICAgICAgICAgY2hpbGROb2RlczogY2hpbGROb2RlcyxcclxuICAgICAgICAgICAgICAgIHBhcmVudEtleTogYm9keS5rZXksXHJcbiAgICAgICAgICAgICAgICBsZXZlbDogMSxcclxuICAgICAgICAgICAgICAgIGluZGV4OiBnbG9iYWxSb3dDb3VudCsrXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGZsYXR0ZW5lZFJvd3MucHVzaChjbG9uZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBuZXdQcm9wcyA9IHt9O1xyXG4gICAgICAgIC8vIEFzc2lnbiBpbmRleE9mVHlwZSB0byBjZWxscyBhbmQgcm93cyBmb3IgYXJpYS1wb3NpbnNldFxyXG4gICAgICAgIGlmIChub2RlLnR5cGUgIT09IFwicGxhY2Vob2xkZXJcIiAmJiBub2RlLnR5cGUgIT09IFwiY29sdW1uXCIpIG5ld1Byb3BzW1wiaW5kZXhPZlR5cGVcIl0gPSBpO1xyXG4gICAgICAgIC8vIFVzZSBPYmplY3QuYXNzaWduIGluc3RlYWQgb2Ygc3ByZWFkIHRvIHByZXNlcnZlIG9iamVjdCByZWZlcmVuY2UgZm9yIGtleU1hcC4gQWxzbyBlbnN1cmVzIHJldHJpZXZpbmcgbm9kZXNcclxuICAgICAgICAvLyB2aWEgLmNoaWxkTm9kZXMgcmV0dXJucyB0aGUgc2FtZSBvYmplY3QgYXMgdGhlIG9uZSBmb3VuZCB2aWEga2V5TWFwIGxvb2sgdXBcclxuICAgICAgICBPYmplY3QuYXNzaWduKG5vZGUsIG5ld1Byb3BzKTtcclxuICAgICAgICBrZXlNYXAuc2V0KG5vZGUua2V5LCBub2RlKTtcclxuICAgICAgICBsZXQgbGFzdE5vZGU7XHJcbiAgICAgICAgbGV0IHJvd0luZGV4ID0gMDtcclxuICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiBub2RlLmNoaWxkTm9kZXMpaWYgKCEoY2hpbGQudHlwZSA9PT0gXCJpdGVtXCIgJiYgZXhwYW5kZWRLZXlzICE9PSBcImFsbFwiICYmICFleHBhbmRlZEtleXMuaGFzKG5vZGUua2V5KSkpIHtcclxuICAgICAgICAgICAgaWYgKGNoaWxkLnBhcmVudEtleSA9PSBudWxsKSAvLyBpZiBjaGlsZCBpcyBhIGNlbGwvZXhwYW5kZWQgcm93L2NvbHVtbiBhbmQgdGhlIHBhcmVudCBrZXkgaXNuJ3QgYWxyZWFkeSBlc3RhYmxpc2hlZCBieSB0aGUgY29sbGVjdGlvbiwgbWF0Y2ggY2hpbGQgbm9kZSB0byBwYXJlbnQgcm93XHJcbiAgICAgICAgICAgIGNoaWxkLnBhcmVudEtleSA9IG5vZGUua2V5O1xyXG4gICAgICAgICAgICBpZiAobGFzdE5vZGUpIHtcclxuICAgICAgICAgICAgICAgIGxhc3ROb2RlLm5leHRLZXkgPSBjaGlsZC5rZXk7XHJcbiAgICAgICAgICAgICAgICBjaGlsZC5wcmV2S2V5ID0gbGFzdE5vZGUua2V5O1xyXG4gICAgICAgICAgICB9IGVsc2UgY2hpbGQucHJldktleSA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSBcIml0ZW1cIikgdmlzaXROb2RlKGNoaWxkLCByb3dJbmRleCsrKTtcclxuICAgICAgICAgICAgZWxzZSAvLyBXZSBlbmZvcmNlIHRoYXQgdGhlIGNlbGxzIGNvbWUgYmVmb3JlIHJvd3Mgc28gY2FuIGp1c3QgcmV1c2UgY2VsbCBpbmRleFxyXG4gICAgICAgICAgICB2aXNpdE5vZGUoY2hpbGQsIGNoaWxkLmluZGV4KTtcclxuICAgICAgICAgICAgbGFzdE5vZGUgPSBjaGlsZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxhc3ROb2RlKSBsYXN0Tm9kZS5uZXh0S2V5ID0gbnVsbDtcclxuICAgIH07XHJcbiAgICBsZXQgbGFzdDtcclxuICAgIHRvcExldmVsUm93cy5mb3JFYWNoKChub2RlLCBpKT0+e1xyXG4gICAgICAgIHZpc2l0Tm9kZShub2RlLCBpKTtcclxuICAgICAgICBpZiAobGFzdCkge1xyXG4gICAgICAgICAgICBsYXN0Lm5leHRLZXkgPSBub2RlLmtleTtcclxuICAgICAgICAgICAgbm9kZS5wcmV2S2V5ID0gbGFzdC5rZXk7XHJcbiAgICAgICAgfSBlbHNlIG5vZGUucHJldktleSA9IG51bGw7XHJcbiAgICAgICAgbGFzdCA9IG5vZGU7XHJcbiAgICB9KTtcclxuICAgIGlmIChsYXN0KSBsYXN0Lm5leHRLZXkgPSBudWxsO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBrZXlNYXA6IGtleU1hcCxcclxuICAgICAgICB1c2VyQ29sdW1uQ291bnQ6IHVzZXJDb2x1bW5Db3VudCxcclxuICAgICAgICBmbGF0dGVuZWRSb3dzOiBmbGF0dGVuZWRSb3dzLFxyXG4gICAgICAgIHRhYmxlTm9kZXM6IFtcclxuICAgICAgICAgICAgLi4ub3JpZ2luYWxDb2x1bW5zLFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAuLi5ib2R5LFxyXG4gICAgICAgICAgICAgICAgY2hpbGROb2RlczogZmxhdHRlbmVkUm93c1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgXVxyXG4gICAgfTtcclxufVxyXG5cclxuXHJcblxyXG5cclxuZXhwb3J0IHskMjkyYmM0ZTA5Y2QwZWI2MiRleHBvcnQkY2I4OTVkY2Y4NWRiMTMxOSBhcyB1c2VUYWJsZUNvbHVtblJlc2l6ZVN0YXRlLCAkNGEwZGQwMzZkNDkyY2VlNCRleHBvcnQkOTA3YmNjNmM0ODMyNWZkNiBhcyB1c2VUYWJsZVN0YXRlLCAkMzEyYWUzYjU2YTk0YTg2ZSRleHBvcnQkZjg1MDg5NWIyODdlZjI4ZSBhcyBUYWJsZUhlYWRlciwgJDRhZTUzMTRiZjUwZGIxYTMkZXhwb3J0JDc2Y2NkMjEwYjkwMjk5MTcgYXMgVGFibGVCb2R5LCAkMWNkMjQ0NTU3YzJmOTdkNSRleHBvcnQkODE2YjVkODExMjk1ZTZiYyBhcyBDb2x1bW4sICQ3MGQ3MGViMTZlYTQ4NDI4JGV4cG9ydCRiNTliZGJlZjljZTcwZGUyIGFzIFJvdywgJDk0MWQxZDlhNmEyODk4MmEkZXhwb3J0JGY2ZjBjM2ZlNGVjMzA2ZWEgYXMgQ2VsbCwgJDY1NTUxMDRmZjA4NWJlZjQkcmVfZXhwb3J0JFNlY3Rpb24gYXMgU2VjdGlvbiwgJDc4ODc4MWJhYTMwMTE3ZmEkZXhwb3J0JDU5NmUxYjJlMmNmOTM2OTAgYXMgVGFibGVDb2xsZWN0aW9uLCAkNzg4NzgxYmFhMzAxMTdmYSRleHBvcnQkN2MxMjdkYjg1MGQ0ZTgxZSBhcyBidWlsZEhlYWRlclJvd3MsICRhOWU3YWU1NDRhNGU0MWRkJGV4cG9ydCQ3ZmY3N2ExNjI5NzBiMzBlIGFzIFRhYmxlQ29sdW1uTGF5b3V0LCAkZWU2NWEwMDU3ZmQ5OTUzMSRleHBvcnQkMzRkZmE4YTE2MjIxODVhNCBhcyBVTlNUQUJMRV91c2VUcmVlR3JpZFN0YXRlfTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxlLmpzLm1hcFxyXG4iXSwibmFtZXMiOlsiU2VjdGlvbiIsIiQ2NTU1MTA0ZmYwODViZWY0JHJlX2V4cG9ydCRTZWN0aW9uIiwidXNlQ29sbGVjdGlvbiIsIiQxQmZqVyR1c2VDb2xsZWN0aW9uIiwiZ2V0Rmlyc3RJdGVtIiwiJDFCZmpXJGdldEZpcnN0SXRlbSIsImdldExhc3RJdGVtIiwiJDFCZmpXJGdldExhc3RJdGVtIiwiQ29sbGVjdGlvbkJ1aWxkZXIiLCIkMUJmalckQ29sbGVjdGlvbkJ1aWxkZXIiLCIkMUJmalckcmVhY3QiLCJ1c2VTdGF0ZSIsIiQxQmZqVyR1c2VTdGF0ZSIsInVzZU1lbW8iLCIkMUJmalckdXNlTWVtbyIsInVzZUNhbGxiYWNrIiwiJDFCZmpXJHVzZUNhbGxiYWNrIiwidXNlR3JpZFN0YXRlIiwiJDFCZmpXJHVzZUdyaWRTdGF0ZSIsIkdyaWRDb2xsZWN0aW9uIiwiJDFCZmpXJEdyaWRDb2xsZWN0aW9uIiwidGFibGVOZXN0ZWRSb3dzIiwiJDFCZmpXJHRhYmxlTmVzdGVkUm93cyIsInVzZUNvbnRyb2xsZWRTdGF0ZSIsIiQxQmZqVyR1c2VDb250cm9sbGVkU3RhdGUiLCIkNjgxOGIxYzRmYzY3MDI4ZCRleHBvcnQkMTk5NGEwNzdiOThlZTBkNSIsIndpZHRoIiwiaXNOYU4iLCJTdHJpbmciLCJtYXRjaCIsIiQ2ODE4YjFjNGZjNjcwMjhkJGV4cG9ydCQ5MDc4YmFkNGMzOTM0NjA0IiwiY29uc29sZSIsIndhcm4iLCJwYXJzZUZsb2F0IiwiJDY4MThiMWM0ZmM2NzAyOGQkZXhwb3J0JDdiYmFkMjc4OTZmN2FlOWYiLCJ0YWJsZVdpZHRoIiwiRXJyb3IiLCIkNjgxOGIxYzRmYzY3MDI4ZCRleHBvcnQkNTkxODVjNjJhNzU0NGFhMCIsIm1heFdpZHRoIiwiTnVtYmVyIiwiTUFYX1NBRkVfSU5URUdFUiIsIiQ2ODE4YjFjNGZjNjcwMjhkJGV4cG9ydCRmNTU2MDU0Y2U0MzU4NzAxIiwibWluV2lkdGgiLCIkNjgxOGIxYzRmYzY3MDI4ZCRleHBvcnQkNTVkNTBkYzY4NzM4NTQ5MSIsImF2YWlsYWJsZVdpZHRoIiwiY29sdW1ucyIsImNoYW5nZWRDb2x1bW5zIiwiZ2V0RGVmYXVsdFdpZHRoIiwiZ2V0RGVmYXVsdE1pbldpZHRoIiwiaGFzTm9uRnJvemVuSXRlbXMiLCJmbGV4SXRlbXMiLCJtYXAiLCJjb2x1bW4iLCJpbmRleCIsIl9jb2x1bW5fd2lkdGgiLCJfcmVmIiwiX3JlZjEiLCJnZXQiLCJrZXkiLCJkZWZhdWx0V2lkdGgiLCJmcm96ZW4iLCJiYXNlU2l6ZSIsImZsZXgiLCJ0YXJnZXRNYWluU2l6ZSIsIl9jb2x1bW5fbWluV2lkdGgiLCJfcmVmMiIsIm1pbiIsIm1heCIsImh5cG90aGV0aWNhbE1haW5TaXplIiwiTWF0aCIsInZpb2xhdGlvbiIsInVzZWRXaWR0aCIsImZsZXhGYWN0b3JzIiwiZm9yRWFjaCIsIml0ZW0iLCJyZW1haW5pbmdGcmVlU3BhY2UiLCJyYXRpbyIsInRvdGFsVmlvbGF0aW9uIiwic2lnbiIsIiQ2ODE4YjFjNGZjNjcwMjhkJHZhciRjYXNjYWRlUm91bmRpbmciLCJmcFRvdGFsIiwiaW50VG90YWwiLCJyb3VuZGVkQXJyYXkiLCJmbG9hdCIsImludGVnZXIiLCJyb3VuZCIsInB1c2giLCIkYTllN2FlNTQ0YTRlNDFkZCRleHBvcnQkN2ZmNzdhMTYyOTcwYjMwZSIsInNwbGl0Q29sdW1uc0ludG9Db250cm9sbGVkQW5kVW5jb250cm9sbGVkIiwicmVkdWNlIiwiYWNjIiwiY29sIiwicHJvcHMiLCJzZXQiLCJNYXAiLCJyZWNvbWJpbmVDb2x1bW5zIiwidW5jb250cm9sbGVkV2lkdGhzIiwidW5jb250cm9sbGVkQ29sdW1ucyIsImNvbnRyb2xsZWRDb2x1bW5zIiwiaGFzIiwiZ2V0SW5pdGlhbFVuY29udHJvbGxlZFdpZHRocyIsIkFycmF5IiwiZnJvbSIsIl90aGlzX2dldERlZmF1bHRXaWR0aCIsIl90aGlzIiwiX2NvbF9wcm9wc19kZWZhdWx0V2lkdGgiLCJjYWxsIiwiZ2V0Q29sdW1uV2lkdGgiLCJfdGhpc19jb2x1bW5XaWR0aHNfZ2V0IiwiY29sdW1uV2lkdGhzIiwiZ2V0Q29sdW1uTWluV2lkdGgiLCJfdGhpc19jb2x1bW5NaW5XaWR0aHNfZ2V0IiwiY29sdW1uTWluV2lkdGhzIiwiZ2V0Q29sdW1uTWF4V2lkdGgiLCJfdGhpc19jb2x1bW5NYXhXaWR0aHNfZ2V0IiwiY29sdW1uTWF4V2lkdGhzIiwicmVzaXplQ29sdW1uV2lkdGgiLCJjb2xsZWN0aW9uIiwiY29udHJvbGxlZFdpZHRocyIsInByZXZDb2x1bW5XaWR0aHMiLCJyZXNpemVJbmRleCIsIkluZmluaXR5IiwicmVzaXppbmdDaGFuZ2VkIiwicGVyY2VudEtleXMiLCJmcktleXNUb1RoZVJpZ2h0IiwibWluV2lkdGhzIiwiaSIsIl9jb2x1bW5fcHJvcHNfd2lkdGhfZW5kc1dpdGgiLCJfY29sdW1uX3Byb3BzX3dpZHRoIiwiZnJLZXkiLCJmclZhbHVlIiwiZW5kc1dpdGgiLCJmbG9vciIsIm5ld1dpZHRocyIsImJ1aWxkQ29sdW1uV2lkdGhzIiwid2lkdGhzIiwiX2NvbHVtbl9wcm9wc19taW5XaWR0aCIsImNvbnN0cnVjdG9yIiwib3B0aW9ucyIsIl9vcHRpb25zX2dldERlZmF1bHRXaWR0aCIsIl9vcHRpb25zX2dldERlZmF1bHRNaW5XaWR0aCIsIiQyOTJiYzRlMDljZDBlYjYyJGV4cG9ydCRjYjg5NWRjZjg1ZGIxMzE5Iiwic3RhdGUiLCJyZXNpemluZ0NvbHVtbiIsInNldFJlc2l6aW5nQ29sdW1uIiwiY29sdW1uTGF5b3V0Iiwic2V0VW5jb250cm9sbGVkV2lkdGhzIiwibGFzdENvbHVtbnMiLCJzZXRMYXN0Q29sdW1ucyIsImxlbmd0aCIsInNvbWUiLCJjIiwibmV3VW5jb250cm9sbGVkV2lkdGhzIiwiY29sV2lkdGhzIiwic3RhcnRSZXNpemUiLCJ1cGRhdGVSZXNpemVkQ29sdW1ucyIsIm5ld0NvbnRyb2xsZWQiLCJlbnRyeSIsIm5ld1NpemVzIiwiZW5kUmVzaXplIiwidGFibGVTdGF0ZSIsIiQ3ODg3ODFiYWEzMDExN2ZhJHZhciRST1dfSEVBREVSX0NPTFVNTl9LRVkiLCJyYW5kb20iLCJ0b1N0cmluZyIsInNsaWNlIiwiJDc4ODc4MWJhYTMwMTE3ZmEkdmFyJFJPV19IRUFERVJfQ09MVU1OX0tFWV9EUkFHIiwiJDc4ODc4MWJhYTMwMTE3ZmEkZXhwb3J0JDdjMTI3ZGI4NTBkNGU4MWUiLCJrZXlNYXAiLCJjb2x1bW5Ob2RlcyIsInNlZW4iLCJwYXJlbnRLZXkiLCJwYXJlbnQiLCJjb2xzcGFuIiwic3BsaWNlIiwibWF4TGVuZ3RoIiwiaGVhZGVyUm93cyIsImZpbGwiLCJjb2xJbmRleCIsInJvdyIsInJvd0xlbmd0aCIsInAiLCJwbGFjZWhvbGRlciIsInR5cGUiLCJ2YWx1ZSIsInJlbmRlcmVkIiwibGV2ZWwiLCJoYXNDaGlsZE5vZGVzIiwiY2hpbGROb2RlcyIsInRleHRWYWx1ZSIsIm5leHRLZXkiLCJwcmV2S2V5IiwiJDc4ODc4MWJhYTMwMTE3ZmEkZXhwb3J0JDU5NmUxYjJlMmNmOTM2OTAiLCJTeW1ib2wiLCJpdGVyYXRvciIsImJvZHkiLCJzaXplIiwiX3NpemUiLCJnZXRLZXlzIiwia2V5cyIsImdldEtleUJlZm9yZSIsIm5vZGUiLCJnZXRLZXlBZnRlciIsImdldEZpcnN0S2V5IiwiX2dldEZpcnN0SXRlbSIsImdldExhc3RLZXkiLCJfZ2V0TGFzdEl0ZW0iLCJnZXRJdGVtIiwiYXQiLCJpZHgiLCJnZXRUZXh0VmFsdWUiLCJyb3dIZWFkZXJDb2x1bW5LZXlzIiwidGV4dCIsImNlbGwiLCJqb2luIiwibm9kZXMiLCJwcmV2Iiwib3B0cyIsIlNldCIsInNob3dTZWxlY3Rpb25DaGVja2JveGVzIiwicm93SGVhZGVyQ29sdW1uIiwic2hvd0RyYWdCdXR0b25zIiwiaXNTZWxlY3Rpb25DZWxsIiwidW5zaGlmdCIsImlzRHJhZ0J1dHRvbkNlbGwiLCJyb3dzIiwiY29sdW1uS2V5TWFwIiwidmlzaXQiLCJpc1Jvd0hlYWRlciIsImFkZCIsImNoaWxkIiwiY29sdW1uQ291bnQiLCJpdGVtcyIsInZpc2l0Tm9kZSIsIiQ0YTBkZDAzNmQ0OTJjZWU0JHZhciRPUFBPU0lURV9TT1JUX0RJUkVDVElPTiIsImFzY2VuZGluZyIsImRlc2NlbmRpbmciLCIkNGEwZGQwMzZkNDkyY2VlNCRleHBvcnQkOTA3YmNjNmM0ODMyNWZkNiIsImlzS2V5Ym9hcmROYXZpZ2F0aW9uRGlzYWJsZWQiLCJzZXRLZXlib2FyZE5hdmlnYXRpb25EaXNhYmxlZCIsInNlbGVjdGlvbk1vZGUiLCJjb250ZXh0IiwiY2hpbGRyZW4iLCJkaXNhYmxlZEtleXMiLCJzZWxlY3Rpb25NYW5hZ2VyIiwiZGlzYWJsZWRCZWhhdmlvciIsInNvcnREZXNjcmlwdG9yIiwic29ydCIsImNvbHVtbktleSIsImRpcmVjdGlvbiIsIl9wcm9wc19zb3J0RGVzY3JpcHRvciIsIm9uU29ydENoYW5nZSIsIiQzMTJhZTNiNTZhOTRhODZlJHZhciRUYWJsZUhlYWRlciIsImdldENvbGxlY3Rpb25Ob2RlIiwicmVuZGVyZXIiLCJDaGlsZHJlbiIsImVsZW1lbnQiLCIkMzEyYWUzYjU2YTk0YTg2ZSRleHBvcnQkZjg1MDg5NWIyODdlZjI4ZSIsIiQ0YWU1MzE0YmY1MGRiMWEzJHZhciRUYWJsZUJvZHkiLCIkNGFlNTMxNGJmNTBkYjFhMyRleHBvcnQkNzZjY2QyMTBiOTAyOTkxNyIsIiQxY2QyNDQ1NTdjMmY5N2Q1JHZhciRDb2x1bW4iLCJ0aXRsZSIsImNoaWxkQ29sdW1ucyIsImZ1bGxOb2RlcyIsImNvdW50Iiwic2hvdWxkSW52YWxpZGF0ZSIsIm5ld0NvbnRleHQiLCJ1cGRhdGVDb250ZXh0IiwiJDFjZDI0NDU1N2MyZjk3ZDUkZXhwb3J0JDgxNmI1ZDgxMTI5NWU2YmMiLCIkNzBkNzBlYjE2ZWE0ODQyOCR2YXIkUm93IiwiVU5TVEFCTEVfY2hpbGRJdGVtcyIsImNlbGxzIiwiY2hpbGRSb3dzIiwiJDcwZDcwZWIxNmVhNDg0MjgkZXhwb3J0JGI1OWJkYmVmOWNlNzBkZTIiLCIkOTQxZDFkOWE2YTI4OTgyYSR2YXIkQ2VsbCIsIiQ5NDFkMWQ5YTZhMjg5ODJhJGV4cG9ydCRmNmYwYzNmZTRlYzMwNmVhIiwiJGVlNjVhMDA1N2ZkOTk1MzEkZXhwb3J0JDM0ZGZhOGExNjIyMTg1YTQiLCJVTlNUQUJMRV9leHBhbmRlZEtleXMiLCJwcm9wRXhwYW5kZWRLZXlzIiwiVU5TVEFCTEVfZGVmYXVsdEV4cGFuZGVkS2V5cyIsInByb3BEZWZhdWx0RXhwYW5kZWRLZXlzIiwiVU5TVEFCTEVfb25FeHBhbmRlZENoYW5nZSIsImV4cGFuZGVkS2V5cyIsInNldEV4cGFuZGVkS2V5cyIsIiRlZTY1YTAwNTdmZDk5NTMxJHZhciRjb252ZXJ0RXhwYW5kZWQiLCJ1bmRlZmluZWQiLCJidWlsZGVyIiwiYnVpbGQiLCJ0cmVlR3JpZENvbGxlY3Rpb24iLCIkZWU2NWEwMDU3ZmQ5OTUzMSR2YXIkZ2VuZXJhdGVUcmVlR3JpZENvbGxlY3Rpb24iLCJvblRvZ2dsZSIsIiRlZTY1YTAwNTdmZDk5NTMxJHZhciR0b2dnbGVLZXkiLCJ0YWJsZU5vZGVzIiwidXNlckNvbHVtbkNvdW50IiwidG9nZ2xlS2V5IiwiY3VycmVudEV4cGFuZGVkS2V5cyIsInVwZGF0ZWRFeHBhbmRlZEtleXMiLCJmbGF0dGVuZWRSb3dzIiwiZmlsdGVyIiwiZGVsZXRlIiwiZXhwYW5kZWQiLCJvcmlnaW5hbENvbHVtbnMiLCJ0b3BMZXZlbFJvd3MiLCJnbG9iYWxSb3dDb3VudCIsImNlbGxDbG9uZSIsImNsb25lIiwibmV3UHJvcHMiLCJPYmplY3QiLCJhc3NpZ24iLCJsYXN0Tm9kZSIsInJvd0luZGV4IiwibGFzdCIsInVzZVRhYmxlQ29sdW1uUmVzaXplU3RhdGUiLCJ1c2VUYWJsZVN0YXRlIiwiVGFibGVIZWFkZXIiLCJUYWJsZUJvZHkiLCJDb2x1bW4iLCJSb3ciLCJDZWxsIiwiVGFibGVDb2xsZWN0aW9uIiwiYnVpbGRIZWFkZXJSb3dzIiwiVGFibGVDb2x1bW5MYXlvdXQiLCJVTlNUQUJMRV91c2VUcmVlR3JpZFN0YXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/table/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/tabs/dist/import.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@react-stately/tabs/dist/import.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useTabListState: () => (/* binding */ $76f919a04c5a7d14$export$4ba071daf4e486)\n/* harmony export */ });\n/* harmony import */ var _react_stately_list__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/list */ \"(ssr)/./node_modules/@react-stately/list/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n\n/*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ /*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ function $76f919a04c5a7d14$export$4ba071daf4e486(props) {\n    var _props_defaultSelectedKey;\n    let state = (0, _react_stately_list__WEBPACK_IMPORTED_MODULE_1__.useSingleSelectListState)({\n        ...props,\n        suppressTextValueWarning: true,\n        defaultSelectedKey: (_props_defaultSelectedKey = props.defaultSelectedKey) !== null && _props_defaultSelectedKey !== void 0 ? _props_defaultSelectedKey : $76f919a04c5a7d14$var$findDefaultSelectedKey(props.collection, props.disabledKeys ? new Set(props.disabledKeys) : new Set())\n    });\n    let { selectionManager: selectionManager, collection: collection, selectedKey: currentSelectedKey } = state;\n    let lastSelectedKey = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(currentSelectedKey);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        // Ensure a tab is always selected (in case no selected key was specified or if selected item was deleted from collection)\n        let selectedKey = currentSelectedKey;\n        if (selectionManager.isEmpty || !collection.getItem(selectedKey)) {\n            selectedKey = $76f919a04c5a7d14$var$findDefaultSelectedKey(collection, state.disabledKeys);\n            if (selectedKey != null) selectionManager.setSelectedKeys([\n                selectedKey\n            ]);\n        }\n        // If the tablist doesn't have focus and the selected key changes or if there isn't a focused key yet, change focused key to the selected key if it exists.\n        if (selectedKey != null && selectionManager.focusedKey == null || !selectionManager.isFocused && selectedKey !== lastSelectedKey.current) selectionManager.setFocusedKey(selectedKey);\n        lastSelectedKey.current = selectedKey;\n    });\n    return {\n        ...state,\n        isDisabled: props.isDisabled || false\n    };\n}\nfunction $76f919a04c5a7d14$var$findDefaultSelectedKey(collection, disabledKeys) {\n    let selectedKey = null;\n    if (collection) {\n        selectedKey = collection.getFirstKey();\n        // loop over tabs until we find one that isn't disabled and select that\n        while(disabledKeys.has(selectedKey) && selectedKey !== collection.getLastKey())selectedKey = collection.getKeyAfter(selectedKey);\n        // if this check is true, then every item is disabled, it makes more sense to default to the first key than the last\n        if (disabledKeys.has(selectedKey) && selectedKey === collection.getLastKey()) selectedKey = collection.getFirstKey();\n    }\n    return selectedKey;\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvdGFicy9kaXN0L2ltcG9ydC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWdHO0FBQ25CO0FBRTdFOzs7Ozs7Ozs7O0NBVUMsR0FBRzs7Ozs7Ozs7OztDQVVILEdBRUQsU0FBU00sd0NBQXdDQyxLQUFLO0lBQ2xELElBQUlDO0lBQ0osSUFBSUMsUUFBUSxDQUFDLEdBQUdSLHlFQUE4QixFQUFHO1FBQzdDLEdBQUdNLEtBQUs7UUFDUkcsMEJBQTBCO1FBQzFCQyxvQkFBb0IsQ0FBQ0gsNEJBQTRCRCxNQUFNSSxrQkFBa0IsTUFBTSxRQUFRSCw4QkFBOEIsS0FBSyxJQUFJQSw0QkFBNEJJLDZDQUE2Q0wsTUFBTU0sVUFBVSxFQUFFTixNQUFNTyxZQUFZLEdBQUcsSUFBSUMsSUFBSVIsTUFBTU8sWUFBWSxJQUFJLElBQUlDO0lBQ3BSO0lBQ0EsSUFBSSxFQUFFQyxrQkFBa0JBLGdCQUFnQixFQUFFSCxZQUFZQSxVQUFVLEVBQUVJLGFBQWFDLGtCQUFrQixFQUFFLEdBQUdUO0lBQ3RHLElBQUlVLGtCQUFrQixDQUFDLEdBQUdoQix5Q0FBWSxFQUFHZTtJQUN4QyxJQUFHYiw0Q0FBZSxFQUFHO1FBQ2xCLDBIQUEwSDtRQUMxSCxJQUFJWSxjQUFjQztRQUNsQixJQUFJRixpQkFBaUJJLE9BQU8sSUFBSSxDQUFDUCxXQUFXUSxPQUFPLENBQUNKLGNBQWM7WUFDOURBLGNBQWNMLDZDQUE2Q0MsWUFBWUosTUFBTUssWUFBWTtZQUN6RixJQUFJRyxlQUFlLE1BQ25CRCxpQkFBaUJNLGVBQWUsQ0FBQztnQkFDN0JMO2FBQ0g7UUFDTDtRQUNBLDJKQUEySjtRQUMzSixJQUFJQSxlQUFlLFFBQVFELGlCQUFpQk8sVUFBVSxJQUFJLFFBQVEsQ0FBQ1AsaUJBQWlCUSxTQUFTLElBQUlQLGdCQUFnQkUsZ0JBQWdCTSxPQUFPLEVBQUVULGlCQUFpQlUsYUFBYSxDQUFDVDtRQUN6S0UsZ0JBQWdCTSxPQUFPLEdBQUdSO0lBQzlCO0lBQ0EsT0FBTztRQUNILEdBQUdSLEtBQUs7UUFDUmtCLFlBQVlwQixNQUFNb0IsVUFBVSxJQUFJO0lBQ3BDO0FBQ0o7QUFDQSxTQUFTZiw2Q0FBNkNDLFVBQVUsRUFBRUMsWUFBWTtJQUMxRSxJQUFJRyxjQUFjO0lBQ2xCLElBQUlKLFlBQVk7UUFDWkksY0FBY0osV0FBV2UsV0FBVztRQUNwQyx1RUFBdUU7UUFDdkUsTUFBTWQsYUFBYWUsR0FBRyxDQUFDWixnQkFBZ0JBLGdCQUFnQkosV0FBV2lCLFVBQVUsR0FBR2IsY0FBY0osV0FBV2tCLFdBQVcsQ0FBQ2Q7UUFDcEgsb0hBQW9IO1FBQ3BILElBQUlILGFBQWFlLEdBQUcsQ0FBQ1osZ0JBQWdCQSxnQkFBZ0JKLFdBQVdpQixVQUFVLElBQUliLGNBQWNKLFdBQVdlLFdBQVc7SUFDdEg7SUFDQSxPQUFPWDtBQUNYO0FBS29FLENBQ3BFLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL2RhbmFtb25uZXh0X3VpLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC1zdGF0ZWx5L3RhYnMvZGlzdC9pbXBvcnQubWpzPzljOGQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHt1c2VTaW5nbGVTZWxlY3RMaXN0U3RhdGUgYXMgJGlqSEtaJHVzZVNpbmdsZVNlbGVjdExpc3RTdGF0ZX0gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L2xpc3RcIjtcclxuaW1wb3J0IHt1c2VSZWYgYXMgJGlqSEtaJHVzZVJlZiwgdXNlRWZmZWN0IGFzICRpakhLWiR1c2VFZmZlY3R9IGZyb20gXCJyZWFjdFwiO1xyXG5cclxuLypcclxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcclxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXHJcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxyXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi8gLypcclxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcclxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXHJcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxyXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi8gXHJcblxyXG5mdW5jdGlvbiAkNzZmOTE5YTA0YzVhN2QxNCRleHBvcnQkNGJhMDcxZGFmNGU0ODYocHJvcHMpIHtcclxuICAgIHZhciBfcHJvcHNfZGVmYXVsdFNlbGVjdGVkS2V5O1xyXG4gICAgbGV0IHN0YXRlID0gKDAsICRpakhLWiR1c2VTaW5nbGVTZWxlY3RMaXN0U3RhdGUpKHtcclxuICAgICAgICAuLi5wcm9wcyxcclxuICAgICAgICBzdXBwcmVzc1RleHRWYWx1ZVdhcm5pbmc6IHRydWUsXHJcbiAgICAgICAgZGVmYXVsdFNlbGVjdGVkS2V5OiAoX3Byb3BzX2RlZmF1bHRTZWxlY3RlZEtleSA9IHByb3BzLmRlZmF1bHRTZWxlY3RlZEtleSkgIT09IG51bGwgJiYgX3Byb3BzX2RlZmF1bHRTZWxlY3RlZEtleSAhPT0gdm9pZCAwID8gX3Byb3BzX2RlZmF1bHRTZWxlY3RlZEtleSA6ICQ3NmY5MTlhMDRjNWE3ZDE0JHZhciRmaW5kRGVmYXVsdFNlbGVjdGVkS2V5KHByb3BzLmNvbGxlY3Rpb24sIHByb3BzLmRpc2FibGVkS2V5cyA/IG5ldyBTZXQocHJvcHMuZGlzYWJsZWRLZXlzKSA6IG5ldyBTZXQoKSlcclxuICAgIH0pO1xyXG4gICAgbGV0IHsgc2VsZWN0aW9uTWFuYWdlcjogc2VsZWN0aW9uTWFuYWdlciwgY29sbGVjdGlvbjogY29sbGVjdGlvbiwgc2VsZWN0ZWRLZXk6IGN1cnJlbnRTZWxlY3RlZEtleSB9ID0gc3RhdGU7XHJcbiAgICBsZXQgbGFzdFNlbGVjdGVkS2V5ID0gKDAsICRpakhLWiR1c2VSZWYpKGN1cnJlbnRTZWxlY3RlZEtleSk7XHJcbiAgICAoMCwgJGlqSEtaJHVzZUVmZmVjdCkoKCk9PntcclxuICAgICAgICAvLyBFbnN1cmUgYSB0YWIgaXMgYWx3YXlzIHNlbGVjdGVkIChpbiBjYXNlIG5vIHNlbGVjdGVkIGtleSB3YXMgc3BlY2lmaWVkIG9yIGlmIHNlbGVjdGVkIGl0ZW0gd2FzIGRlbGV0ZWQgZnJvbSBjb2xsZWN0aW9uKVxyXG4gICAgICAgIGxldCBzZWxlY3RlZEtleSA9IGN1cnJlbnRTZWxlY3RlZEtleTtcclxuICAgICAgICBpZiAoc2VsZWN0aW9uTWFuYWdlci5pc0VtcHR5IHx8ICFjb2xsZWN0aW9uLmdldEl0ZW0oc2VsZWN0ZWRLZXkpKSB7XHJcbiAgICAgICAgICAgIHNlbGVjdGVkS2V5ID0gJDc2ZjkxOWEwNGM1YTdkMTQkdmFyJGZpbmREZWZhdWx0U2VsZWN0ZWRLZXkoY29sbGVjdGlvbiwgc3RhdGUuZGlzYWJsZWRLZXlzKTtcclxuICAgICAgICAgICAgaWYgKHNlbGVjdGVkS2V5ICE9IG51bGwpIC8vIGRpcmVjdGx5IHNldCBzZWxlY3Rpb24gYmVjYXVzZSByZXBsYWNlL3RvZ2dsZSBzZWxlY3Rpb24gd29uJ3QgY29uc2lkZXIgZGlzYWJsZWQga2V5c1xyXG4gICAgICAgICAgICBzZWxlY3Rpb25NYW5hZ2VyLnNldFNlbGVjdGVkS2V5cyhbXHJcbiAgICAgICAgICAgICAgICBzZWxlY3RlZEtleVxyXG4gICAgICAgICAgICBdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSWYgdGhlIHRhYmxpc3QgZG9lc24ndCBoYXZlIGZvY3VzIGFuZCB0aGUgc2VsZWN0ZWQga2V5IGNoYW5nZXMgb3IgaWYgdGhlcmUgaXNuJ3QgYSBmb2N1c2VkIGtleSB5ZXQsIGNoYW5nZSBmb2N1c2VkIGtleSB0byB0aGUgc2VsZWN0ZWQga2V5IGlmIGl0IGV4aXN0cy5cclxuICAgICAgICBpZiAoc2VsZWN0ZWRLZXkgIT0gbnVsbCAmJiBzZWxlY3Rpb25NYW5hZ2VyLmZvY3VzZWRLZXkgPT0gbnVsbCB8fCAhc2VsZWN0aW9uTWFuYWdlci5pc0ZvY3VzZWQgJiYgc2VsZWN0ZWRLZXkgIT09IGxhc3RTZWxlY3RlZEtleS5jdXJyZW50KSBzZWxlY3Rpb25NYW5hZ2VyLnNldEZvY3VzZWRLZXkoc2VsZWN0ZWRLZXkpO1xyXG4gICAgICAgIGxhc3RTZWxlY3RlZEtleS5jdXJyZW50ID0gc2VsZWN0ZWRLZXk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgLi4uc3RhdGUsXHJcbiAgICAgICAgaXNEaXNhYmxlZDogcHJvcHMuaXNEaXNhYmxlZCB8fCBmYWxzZVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiAkNzZmOTE5YTA0YzVhN2QxNCR2YXIkZmluZERlZmF1bHRTZWxlY3RlZEtleShjb2xsZWN0aW9uLCBkaXNhYmxlZEtleXMpIHtcclxuICAgIGxldCBzZWxlY3RlZEtleSA9IG51bGw7XHJcbiAgICBpZiAoY29sbGVjdGlvbikge1xyXG4gICAgICAgIHNlbGVjdGVkS2V5ID0gY29sbGVjdGlvbi5nZXRGaXJzdEtleSgpO1xyXG4gICAgICAgIC8vIGxvb3Agb3ZlciB0YWJzIHVudGlsIHdlIGZpbmQgb25lIHRoYXQgaXNuJ3QgZGlzYWJsZWQgYW5kIHNlbGVjdCB0aGF0XHJcbiAgICAgICAgd2hpbGUoZGlzYWJsZWRLZXlzLmhhcyhzZWxlY3RlZEtleSkgJiYgc2VsZWN0ZWRLZXkgIT09IGNvbGxlY3Rpb24uZ2V0TGFzdEtleSgpKXNlbGVjdGVkS2V5ID0gY29sbGVjdGlvbi5nZXRLZXlBZnRlcihzZWxlY3RlZEtleSk7XHJcbiAgICAgICAgLy8gaWYgdGhpcyBjaGVjayBpcyB0cnVlLCB0aGVuIGV2ZXJ5IGl0ZW0gaXMgZGlzYWJsZWQsIGl0IG1ha2VzIG1vcmUgc2Vuc2UgdG8gZGVmYXVsdCB0byB0aGUgZmlyc3Qga2V5IHRoYW4gdGhlIGxhc3RcclxuICAgICAgICBpZiAoZGlzYWJsZWRLZXlzLmhhcyhzZWxlY3RlZEtleSkgJiYgc2VsZWN0ZWRLZXkgPT09IGNvbGxlY3Rpb24uZ2V0TGFzdEtleSgpKSBzZWxlY3RlZEtleSA9IGNvbGxlY3Rpb24uZ2V0Rmlyc3RLZXkoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBzZWxlY3RlZEtleTtcclxufVxyXG5cclxuXHJcblxyXG5cclxuZXhwb3J0IHskNzZmOTE5YTA0YzVhN2QxNCRleHBvcnQkNGJhMDcxZGFmNGU0ODYgYXMgdXNlVGFiTGlzdFN0YXRlfTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxlLmpzLm1hcFxyXG4iXSwibmFtZXMiOlsidXNlU2luZ2xlU2VsZWN0TGlzdFN0YXRlIiwiJGlqSEtaJHVzZVNpbmdsZVNlbGVjdExpc3RTdGF0ZSIsInVzZVJlZiIsIiRpakhLWiR1c2VSZWYiLCJ1c2VFZmZlY3QiLCIkaWpIS1okdXNlRWZmZWN0IiwiJDc2ZjkxOWEwNGM1YTdkMTQkZXhwb3J0JDRiYTA3MWRhZjRlNDg2IiwicHJvcHMiLCJfcHJvcHNfZGVmYXVsdFNlbGVjdGVkS2V5Iiwic3RhdGUiLCJzdXBwcmVzc1RleHRWYWx1ZVdhcm5pbmciLCJkZWZhdWx0U2VsZWN0ZWRLZXkiLCIkNzZmOTE5YTA0YzVhN2QxNCR2YXIkZmluZERlZmF1bHRTZWxlY3RlZEtleSIsImNvbGxlY3Rpb24iLCJkaXNhYmxlZEtleXMiLCJTZXQiLCJzZWxlY3Rpb25NYW5hZ2VyIiwic2VsZWN0ZWRLZXkiLCJjdXJyZW50U2VsZWN0ZWRLZXkiLCJsYXN0U2VsZWN0ZWRLZXkiLCJpc0VtcHR5IiwiZ2V0SXRlbSIsInNldFNlbGVjdGVkS2V5cyIsImZvY3VzZWRLZXkiLCJpc0ZvY3VzZWQiLCJjdXJyZW50Iiwic2V0Rm9jdXNlZEtleSIsImlzRGlzYWJsZWQiLCJnZXRGaXJzdEtleSIsImhhcyIsImdldExhc3RLZXkiLCJnZXRLZXlBZnRlciIsInVzZVRhYkxpc3RTdGF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/tabs/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/toggle/dist/import.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@react-stately/toggle/dist/import.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useToggleState: () => (/* binding */ $3017fa7ffdddec74$export$8042c6c013fd5226)\n/* harmony export */ });\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\");\n\n/*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ /*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ function $3017fa7ffdddec74$export$8042c6c013fd5226(props = {}) {\n    let { isReadOnly: isReadOnly } = props;\n    // have to provide an empty function so useControlledState doesn't throw a fit\n    // can't use useControlledState's prop calling because we need the event object from the change\n    let [isSelected, setSelected] = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_0__.useControlledState)(props.isSelected, props.defaultSelected || false, props.onChange);\n    function updateSelected(value) {\n        if (!isReadOnly) setSelected(value);\n    }\n    function toggleState() {\n        if (!isReadOnly) setSelected(!isSelected);\n    }\n    return {\n        isSelected: isSelected,\n        setSelected: updateSelected,\n        toggle: toggleState\n    };\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvdG9nZ2xlL2Rpc3QvaW1wb3J0Lm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFxRjtBQUVyRjs7Ozs7Ozs7OztDQVVDLEdBQUc7Ozs7Ozs7Ozs7Q0FVSCxHQUNELFNBQVNFLDBDQUEwQ0MsUUFBUSxDQUFDLENBQUM7SUFDekQsSUFBSSxFQUFFQyxZQUFZQSxVQUFVLEVBQUUsR0FBR0Q7SUFDakMsOEVBQThFO0lBQzlFLCtGQUErRjtJQUMvRixJQUFJLENBQUNFLFlBQVlDLFlBQVksR0FBRyxDQUFDLEdBQUdMLG9FQUF3QixFQUFHRSxNQUFNRSxVQUFVLEVBQUVGLE1BQU1JLGVBQWUsSUFBSSxPQUFPSixNQUFNSyxRQUFRO0lBQy9ILFNBQVNDLGVBQWVDLEtBQUs7UUFDekIsSUFBSSxDQUFDTixZQUFZRSxZQUFZSTtJQUNqQztJQUNBLFNBQVNDO1FBQ0wsSUFBSSxDQUFDUCxZQUFZRSxZQUFZLENBQUNEO0lBQ2xDO0lBQ0EsT0FBTztRQUNIQSxZQUFZQTtRQUNaQyxhQUFhRztRQUNiRyxRQUFRRDtJQUNaO0FBQ0o7QUFLcUUsQ0FDckUsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGFuYW1vbm5leHRfdWkvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvdG9nZ2xlL2Rpc3QvaW1wb3J0Lm1qcz9mODU3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7dXNlQ29udHJvbGxlZFN0YXRlIGFzICRiT2thZSR1c2VDb250cm9sbGVkU3RhdGV9IGZyb20gXCJAcmVhY3Qtc3RhdGVseS91dGlsc1wiO1xyXG5cclxuLypcclxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcclxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXHJcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxyXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi8gLypcclxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcclxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXHJcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxyXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi8gXHJcbmZ1bmN0aW9uICQzMDE3ZmE3ZmZkZGRlYzc0JGV4cG9ydCQ4MDQyYzZjMDEzZmQ1MjI2KHByb3BzID0ge30pIHtcclxuICAgIGxldCB7IGlzUmVhZE9ubHk6IGlzUmVhZE9ubHkgfSA9IHByb3BzO1xyXG4gICAgLy8gaGF2ZSB0byBwcm92aWRlIGFuIGVtcHR5IGZ1bmN0aW9uIHNvIHVzZUNvbnRyb2xsZWRTdGF0ZSBkb2Vzbid0IHRocm93IGEgZml0XHJcbiAgICAvLyBjYW4ndCB1c2UgdXNlQ29udHJvbGxlZFN0YXRlJ3MgcHJvcCBjYWxsaW5nIGJlY2F1c2Ugd2UgbmVlZCB0aGUgZXZlbnQgb2JqZWN0IGZyb20gdGhlIGNoYW5nZVxyXG4gICAgbGV0IFtpc1NlbGVjdGVkLCBzZXRTZWxlY3RlZF0gPSAoMCwgJGJPa2FlJHVzZUNvbnRyb2xsZWRTdGF0ZSkocHJvcHMuaXNTZWxlY3RlZCwgcHJvcHMuZGVmYXVsdFNlbGVjdGVkIHx8IGZhbHNlLCBwcm9wcy5vbkNoYW5nZSk7XHJcbiAgICBmdW5jdGlvbiB1cGRhdGVTZWxlY3RlZCh2YWx1ZSkge1xyXG4gICAgICAgIGlmICghaXNSZWFkT25seSkgc2V0U2VsZWN0ZWQodmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gdG9nZ2xlU3RhdGUoKSB7XHJcbiAgICAgICAgaWYgKCFpc1JlYWRPbmx5KSBzZXRTZWxlY3RlZCghaXNTZWxlY3RlZCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGlzU2VsZWN0ZWQ6IGlzU2VsZWN0ZWQsXHJcbiAgICAgICAgc2V0U2VsZWN0ZWQ6IHVwZGF0ZVNlbGVjdGVkLFxyXG4gICAgICAgIHRvZ2dsZTogdG9nZ2xlU3RhdGVcclxuICAgIH07XHJcbn1cclxuXHJcblxyXG5cclxuXHJcbmV4cG9ydCB7JDMwMTdmYTdmZmRkZGVjNzQkZXhwb3J0JDgwNDJjNmMwMTNmZDUyMjYgYXMgdXNlVG9nZ2xlU3RhdGV9O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGUuanMubWFwXHJcbiJdLCJuYW1lcyI6WyJ1c2VDb250cm9sbGVkU3RhdGUiLCIkYk9rYWUkdXNlQ29udHJvbGxlZFN0YXRlIiwiJDMwMTdmYTdmZmRkZGVjNzQkZXhwb3J0JDgwNDJjNmMwMTNmZDUyMjYiLCJwcm9wcyIsImlzUmVhZE9ubHkiLCJpc1NlbGVjdGVkIiwic2V0U2VsZWN0ZWQiLCJkZWZhdWx0U2VsZWN0ZWQiLCJvbkNoYW5nZSIsInVwZGF0ZVNlbGVjdGVkIiwidmFsdWUiLCJ0b2dnbGVTdGF0ZSIsInRvZ2dsZSIsInVzZVRvZ2dsZVN0YXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/toggle/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/tooltip/dist/import.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@react-stately/tooltip/dist/import.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useTooltipTriggerState: () => (/* binding */ $8796f90736e175cb$export$4d40659c25ecb50b)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_stately_overlays__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/overlays */ \"(ssr)/./node_modules/@react-stately/overlays/dist/import.mjs\");\n\n\n/*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ /*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ const $8796f90736e175cb$var$TOOLTIP_DELAY = 1500; // this seems to be a 1.5 second delay, check with design\nconst $8796f90736e175cb$var$TOOLTIP_COOLDOWN = 500;\nlet $8796f90736e175cb$var$tooltips = {};\nlet $8796f90736e175cb$var$tooltipId = 0;\nlet $8796f90736e175cb$var$globalWarmedUp = false;\nlet $8796f90736e175cb$var$globalWarmUpTimeout = null;\nlet $8796f90736e175cb$var$globalCooldownTimeout = null;\nfunction $8796f90736e175cb$export$4d40659c25ecb50b(props = {}) {\n    let { delay: delay = $8796f90736e175cb$var$TOOLTIP_DELAY, closeDelay: closeDelay = $8796f90736e175cb$var$TOOLTIP_COOLDOWN } = props;\n    let { isOpen: isOpen, open: open, close: close } = (0, _react_stately_overlays__WEBPACK_IMPORTED_MODULE_1__.useOverlayTriggerState)(props);\n    let id = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>`${++$8796f90736e175cb$var$tooltipId}`, []);\n    let closeTimeout = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    let ensureTooltipEntry = ()=>{\n        $8796f90736e175cb$var$tooltips[id] = hideTooltip;\n    };\n    let closeOpenTooltips = ()=>{\n        for(let hideTooltipId in $8796f90736e175cb$var$tooltips)if (hideTooltipId !== id) {\n            $8796f90736e175cb$var$tooltips[hideTooltipId](true);\n            delete $8796f90736e175cb$var$tooltips[hideTooltipId];\n        }\n    };\n    let showTooltip = ()=>{\n        clearTimeout(closeTimeout.current);\n        closeTimeout.current = null;\n        closeOpenTooltips();\n        ensureTooltipEntry();\n        $8796f90736e175cb$var$globalWarmedUp = true;\n        open();\n        if ($8796f90736e175cb$var$globalWarmUpTimeout) {\n            clearTimeout($8796f90736e175cb$var$globalWarmUpTimeout);\n            $8796f90736e175cb$var$globalWarmUpTimeout = null;\n        }\n        if ($8796f90736e175cb$var$globalCooldownTimeout) {\n            clearTimeout($8796f90736e175cb$var$globalCooldownTimeout);\n            $8796f90736e175cb$var$globalCooldownTimeout = null;\n        }\n    };\n    let hideTooltip = (immediate)=>{\n        if (immediate || closeDelay <= 0) {\n            clearTimeout(closeTimeout.current);\n            closeTimeout.current = null;\n            close();\n        } else if (!closeTimeout.current) closeTimeout.current = setTimeout(()=>{\n            closeTimeout.current = null;\n            close();\n        }, closeDelay);\n        if ($8796f90736e175cb$var$globalWarmUpTimeout) {\n            clearTimeout($8796f90736e175cb$var$globalWarmUpTimeout);\n            $8796f90736e175cb$var$globalWarmUpTimeout = null;\n        }\n        if ($8796f90736e175cb$var$globalWarmedUp) {\n            if ($8796f90736e175cb$var$globalCooldownTimeout) clearTimeout($8796f90736e175cb$var$globalCooldownTimeout);\n            $8796f90736e175cb$var$globalCooldownTimeout = setTimeout(()=>{\n                delete $8796f90736e175cb$var$tooltips[id];\n                $8796f90736e175cb$var$globalCooldownTimeout = null;\n                $8796f90736e175cb$var$globalWarmedUp = false;\n            }, Math.max($8796f90736e175cb$var$TOOLTIP_COOLDOWN, closeDelay));\n        }\n    };\n    let warmupTooltip = ()=>{\n        closeOpenTooltips();\n        ensureTooltipEntry();\n        if (!isOpen && !$8796f90736e175cb$var$globalWarmUpTimeout && !$8796f90736e175cb$var$globalWarmedUp) $8796f90736e175cb$var$globalWarmUpTimeout = setTimeout(()=>{\n            $8796f90736e175cb$var$globalWarmUpTimeout = null;\n            $8796f90736e175cb$var$globalWarmedUp = true;\n            showTooltip();\n        }, delay);\n        else if (!isOpen) showTooltip();\n    };\n    // eslint-disable-next-line arrow-body-style\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return ()=>{\n            clearTimeout(closeTimeout.current);\n            let tooltip = $8796f90736e175cb$var$tooltips[id];\n            if (tooltip) delete $8796f90736e175cb$var$tooltips[id];\n        };\n    }, [\n        id\n    ]);\n    return {\n        isOpen: isOpen,\n        open: (immediate)=>{\n            if (!immediate && delay > 0 && !closeTimeout.current) warmupTooltip();\n            else showTooltip();\n        },\n        close: hideTooltip\n    };\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvdG9vbHRpcC9kaXN0L2ltcG9ydC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXdHO0FBQ1I7QUFFaEc7Ozs7Ozs7Ozs7Q0FVQyxHQUFHOzs7Ozs7Ozs7O0NBVUgsR0FFRCxNQUFNUSxzQ0FBc0MsTUFBTSx5REFBeUQ7QUFDM0csTUFBTUMseUNBQXlDO0FBQy9DLElBQUlDLGlDQUFpQyxDQUFDO0FBQ3RDLElBQUlDLGtDQUFrQztBQUN0QyxJQUFJQyx1Q0FBdUM7QUFDM0MsSUFBSUMsNENBQTRDO0FBQ2hELElBQUlDLDhDQUE4QztBQUNsRCxTQUFTQywwQ0FBMENDLFFBQVEsQ0FBQyxDQUFDO0lBQ3pELElBQUksRUFBRUMsT0FBT0EsUUFBUVQsbUNBQW1DLEVBQUVVLFlBQVlBLGFBQWFULHNDQUFzQyxFQUFFLEdBQUdPO0lBQzlILElBQUksRUFBRUcsUUFBUUEsTUFBTSxFQUFFQyxNQUFNQSxJQUFJLEVBQUVDLE9BQU9BLEtBQUssRUFBRSxHQUFHLENBQUMsR0FBR2QsMkVBQTRCLEVBQUdTO0lBQ3RGLElBQUlNLEtBQUssQ0FBQyxHQUFHckIsMENBQWEsRUFBRyxJQUFJLENBQUMsRUFBRSxFQUFFVSxnQ0FBZ0MsQ0FBQyxFQUFFLEVBQUU7SUFDM0UsSUFBSVksZUFBZSxDQUFDLEdBQUdwQix5Q0FBWTtJQUNuQyxJQUFJcUIscUJBQXFCO1FBQ3JCZCw4QkFBOEIsQ0FBQ1ksR0FBRyxHQUFHRztJQUN6QztJQUNBLElBQUlDLG9CQUFvQjtRQUNwQixJQUFJLElBQUlDLGlCQUFpQmpCLCtCQUErQixJQUFJaUIsa0JBQWtCTCxJQUFJO1lBQzlFWiw4QkFBOEIsQ0FBQ2lCLGNBQWMsQ0FBQztZQUM5QyxPQUFPakIsOEJBQThCLENBQUNpQixjQUFjO1FBQ3hEO0lBQ0o7SUFDQSxJQUFJQyxjQUFjO1FBQ2RDLGFBQWFOLGFBQWFPLE9BQU87UUFDakNQLGFBQWFPLE9BQU8sR0FBRztRQUN2Qko7UUFDQUY7UUFDQVosdUNBQXVDO1FBQ3ZDUTtRQUNBLElBQUlQLDJDQUEyQztZQUMzQ2dCLGFBQWFoQjtZQUNiQSw0Q0FBNEM7UUFDaEQ7UUFDQSxJQUFJQyw2Q0FBNkM7WUFDN0NlLGFBQWFmO1lBQ2JBLDhDQUE4QztRQUNsRDtJQUNKO0lBQ0EsSUFBSVcsY0FBYyxDQUFDTTtRQUNmLElBQUlBLGFBQWFiLGNBQWMsR0FBRztZQUM5QlcsYUFBYU4sYUFBYU8sT0FBTztZQUNqQ1AsYUFBYU8sT0FBTyxHQUFHO1lBQ3ZCVDtRQUNKLE9BQU8sSUFBSSxDQUFDRSxhQUFhTyxPQUFPLEVBQUVQLGFBQWFPLE9BQU8sR0FBR0UsV0FBVztZQUNoRVQsYUFBYU8sT0FBTyxHQUFHO1lBQ3ZCVDtRQUNKLEdBQUdIO1FBQ0gsSUFBSUwsMkNBQTJDO1lBQzNDZ0IsYUFBYWhCO1lBQ2JBLDRDQUE0QztRQUNoRDtRQUNBLElBQUlELHNDQUFzQztZQUN0QyxJQUFJRSw2Q0FBNkNlLGFBQWFmO1lBQzlEQSw4Q0FBOENrQixXQUFXO2dCQUNyRCxPQUFPdEIsOEJBQThCLENBQUNZLEdBQUc7Z0JBQ3pDUiw4Q0FBOEM7Z0JBQzlDRix1Q0FBdUM7WUFDM0MsR0FBR3FCLEtBQUtDLEdBQUcsQ0FBQ3pCLHdDQUF3Q1M7UUFDeEQ7SUFDSjtJQUNBLElBQUlpQixnQkFBZ0I7UUFDaEJUO1FBQ0FGO1FBQ0EsSUFBSSxDQUFDTCxVQUFVLENBQUNOLDZDQUE2QyxDQUFDRCxzQ0FBc0NDLDRDQUE0Q21CLFdBQVc7WUFDdkpuQiw0Q0FBNEM7WUFDNUNELHVDQUF1QztZQUN2Q2dCO1FBQ0osR0FBR1g7YUFDRSxJQUFJLENBQUNFLFFBQVFTO0lBQ3RCO0lBQ0EsNENBQTRDO0lBQzNDLElBQUd2Qiw0Q0FBZSxFQUFHO1FBQ2xCLE9BQU87WUFDSHdCLGFBQWFOLGFBQWFPLE9BQU87WUFDakMsSUFBSU0sVUFBVTFCLDhCQUE4QixDQUFDWSxHQUFHO1lBQ2hELElBQUljLFNBQVMsT0FBTzFCLDhCQUE4QixDQUFDWSxHQUFHO1FBQzFEO0lBQ0osR0FBRztRQUNDQTtLQUNIO0lBQ0QsT0FBTztRQUNISCxRQUFRQTtRQUNSQyxNQUFNLENBQUNXO1lBQ0gsSUFBSSxDQUFDQSxhQUFhZCxRQUFRLEtBQUssQ0FBQ00sYUFBYU8sT0FBTyxFQUFFSztpQkFDakRQO1FBQ1Q7UUFDQVAsT0FBT0k7SUFDWDtBQUNKO0FBSzZFLENBQzdFLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL2RhbmFtb25uZXh0X3VpLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC1zdGF0ZWx5L3Rvb2x0aXAvZGlzdC9pbXBvcnQubWpzPzE1OGEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHt1c2VNZW1vIGFzICQxT2hEcSR1c2VNZW1vLCB1c2VSZWYgYXMgJDFPaERxJHVzZVJlZiwgdXNlRWZmZWN0IGFzICQxT2hEcSR1c2VFZmZlY3R9IGZyb20gXCJyZWFjdFwiO1xyXG5pbXBvcnQge3VzZU92ZXJsYXlUcmlnZ2VyU3RhdGUgYXMgJDFPaERxJHVzZU92ZXJsYXlUcmlnZ2VyU3RhdGV9IGZyb20gXCJAcmVhY3Qtc3RhdGVseS9vdmVybGF5c1wiO1xyXG5cclxuLypcclxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcclxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXHJcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxyXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi8gLypcclxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcclxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXHJcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxyXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi8gXHJcblxyXG5jb25zdCAkODc5NmY5MDczNmUxNzVjYiR2YXIkVE9PTFRJUF9ERUxBWSA9IDE1MDA7IC8vIHRoaXMgc2VlbXMgdG8gYmUgYSAxLjUgc2Vjb25kIGRlbGF5LCBjaGVjayB3aXRoIGRlc2lnblxyXG5jb25zdCAkODc5NmY5MDczNmUxNzVjYiR2YXIkVE9PTFRJUF9DT09MRE9XTiA9IDUwMDtcclxubGV0ICQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciR0b29sdGlwcyA9IHt9O1xyXG5sZXQgJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJHRvb2x0aXBJZCA9IDA7XHJcbmxldCAkODc5NmY5MDczNmUxNzVjYiR2YXIkZ2xvYmFsV2FybWVkVXAgPSBmYWxzZTtcclxubGV0ICQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciRnbG9iYWxXYXJtVXBUaW1lb3V0ID0gbnVsbDtcclxubGV0ICQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciRnbG9iYWxDb29sZG93blRpbWVvdXQgPSBudWxsO1xyXG5mdW5jdGlvbiAkODc5NmY5MDczNmUxNzVjYiRleHBvcnQkNGQ0MDY1OWMyNWVjYjUwYihwcm9wcyA9IHt9KSB7XHJcbiAgICBsZXQgeyBkZWxheTogZGVsYXkgPSAkODc5NmY5MDczNmUxNzVjYiR2YXIkVE9PTFRJUF9ERUxBWSwgY2xvc2VEZWxheTogY2xvc2VEZWxheSA9ICQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciRUT09MVElQX0NPT0xET1dOIH0gPSBwcm9wcztcclxuICAgIGxldCB7IGlzT3BlbjogaXNPcGVuLCBvcGVuOiBvcGVuLCBjbG9zZTogY2xvc2UgfSA9ICgwLCAkMU9oRHEkdXNlT3ZlcmxheVRyaWdnZXJTdGF0ZSkocHJvcHMpO1xyXG4gICAgbGV0IGlkID0gKDAsICQxT2hEcSR1c2VNZW1vKSgoKT0+YCR7KyskODc5NmY5MDczNmUxNzVjYiR2YXIkdG9vbHRpcElkfWAsIFtdKTtcclxuICAgIGxldCBjbG9zZVRpbWVvdXQgPSAoMCwgJDFPaERxJHVzZVJlZikoKTtcclxuICAgIGxldCBlbnN1cmVUb29sdGlwRW50cnkgPSAoKT0+e1xyXG4gICAgICAgICQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciR0b29sdGlwc1tpZF0gPSBoaWRlVG9vbHRpcDtcclxuICAgIH07XHJcbiAgICBsZXQgY2xvc2VPcGVuVG9vbHRpcHMgPSAoKT0+e1xyXG4gICAgICAgIGZvcihsZXQgaGlkZVRvb2x0aXBJZCBpbiAkODc5NmY5MDczNmUxNzVjYiR2YXIkdG9vbHRpcHMpaWYgKGhpZGVUb29sdGlwSWQgIT09IGlkKSB7XHJcbiAgICAgICAgICAgICQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciR0b29sdGlwc1toaWRlVG9vbHRpcElkXSh0cnVlKTtcclxuICAgICAgICAgICAgZGVsZXRlICQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciR0b29sdGlwc1toaWRlVG9vbHRpcElkXTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgbGV0IHNob3dUb29sdGlwID0gKCk9PntcclxuICAgICAgICBjbGVhclRpbWVvdXQoY2xvc2VUaW1lb3V0LmN1cnJlbnQpO1xyXG4gICAgICAgIGNsb3NlVGltZW91dC5jdXJyZW50ID0gbnVsbDtcclxuICAgICAgICBjbG9zZU9wZW5Ub29sdGlwcygpO1xyXG4gICAgICAgIGVuc3VyZVRvb2x0aXBFbnRyeSgpO1xyXG4gICAgICAgICQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciRnbG9iYWxXYXJtZWRVcCA9IHRydWU7XHJcbiAgICAgICAgb3BlbigpO1xyXG4gICAgICAgIGlmICgkODc5NmY5MDczNmUxNzVjYiR2YXIkZ2xvYmFsV2FybVVwVGltZW91dCkge1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJGdsb2JhbFdhcm1VcFRpbWVvdXQpO1xyXG4gICAgICAgICAgICAkODc5NmY5MDczNmUxNzVjYiR2YXIkZ2xvYmFsV2FybVVwVGltZW91dCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgkODc5NmY5MDczNmUxNzVjYiR2YXIkZ2xvYmFsQ29vbGRvd25UaW1lb3V0KSB7XHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCgkODc5NmY5MDczNmUxNzVjYiR2YXIkZ2xvYmFsQ29vbGRvd25UaW1lb3V0KTtcclxuICAgICAgICAgICAgJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJGdsb2JhbENvb2xkb3duVGltZW91dCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGxldCBoaWRlVG9vbHRpcCA9IChpbW1lZGlhdGUpPT57XHJcbiAgICAgICAgaWYgKGltbWVkaWF0ZSB8fCBjbG9zZURlbGF5IDw9IDApIHtcclxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGNsb3NlVGltZW91dC5jdXJyZW50KTtcclxuICAgICAgICAgICAgY2xvc2VUaW1lb3V0LmN1cnJlbnQgPSBudWxsO1xyXG4gICAgICAgICAgICBjbG9zZSgpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoIWNsb3NlVGltZW91dC5jdXJyZW50KSBjbG9zZVRpbWVvdXQuY3VycmVudCA9IHNldFRpbWVvdXQoKCk9PntcclxuICAgICAgICAgICAgY2xvc2VUaW1lb3V0LmN1cnJlbnQgPSBudWxsO1xyXG4gICAgICAgICAgICBjbG9zZSgpO1xyXG4gICAgICAgIH0sIGNsb3NlRGVsYXkpO1xyXG4gICAgICAgIGlmICgkODc5NmY5MDczNmUxNzVjYiR2YXIkZ2xvYmFsV2FybVVwVGltZW91dCkge1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJGdsb2JhbFdhcm1VcFRpbWVvdXQpO1xyXG4gICAgICAgICAgICAkODc5NmY5MDczNmUxNzVjYiR2YXIkZ2xvYmFsV2FybVVwVGltZW91dCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgkODc5NmY5MDczNmUxNzVjYiR2YXIkZ2xvYmFsV2FybWVkVXApIHtcclxuICAgICAgICAgICAgaWYgKCQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciRnbG9iYWxDb29sZG93blRpbWVvdXQpIGNsZWFyVGltZW91dCgkODc5NmY5MDczNmUxNzVjYiR2YXIkZ2xvYmFsQ29vbGRvd25UaW1lb3V0KTtcclxuICAgICAgICAgICAgJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJGdsb2JhbENvb2xkb3duVGltZW91dCA9IHNldFRpbWVvdXQoKCk9PntcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSAkODc5NmY5MDczNmUxNzVjYiR2YXIkdG9vbHRpcHNbaWRdO1xyXG4gICAgICAgICAgICAgICAgJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJGdsb2JhbENvb2xkb3duVGltZW91dCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAkODc5NmY5MDczNmUxNzVjYiR2YXIkZ2xvYmFsV2FybWVkVXAgPSBmYWxzZTtcclxuICAgICAgICAgICAgfSwgTWF0aC5tYXgoJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJFRPT0xUSVBfQ09PTERPV04sIGNsb3NlRGVsYXkpKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgbGV0IHdhcm11cFRvb2x0aXAgPSAoKT0+e1xyXG4gICAgICAgIGNsb3NlT3BlblRvb2x0aXBzKCk7XHJcbiAgICAgICAgZW5zdXJlVG9vbHRpcEVudHJ5KCk7XHJcbiAgICAgICAgaWYgKCFpc09wZW4gJiYgISQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciRnbG9iYWxXYXJtVXBUaW1lb3V0ICYmICEkODc5NmY5MDczNmUxNzVjYiR2YXIkZ2xvYmFsV2FybWVkVXApICQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciRnbG9iYWxXYXJtVXBUaW1lb3V0ID0gc2V0VGltZW91dCgoKT0+e1xyXG4gICAgICAgICAgICAkODc5NmY5MDczNmUxNzVjYiR2YXIkZ2xvYmFsV2FybVVwVGltZW91dCA9IG51bGw7XHJcbiAgICAgICAgICAgICQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciRnbG9iYWxXYXJtZWRVcCA9IHRydWU7XHJcbiAgICAgICAgICAgIHNob3dUb29sdGlwKCk7XHJcbiAgICAgICAgfSwgZGVsYXkpO1xyXG4gICAgICAgIGVsc2UgaWYgKCFpc09wZW4pIHNob3dUb29sdGlwKCk7XHJcbiAgICB9O1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGFycm93LWJvZHktc3R5bGVcclxuICAgICgwLCAkMU9oRHEkdXNlRWZmZWN0KSgoKT0+e1xyXG4gICAgICAgIHJldHVybiAoKT0+e1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoY2xvc2VUaW1lb3V0LmN1cnJlbnQpO1xyXG4gICAgICAgICAgICBsZXQgdG9vbHRpcCA9ICQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciR0b29sdGlwc1tpZF07XHJcbiAgICAgICAgICAgIGlmICh0b29sdGlwKSBkZWxldGUgJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJHRvb2x0aXBzW2lkXTtcclxuICAgICAgICB9O1xyXG4gICAgfSwgW1xyXG4gICAgICAgIGlkXHJcbiAgICBdKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgaXNPcGVuOiBpc09wZW4sXHJcbiAgICAgICAgb3BlbjogKGltbWVkaWF0ZSk9PntcclxuICAgICAgICAgICAgaWYgKCFpbW1lZGlhdGUgJiYgZGVsYXkgPiAwICYmICFjbG9zZVRpbWVvdXQuY3VycmVudCkgd2FybXVwVG9vbHRpcCgpO1xyXG4gICAgICAgICAgICBlbHNlIHNob3dUb29sdGlwKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjbG9zZTogaGlkZVRvb2x0aXBcclxuICAgIH07XHJcbn1cclxuXHJcblxyXG5cclxuXHJcbmV4cG9ydCB7JDg3OTZmOTA3MzZlMTc1Y2IkZXhwb3J0JDRkNDA2NTljMjVlY2I1MGIgYXMgdXNlVG9vbHRpcFRyaWdnZXJTdGF0ZX07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsZS5qcy5tYXBcclxuIl0sIm5hbWVzIjpbInVzZU1lbW8iLCIkMU9oRHEkdXNlTWVtbyIsInVzZVJlZiIsIiQxT2hEcSR1c2VSZWYiLCJ1c2VFZmZlY3QiLCIkMU9oRHEkdXNlRWZmZWN0IiwidXNlT3ZlcmxheVRyaWdnZXJTdGF0ZSIsIiQxT2hEcSR1c2VPdmVybGF5VHJpZ2dlclN0YXRlIiwiJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJFRPT0xUSVBfREVMQVkiLCIkODc5NmY5MDczNmUxNzVjYiR2YXIkVE9PTFRJUF9DT09MRE9XTiIsIiQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciR0b29sdGlwcyIsIiQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciR0b29sdGlwSWQiLCIkODc5NmY5MDczNmUxNzVjYiR2YXIkZ2xvYmFsV2FybWVkVXAiLCIkODc5NmY5MDczNmUxNzVjYiR2YXIkZ2xvYmFsV2FybVVwVGltZW91dCIsIiQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciRnbG9iYWxDb29sZG93blRpbWVvdXQiLCIkODc5NmY5MDczNmUxNzVjYiRleHBvcnQkNGQ0MDY1OWMyNWVjYjUwYiIsInByb3BzIiwiZGVsYXkiLCJjbG9zZURlbGF5IiwiaXNPcGVuIiwib3BlbiIsImNsb3NlIiwiaWQiLCJjbG9zZVRpbWVvdXQiLCJlbnN1cmVUb29sdGlwRW50cnkiLCJoaWRlVG9vbHRpcCIsImNsb3NlT3BlblRvb2x0aXBzIiwiaGlkZVRvb2x0aXBJZCIsInNob3dUb29sdGlwIiwiY2xlYXJUaW1lb3V0IiwiY3VycmVudCIsImltbWVkaWF0ZSIsInNldFRpbWVvdXQiLCJNYXRoIiwibWF4Iiwid2FybXVwVG9vbHRpcCIsInRvb2x0aXAiLCJ1c2VUb29sdGlwVHJpZ2dlclN0YXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/tooltip/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/tree/dist/import.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@react-stately/tree/dist/import.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TreeCollection: () => (/* binding */ $05ca4cd7c4a5a999$export$863faf230ee2118a),\n/* harmony export */   useTreeState: () => (/* binding */ $875d6693e12af071$export$728d6ba534403756)\n/* harmony export */ });\n/* harmony import */ var _react_stately_selection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-stately/selection */ \"(ssr)/./node_modules/@react-stately/selection/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_stately_collections__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @react-stately/collections */ \"(ssr)/./node_modules/@react-stately/collections/dist/import.mjs\");\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\");\n\n\n\n\n/*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ /*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ /*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ class $05ca4cd7c4a5a999$export$863faf230ee2118a {\n    *[Symbol.iterator]() {\n        yield* this.iterable;\n    }\n    get size() {\n        return this.keyMap.size;\n    }\n    getKeys() {\n        return this.keyMap.keys();\n    }\n    getKeyBefore(key) {\n        let node = this.keyMap.get(key);\n        return node ? node.prevKey : null;\n    }\n    getKeyAfter(key) {\n        let node = this.keyMap.get(key);\n        return node ? node.nextKey : null;\n    }\n    getFirstKey() {\n        return this.firstKey;\n    }\n    getLastKey() {\n        return this.lastKey;\n    }\n    getItem(key) {\n        return this.keyMap.get(key);\n    }\n    at(idx) {\n        const keys = [\n            ...this.getKeys()\n        ];\n        return this.getItem(keys[idx]);\n    }\n    constructor(nodes, { expandedKeys: expandedKeys } = {}){\n        this.keyMap = new Map();\n        this.iterable = nodes;\n        expandedKeys = expandedKeys || new Set();\n        let visit = (node)=>{\n            this.keyMap.set(node.key, node);\n            if (node.childNodes && (node.type === \"section\" || expandedKeys.has(node.key))) for (let child of node.childNodes)visit(child);\n        };\n        for (let node of nodes)visit(node);\n        let last;\n        let index = 0;\n        for (let [key, node] of this.keyMap){\n            if (last) {\n                last.nextKey = key;\n                node.prevKey = last.key;\n            } else {\n                this.firstKey = key;\n                node.prevKey = undefined;\n            }\n            if (node.type === \"item\") node.index = index++;\n            last = node;\n            // Set nextKey as undefined since this might be the last node\n            // If it isn't the last node, last.nextKey will properly set at start of new loop\n            last.nextKey = undefined;\n        }\n        this.lastKey = last === null || last === void 0 ? void 0 : last.key;\n    }\n}\nfunction $875d6693e12af071$export$728d6ba534403756(props) {\n    let [expandedKeys, setExpandedKeys] = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.useControlledState)(props.expandedKeys ? new Set(props.expandedKeys) : undefined, props.defaultExpandedKeys ? new Set(props.defaultExpandedKeys) : new Set(), props.onExpandedChange);\n    let selectionState = (0, _react_stately_selection__WEBPACK_IMPORTED_MODULE_2__.useMultipleSelectionState)(props);\n    let disabledKeys = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>props.disabledKeys ? new Set(props.disabledKeys) : new Set(), [\n        props.disabledKeys\n    ]);\n    let tree = (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_3__.useCollection)(props, (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((nodes)=>new (0, $05ca4cd7c4a5a999$export$863faf230ee2118a)(nodes, {\n            expandedKeys: expandedKeys\n        }), [\n        expandedKeys\n    ]), null);\n    // Reset focused key if that item is deleted from the collection.\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (selectionState.focusedKey != null && !tree.getItem(selectionState.focusedKey)) selectionState.setFocusedKey(null);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        tree,\n        selectionState.focusedKey\n    ]);\n    let onToggle = (key)=>{\n        setExpandedKeys($875d6693e12af071$var$toggleKey(expandedKeys, key));\n    };\n    return {\n        collection: tree,\n        expandedKeys: expandedKeys,\n        disabledKeys: disabledKeys,\n        toggleKey: onToggle,\n        setExpandedKeys: setExpandedKeys,\n        selectionManager: new (0, _react_stately_selection__WEBPACK_IMPORTED_MODULE_2__.SelectionManager)(tree, selectionState)\n    };\n}\nfunction $875d6693e12af071$var$toggleKey(set, key) {\n    let res = new Set(set);\n    if (res.has(key)) res.delete(key);\n    else res.add(key);\n    return res;\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvdHJlZS9kaXN0L2ltcG9ydC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQW9KO0FBQ2xDO0FBQ2pDO0FBQ0k7QUFFckY7Ozs7Ozs7Ozs7Q0FVQyxHQUFHOzs7Ozs7Ozs7O0NBVUgsR0FDRDs7Ozs7Ozs7OztDQVVDLEdBQUcsTUFBTWM7SUFDTixDQUFDLENBQUNDLE9BQU9DLFFBQVEsQ0FBQyxHQUFHO1FBQ2pCLE9BQU8sSUFBSSxDQUFDQyxRQUFRO0lBQ3hCO0lBQ0EsSUFBSUMsT0FBTztRQUNQLE9BQU8sSUFBSSxDQUFDQyxNQUFNLENBQUNELElBQUk7SUFDM0I7SUFDQUUsVUFBVTtRQUNOLE9BQU8sSUFBSSxDQUFDRCxNQUFNLENBQUNFLElBQUk7SUFDM0I7SUFDQUMsYUFBYUMsR0FBRyxFQUFFO1FBQ2QsSUFBSUMsT0FBTyxJQUFJLENBQUNMLE1BQU0sQ0FBQ00sR0FBRyxDQUFDRjtRQUMzQixPQUFPQyxPQUFPQSxLQUFLRSxPQUFPLEdBQUc7SUFDakM7SUFDQUMsWUFBWUosR0FBRyxFQUFFO1FBQ2IsSUFBSUMsT0FBTyxJQUFJLENBQUNMLE1BQU0sQ0FBQ00sR0FBRyxDQUFDRjtRQUMzQixPQUFPQyxPQUFPQSxLQUFLSSxPQUFPLEdBQUc7SUFDakM7SUFDQUMsY0FBYztRQUNWLE9BQU8sSUFBSSxDQUFDQyxRQUFRO0lBQ3hCO0lBQ0FDLGFBQWE7UUFDVCxPQUFPLElBQUksQ0FBQ0MsT0FBTztJQUN2QjtJQUNBQyxRQUFRVixHQUFHLEVBQUU7UUFDVCxPQUFPLElBQUksQ0FBQ0osTUFBTSxDQUFDTSxHQUFHLENBQUNGO0lBQzNCO0lBQ0FXLEdBQUdDLEdBQUcsRUFBRTtRQUNKLE1BQU1kLE9BQU87ZUFDTixJQUFJLENBQUNELE9BQU87U0FDbEI7UUFDRCxPQUFPLElBQUksQ0FBQ2EsT0FBTyxDQUFDWixJQUFJLENBQUNjLElBQUk7SUFDakM7SUFDQUMsWUFBWUMsS0FBSyxFQUFFLEVBQUVD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TUFBTSxJQUFJekIsSUFBSUU7SUFDbEIsSUFBSXVCLElBQUlwQixHQUFHLENBQUN0QixNQUFNMEMsSUFBSUMsTUFBTSxDQUFDM0M7U0FDeEIwQyxJQUFJRSxHQUFHLENBQUM1QztJQUNiLE9BQU8wQztBQUNYO0FBTWdJLENBQ2hJLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL2RhbmFtb25uZXh0X3VpLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC1zdGF0ZWx5L3RyZWUvZGlzdC9pbXBvcnQubWpzP2IwOWYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHt1c2VNdWx0aXBsZVNlbGVjdGlvblN0YXRlIGFzICQxT29UaiR1c2VNdWx0aXBsZVNlbGVjdGlvblN0YXRlLCBTZWxlY3Rpb25NYW5hZ2VyIGFzICQxT29UaiRTZWxlY3Rpb25NYW5hZ2VyfSBmcm9tIFwiQHJlYWN0LXN0YXRlbHkvc2VsZWN0aW9uXCI7XHJcbmltcG9ydCB7dXNlTWVtbyBhcyAkMU9vVGokdXNlTWVtbywgdXNlQ2FsbGJhY2sgYXMgJDFPb1RqJHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QgYXMgJDFPb1RqJHVzZUVmZmVjdH0gZnJvbSBcInJlYWN0XCI7XHJcbmltcG9ydCB7dXNlQ29sbGVjdGlvbiBhcyAkMU9vVGokdXNlQ29sbGVjdGlvbn0gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L2NvbGxlY3Rpb25zXCI7XHJcbmltcG9ydCB7dXNlQ29udHJvbGxlZFN0YXRlIGFzICQxT29UaiR1c2VDb250cm9sbGVkU3RhdGV9IGZyb20gXCJAcmVhY3Qtc3RhdGVseS91dGlsc1wiO1xyXG5cclxuLypcclxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcclxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXHJcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxyXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi8gLypcclxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcclxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXHJcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxyXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi8gXHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XHJcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXHJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xyXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcclxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovIGNsYXNzICQwNWNhNGNkN2M0YTVhOTk5JGV4cG9ydCQ4NjNmYWYyMzBlZTIxMThhIHtcclxuICAgICpbU3ltYm9sLml0ZXJhdG9yXSgpIHtcclxuICAgICAgICB5aWVsZCogdGhpcy5pdGVyYWJsZTtcclxuICAgIH1cclxuICAgIGdldCBzaXplKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmtleU1hcC5zaXplO1xyXG4gICAgfVxyXG4gICAgZ2V0S2V5cygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5rZXlNYXAua2V5cygpO1xyXG4gICAgfVxyXG4gICAgZ2V0S2V5QmVmb3JlKGtleSkge1xyXG4gICAgICAgIGxldCBub2RlID0gdGhpcy5rZXlNYXAuZ2V0KGtleSk7XHJcbiAgICAgICAgcmV0dXJuIG5vZGUgPyBub2RlLnByZXZLZXkgOiBudWxsO1xyXG4gICAgfVxyXG4gICAgZ2V0S2V5QWZ0ZXIoa2V5KSB7XHJcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLmtleU1hcC5nZXQoa2V5KTtcclxuICAgICAgICByZXR1cm4gbm9kZSA/IG5vZGUubmV4dEtleSA6IG51bGw7XHJcbiAgICB9XHJcbiAgICBnZXRGaXJzdEtleSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5maXJzdEtleTtcclxuICAgIH1cclxuICAgIGdldExhc3RLZXkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdEtleTtcclxuICAgIH1cclxuICAgIGdldEl0ZW0oa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5TWFwLmdldChrZXkpO1xyXG4gICAgfVxyXG4gICAgYXQoaWR4KSB7XHJcbiAgICAgICAgY29uc3Qga2V5cyA9IFtcclxuICAgICAgICAgICAgLi4udGhpcy5nZXRLZXlzKClcclxuICAgICAgICBdO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldEl0ZW0oa2V5c1tpZHhdKTtcclxuICAgIH1cclxuICAgIGNvbnN0cnVjdG9yKG5vZGVzLCB7IGV4cGFuZGVkS2V5czogZXhwYW5kZWRLZXlzIH0gPSB7fSl7XHJcbiAgICAgICAgdGhpcy5rZXlNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5pdGVyYWJsZSA9IG5vZGVzO1xyXG4gICAgICAgIGV4cGFuZGVkS2V5cyA9IGV4cGFuZGVkS2V5cyB8fCBuZXcgU2V0KCk7XHJcbiAgICAgICAgbGV0IHZpc2l0ID0gKG5vZGUpPT57XHJcbiAgICAgICAgICAgIHRoaXMua2V5TWFwLnNldChub2RlLmtleSwgbm9kZSk7XHJcbiAgICAgICAgICAgIGlmIChub2RlLmNoaWxkTm9kZXMgJiYgKG5vZGUudHlwZSA9PT0gXCJzZWN0aW9uXCIgfHwgZXhwYW5kZWRLZXlzLmhhcyhub2RlLmtleSkpKSBmb3IgKGxldCBjaGlsZCBvZiBub2RlLmNoaWxkTm9kZXMpdmlzaXQoY2hpbGQpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgZm9yIChsZXQgbm9kZSBvZiBub2Rlcyl2aXNpdChub2RlKTtcclxuICAgICAgICBsZXQgbGFzdDtcclxuICAgICAgICBsZXQgaW5kZXggPSAwO1xyXG4gICAgICAgIGZvciAobGV0IFtrZXksIG5vZGVdIG9mIHRoaXMua2V5TWFwKXtcclxuICAgICAgICAgICAgaWYgKGxhc3QpIHtcclxuICAgICAgICAgICAgICAgIGxhc3QubmV4dEtleSA9IGtleTtcclxuICAgICAgICAgICAgICAgIG5vZGUucHJldktleSA9IGxhc3Qua2V5O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5maXJzdEtleSA9IGtleTtcclxuICAgICAgICAgICAgICAgIG5vZGUucHJldktleSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSBcIml0ZW1cIikgbm9kZS5pbmRleCA9IGluZGV4Kys7XHJcbiAgICAgICAgICAgIGxhc3QgPSBub2RlO1xyXG4gICAgICAgICAgICAvLyBTZXQgbmV4dEtleSBhcyB1bmRlZmluZWQgc2luY2UgdGhpcyBtaWdodCBiZSB0aGUgbGFzdCBub2RlXHJcbiAgICAgICAgICAgIC8vIElmIGl0IGlzbid0IHRoZSBsYXN0IG5vZGUsIGxhc3QubmV4dEtleSB3aWxsIHByb3Blcmx5IHNldCBhdCBzdGFydCBvZiBuZXcgbG9vcFxyXG4gICAgICAgICAgICBsYXN0Lm5leHRLZXkgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubGFzdEtleSA9IGxhc3QgPT09IG51bGwgfHwgbGFzdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGFzdC5rZXk7XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5cclxuXHJcblxyXG5mdW5jdGlvbiAkODc1ZDY2OTNlMTJhZjA3MSRleHBvcnQkNzI4ZDZiYTUzNDQwMzc1Nihwcm9wcykge1xyXG4gICAgbGV0IFtleHBhbmRlZEtleXMsIHNldEV4cGFuZGVkS2V5c10gPSAoMCwgJDFPb1RqJHVzZUNvbnRyb2xsZWRTdGF0ZSkocHJvcHMuZXhwYW5kZWRLZXlzID8gbmV3IFNldChwcm9wcy5leHBhbmRlZEtleXMpIDogdW5kZWZpbmVkLCBwcm9wcy5kZWZhdWx0RXhwYW5kZWRLZXlzID8gbmV3IFNldChwcm9wcy5kZWZhdWx0RXhwYW5kZWRLZXlzKSA6IG5ldyBTZXQoKSwgcHJvcHMub25FeHBhbmRlZENoYW5nZSk7XHJcbiAgICBsZXQgc2VsZWN0aW9uU3RhdGUgPSAoMCwgJDFPb1RqJHVzZU11bHRpcGxlU2VsZWN0aW9uU3RhdGUpKHByb3BzKTtcclxuICAgIGxldCBkaXNhYmxlZEtleXMgPSAoMCwgJDFPb1RqJHVzZU1lbW8pKCgpPT5wcm9wcy5kaXNhYmxlZEtleXMgPyBuZXcgU2V0KHByb3BzLmRpc2FibGVkS2V5cykgOiBuZXcgU2V0KCksIFtcclxuICAgICAgICBwcm9wcy5kaXNhYmxlZEtleXNcclxuICAgIF0pO1xyXG4gICAgbGV0IHRyZWUgPSAoMCwgJDFPb1RqJHVzZUNvbGxlY3Rpb24pKHByb3BzLCAoMCwgJDFPb1RqJHVzZUNhbGxiYWNrKSgobm9kZXMpPT5uZXcgKDAsICQwNWNhNGNkN2M0YTVhOTk5JGV4cG9ydCQ4NjNmYWYyMzBlZTIxMThhKShub2Rlcywge1xyXG4gICAgICAgICAgICBleHBhbmRlZEtleXM6IGV4cGFuZGVkS2V5c1xyXG4gICAgICAgIH0pLCBbXHJcbiAgICAgICAgZXhwYW5kZWRLZXlzXHJcbiAgICBdKSwgbnVsbCk7XHJcbiAgICAvLyBSZXNldCBmb2N1c2VkIGtleSBpZiB0aGF0IGl0ZW0gaXMgZGVsZXRlZCBmcm9tIHRoZSBjb2xsZWN0aW9uLlxyXG4gICAgKDAsICQxT29UaiR1c2VFZmZlY3QpKCgpPT57XHJcbiAgICAgICAgaWYgKHNlbGVjdGlvblN0YXRlLmZvY3VzZWRLZXkgIT0gbnVsbCAmJiAhdHJlZS5nZXRJdGVtKHNlbGVjdGlvblN0YXRlLmZvY3VzZWRLZXkpKSBzZWxlY3Rpb25TdGF0ZS5zZXRGb2N1c2VkS2V5KG51bGwpO1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xyXG4gICAgfSwgW1xyXG4gICAgICAgIHRyZWUsXHJcbiAgICAgICAgc2VsZWN0aW9uU3RhdGUuZm9jdXNlZEtleVxyXG4gICAgXSk7XHJcbiAgICBsZXQgb25Ub2dnbGUgPSAoa2V5KT0+e1xyXG4gICAgICAgIHNldEV4cGFuZGVkS2V5cygkODc1ZDY2OTNlMTJhZjA3MSR2YXIkdG9nZ2xlS2V5KGV4cGFuZGVkS2V5cywga2V5KSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBjb2xsZWN0aW9uOiB0cmVlLFxyXG4gICAgICAgIGV4cGFuZGVkS2V5czogZXhwYW5kZWRLZXlzLFxyXG4gICAgICAgIGRpc2FibGVkS2V5czogZGlzYWJsZWRLZXlzLFxyXG4gICAgICAgIHRvZ2dsZUtleTogb25Ub2dnbGUsXHJcbiAgICAgICAgc2V0RXhwYW5kZWRLZXlzOiBzZXRFeHBhbmRlZEtleXMsXHJcbiAgICAgICAgc2VsZWN0aW9uTWFuYWdlcjogbmV3ICgwLCAkMU9vVGokU2VsZWN0aW9uTWFuYWdlcikodHJlZSwgc2VsZWN0aW9uU3RhdGUpXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uICQ4NzVkNjY5M2UxMmFmMDcxJHZhciR0b2dnbGVLZXkoc2V0LCBrZXkpIHtcclxuICAgIGxldCByZXMgPSBuZXcgU2V0KHNldCk7XHJcbiAgICBpZiAocmVzLmhhcyhrZXkpKSByZXMuZGVsZXRlKGtleSk7XHJcbiAgICBlbHNlIHJlcy5hZGQoa2V5KTtcclxuICAgIHJldHVybiByZXM7XHJcbn1cclxuXHJcblxyXG5cclxuXHJcblxyXG5leHBvcnQgeyQ4NzVkNjY5M2UxMmFmMDcxJGV4cG9ydCQ3MjhkNmJhNTM0NDAzNzU2IGFzIHVzZVRyZWVTdGF0ZSwgJDA1Y2E0Y2Q3YzRhNWE5OTkkZXhwb3J0JDg2M2ZhZjIzMGVlMjExOGEgYXMgVHJlZUNvbGxlY3Rpb259O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGUuanMubWFwXHJcbiJdLCJuYW1lcyI6WyJ1c2VNdWx0aXBsZVNlbGVjdGlvblN0YXRlIiwiJDFPb1RqJHVzZU11bHRpcGxlU2VsZWN0aW9uU3RhdGUiLCJTZWxlY3Rpb25NYW5hZ2VyIiwiJDFPb1RqJFNlbGVjdGlvbk1hbmFnZXIiLCJ1c2VNZW1vIiwiJDFPb1RqJHVzZU1lbW8iLCJ1c2VDYWxsYmFjayIsIiQxT29UaiR1c2VDYWxsYmFjayIsInVzZUVmZmVjdCIsIiQxT29UaiR1c2VFZmZlY3QiLCJ1c2VDb2xsZWN0aW9uIiwiJDFPb1RqJHVzZUNvbGxlY3Rpb24iLCJ1c2VDb250cm9sbGVkU3RhdGUiLCIkMU9vVGokdXNlQ29udHJvbGxlZFN0YXRlIiwiJDA1Y2E0Y2Q3YzRhNWE5OTkkZXhwb3J0JDg2M2ZhZjIzMGVlMjExOGEiLCJTeW1ib2wiLCJpdGVyYXRvciIsIml0ZXJhYmxlIiwic2l6ZSIsImtleU1hcCIsImdldEtleXMiLCJrZXlzIiwiZ2V0S2V5QmVmb3JlIiwia2V5Iiwibm9kZSIsImdldCIsInByZXZLZXkiLCJnZXRLZXlBZnRlciIsIm5leHRLZXkiLCJnZXRGaXJzdEtleSIsImZpcnN0S2V5IiwiZ2V0TGFzdEtleSIsImxhc3RLZXkiLCJnZXRJdGVtIiwiYXQiLCJpZHgiLCJjb25zdHJ1Y3RvciIsIm5vZGVzIiwiZXhwYW5kZWRLZXlzIiwiTWFwIiwiU2V0IiwidmlzaXQiLCJzZXQiLCJjaGlsZE5vZGVzIiwidHlwZSIsImhhcyIsImNoaWxkIiwibGFzdCIsImluZGV4IiwidW5kZWZpbmVkIiwiJDg3NWQ2NjkzZTEyYWYwNzEkZXhwb3J0JDcyOGQ2YmE1MzQ0MDM3NTYiLCJwcm9wcyIsInNldEV4cGFuZGVkS2V5cyIsImRlZmF1bHRFeHBhbmRlZEtleXMiLCJvbkV4cGFuZGVkQ2hhbmdlIiwic2VsZWN0aW9uU3RhdGUiLCJkaXNhYmxlZEtleXMiLCJ0cmVlIiwiZm9jdXNlZEtleSIsInNldEZvY3VzZWRLZXkiLCJvblRvZ2dsZSIsIiQ4NzVkNjY5M2UxMmFmMDcxJHZhciR0b2dnbGVLZXkiLCJjb2xsZWN0aW9uIiwidG9nZ2xlS2V5Iiwic2VsZWN0aW9uTWFuYWdlciIsInJlcyIsImRlbGV0ZSIsImFkZCIsInVzZVRyZWVTdGF0ZSIsIlRyZWVDb2xsZWN0aW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/tree/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/utils/dist/import.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@react-stately/utils/dist/import.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clamp: () => (/* binding */ $9446cca9a3875146$export$7d15b64cf5a3a4c4),\n/* harmony export */   snapValueToStep: () => (/* binding */ $9446cca9a3875146$export$cb6e0bb50bc19463),\n/* harmony export */   toFixedNumber: () => (/* binding */ $9446cca9a3875146$export$b6268554fba451f),\n/* harmony export */   useControlledState: () => (/* binding */ $458b0a5536c1a7cf$export$40bfa8c7b0832715)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n/*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ /*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ function $458b0a5536c1a7cf$export$40bfa8c7b0832715(value, defaultValue, onChange) {\n    let [stateValue, setStateValue] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(value || defaultValue);\n    let isControlledRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(value !== undefined);\n    let isControlled = value !== undefined;\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        let wasControlled = isControlledRef.current;\n        if (wasControlled !== isControlled) console.warn(`WARN: A component changed from ${wasControlled ? \"controlled\" : \"uncontrolled\"} to ${isControlled ? \"controlled\" : \"uncontrolled\"}.`);\n        isControlledRef.current = isControlled;\n    }, [\n        isControlled\n    ]);\n    let currentValue = isControlled ? value : stateValue;\n    let setValue = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((value, ...args)=>{\n        let onChangeCaller = (value, ...onChangeArgs)=>{\n            if (onChange) {\n                if (!Object.is(currentValue, value)) onChange(value, ...onChangeArgs);\n            }\n            if (!isControlled) // calling setState multiple times with the same value only emits onChange once.\n            // We do not use a ref for this because we specifically _do_ want the value to\n            // reset every render, and assigning to a ref in render breaks aborted suspended renders.\n            // eslint-disable-next-line react-hooks/exhaustive-deps\n            currentValue = value;\n        };\n        if (typeof value === \"function\") {\n            console.warn(\"We can not support a function callback. See Github Issues for details https://github.com/adobe/react-spectrum/issues/2320\");\n            // this supports functional updates https://reactjs.org/docs/hooks-reference.html#functional-updates\n            // when someone using useControlledState calls setControlledState(myFunc)\n            // this will call our useState setState with a function as well which invokes myFunc and calls onChange with the value from myFunc\n            // if we're in an uncontrolled state, then we also return the value of myFunc which to setState looks as though it was just called with myFunc from the beginning\n            // otherwise we just return the controlled value, which won't cause a rerender because React knows to bail out when the value is the same\n            let updateFunction = (oldValue, ...functionArgs)=>{\n                let interceptedValue = value(isControlled ? currentValue : oldValue, ...functionArgs);\n                onChangeCaller(interceptedValue, ...args);\n                if (!isControlled) return interceptedValue;\n                return oldValue;\n            };\n            setStateValue(updateFunction);\n        } else {\n            if (!isControlled) setStateValue(value);\n            onChangeCaller(value, ...args);\n        }\n    }, [\n        isControlled,\n        currentValue,\n        onChange\n    ]);\n    return [\n        currentValue,\n        setValue\n    ];\n}\n/*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ /**\r\n * Takes a value and forces it to the closest min/max if it's outside. Also forces it to the closest valid step.\r\n */ function $9446cca9a3875146$export$7d15b64cf5a3a4c4(value, min = -Infinity, max = Infinity) {\n    let newValue = Math.min(Math.max(value, min), max);\n    return newValue;\n}\nfunction $9446cca9a3875146$export$cb6e0bb50bc19463(value, min, max, step) {\n    min = Number(min);\n    max = Number(max);\n    let remainder = (value - (isNaN(min) ? 0 : min)) % step;\n    let snappedValue = Math.abs(remainder) * 2 >= step ? value + Math.sign(remainder) * (step - Math.abs(remainder)) : value - remainder;\n    if (!isNaN(min)) {\n        if (snappedValue < min) snappedValue = min;\n        else if (!isNaN(max) && snappedValue > max) snappedValue = min + Math.floor((max - min) / step) * step;\n    } else if (!isNaN(max) && snappedValue > max) snappedValue = Math.floor(max / step) * step;\n    // correct floating point behavior by rounding to step precision\n    let string = step.toString();\n    let index = string.indexOf(\".\");\n    let precision = index >= 0 ? string.length - index : 0;\n    if (precision > 0) {\n        let pow = Math.pow(10, precision);\n        snappedValue = Math.round(snappedValue * pow) / pow;\n    }\n    return snappedValue;\n}\nfunction $9446cca9a3875146$export$b6268554fba451f(value, digits, base = 10) {\n    const pow = Math.pow(base, digits);\n    return Math.round(value * pow) / pow;\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvdXRpbHMvZGlzdC9pbXBvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQTZJO0FBRTdJOzs7Ozs7Ozs7O0NBVUMsR0FBRzs7Ozs7Ozs7OztDQVVILEdBQ0QsU0FBU1EsMENBQTBDQyxLQUFLLEVBQUVDLFlBQVksRUFBRUMsUUFBUTtJQUM1RSxJQUFJLENBQUNDLFlBQVlDLGNBQWMsR0FBRyxDQUFDLEdBQUdaLDJDQUFjLEVBQUdRLFNBQVNDO0lBQ2hFLElBQUlJLGtCQUFrQixDQUFDLEdBQUdYLHlDQUFZLEVBQUdNLFVBQVVNO0lBQ25ELElBQUlDLGVBQWVQLFVBQVVNO0lBQzVCLElBQUdWLDRDQUFlLEVBQUc7UUFDbEIsSUFBSVksZ0JBQWdCSCxnQkFBZ0JJLE9BQU87UUFDM0MsSUFBSUQsa0JBQWtCRCxjQUFjRyxRQUFRQyxJQUFJLENBQUMsQ0FBQywrQkFBK0IsRUFBRUgsZ0JBQWdCLGVBQWUsZUFBZSxJQUFJLEVBQUVELGVBQWUsZUFBZSxlQUFlLENBQUMsQ0FBQztRQUN0TEYsZ0JBQWdCSSxPQUFPLEdBQUdGO0lBQzlCLEdBQUc7UUFDQ0E7S0FDSDtJQUNELElBQUlLLGVBQWVMLGVBQWVQLFFBQVFHO0lBQzFDLElBQUlVLFdBQVcsQ0FBQyxHQUFHZiw4Q0FBaUIsRUFBRyxDQUFDRSxPQUFPLEdBQUdjO1FBQzlDLElBQUlDLGlCQUFpQixDQUFDZixPQUFPLEdBQUdnQjtZQUM1QixJQUFJZCxVQUFVO2dCQUNWLElBQUksQ0FBQ2UsT0FBT0MsRUFBRSxDQUFDTixjQUFjWixRQUFRRSxTQUFTRixVQUFVZ0I7WUFDNUQ7WUFDQSxJQUFJLENBQUNULGNBQ0wsZ0ZBQWdGO1lBQ2hGLDhFQUE4RTtZQUM5RSx5RkFBeUY7WUFDekYsdURBQXVEO1lBQ3ZESyxlQUFlWjtRQUNuQjtRQUNBLElBQUksT0FBT0EsVUFBVSxZQUFZO1lBQzdCVSxRQUFRQyxJQUFJLENBQUM7WUFDYixvR0FBb0c7WUFDcEcseUVBQXlFO1lBQ3pFLGtJQUFrSTtZQUNsSSxpS0FBaUs7WUFDaksseUlBQXlJO1lBQ3pJLElBQUlRLGlCQUFpQixDQUFDQyxVQUFVLEdBQUdDO2dCQUMvQixJQUFJQyxtQkFBbUJ0QixNQUFNTyxlQUFlSyxlQUFlUSxhQUFhQztnQkFDeEVOLGVBQWVPLHFCQUFxQlI7Z0JBQ3BDLElBQUksQ0FBQ1AsY0FBYyxPQUFPZTtnQkFDMUIsT0FBT0Y7WUFDWDtZQUNBaEIsY0FBY2U7UUFDbEIsT0FBTztZQUNILElBQUksQ0FBQ1osY0FBY0gsY0FBY0o7WUFDakNlLGVBQWVmLFVBQVVjO1FBQzdCO0lBQ0osR0FBRztRQUNDUDtRQUNBSztRQUNBVjtLQUNIO0lBQ0QsT0FBTztRQUNIVTtRQUNBQztLQUNIO0FBQ0w7QUFHQTs7Ozs7Ozs7OztDQVVDLEdBQUc7O0NBRUgsR0FBRyxTQUFTVSwwQ0FBMEN2QixLQUFLLEVBQUV3QixNQUFNLENBQUNDLFFBQVEsRUFBRUMsTUFBTUQsUUFBUTtJQUN6RixJQUFJRSxXQUFXQyxLQUFLSixHQUFHLENBQUNJLEtBQUtGLEdBQUcsQ0FBQzFCLE9BQU93QixNQUFNRTtJQUM5QyxPQUFPQztBQUNYO0FBQ0EsU0FBU0UsMENBQTBDN0IsS0FBSyxFQUFFd0IsR0FBRyxFQUFFRSxHQUFHLEVBQUVJLElBQUk7SUFDcEVOLE1BQU1PLE9BQU9QO0lBQ2JFLE1BQU1LLE9BQU9MO0lBQ2IsSUFBSU0sWUFBWSxDQUFDaEMsUUFBU2lDLENBQUFBLE1BQU1ULE9BQU8sSUFBSUEsR0FBRSxDQUFDLElBQUtNO0lBQ25ELElBQUlJLGVBQWVOLEtBQUtPLEdBQUcsQ0FBQ0gsYUFBYSxLQUFLRixPQUFPOUIsUUFBUTRCLEtBQUtRLElBQUksQ0FBQ0osYUFBY0YsQ0FBQUEsT0FBT0YsS0FBS08sR0FBRyxDQUFDSCxVQUFTLElBQUtoQyxRQUFRZ0M7SUFDM0gsSUFBSSxDQUFDQyxNQUFNVCxNQUFNO1FBQ2IsSUFBSVUsZUFBZVYsS0FBS1UsZUFBZVY7YUFDbEMsSUFBSSxDQUFDUyxNQUFNUCxRQUFRUSxlQUFlUixLQUFLUSxlQUFlVixNQUFNSSxLQUFLUyxLQUFLLENBQUMsQ0FBQ1gsTUFBTUYsR0FBRSxJQUFLTSxRQUFRQTtJQUN0RyxPQUFPLElBQUksQ0FBQ0csTUFBTVAsUUFBUVEsZUFBZVIsS0FBS1EsZUFBZU4sS0FBS1MsS0FBSyxDQUFDWCxNQUFNSSxRQUFRQTtJQUN0RixnRUFBZ0U7SUFDaEUsSUFBSVEsU0FBU1IsS0FBS1MsUUFBUTtJQUMxQixJQUFJQyxRQUFRRixPQUFPRyxPQUFPLENBQUM7SUFDM0IsSUFBSUMsWUFBWUYsU0FBUyxJQUFJRixPQUFPSyxNQUFNLEdBQUdILFFBQVE7SUFDckQsSUFBSUUsWUFBWSxHQUFHO1FBQ2YsSUFBSUUsTUFBTWhCLEtBQUtnQixHQUFHLENBQUMsSUFBSUY7UUFDdkJSLGVBQWVOLEtBQUtpQixLQUFLLENBQUNYLGVBQWVVLE9BQU9BO0lBQ3BEO0lBQ0EsT0FBT1Y7QUFDWDtBQUNBLFNBQVNZLHlDQUF5QzlDLEtBQUssRUFBRStDLE1BQU0sRUFBRUMsT0FBTyxFQUFFO0lBQ3RFLE1BQU1KLE1BQU1oQixLQUFLZ0IsR0FBRyxDQUFDSSxNQUFNRDtJQUMzQixPQUFPbkIsS0FBS2lCLEtBQUssQ0FBQzdDLFFBQVE0QyxPQUFPQTtBQUNyQztBQUtzUCxDQUN0UCxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYW5hbW9ubmV4dF91aS8uL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3RhdGVseS91dGlscy9kaXN0L2ltcG9ydC5tanM/ZTNmNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3VzZVN0YXRlIGFzICQ2aW11aCR1c2VTdGF0ZSwgdXNlUmVmIGFzICQ2aW11aCR1c2VSZWYsIHVzZUVmZmVjdCBhcyAkNmltdWgkdXNlRWZmZWN0LCB1c2VDYWxsYmFjayBhcyAkNmltdWgkdXNlQ2FsbGJhY2t9IGZyb20gXCJyZWFjdFwiO1xyXG5cclxuLypcclxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcclxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXHJcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxyXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi8gLypcclxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcclxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXHJcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxyXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi8gXHJcbmZ1bmN0aW9uICQ0NThiMGE1NTM2YzFhN2NmJGV4cG9ydCQ0MGJmYThjN2IwODMyNzE1KHZhbHVlLCBkZWZhdWx0VmFsdWUsIG9uQ2hhbmdlKSB7XHJcbiAgICBsZXQgW3N0YXRlVmFsdWUsIHNldFN0YXRlVmFsdWVdID0gKDAsICQ2aW11aCR1c2VTdGF0ZSkodmFsdWUgfHwgZGVmYXVsdFZhbHVlKTtcclxuICAgIGxldCBpc0NvbnRyb2xsZWRSZWYgPSAoMCwgJDZpbXVoJHVzZVJlZikodmFsdWUgIT09IHVuZGVmaW5lZCk7XHJcbiAgICBsZXQgaXNDb250cm9sbGVkID0gdmFsdWUgIT09IHVuZGVmaW5lZDtcclxuICAgICgwLCAkNmltdWgkdXNlRWZmZWN0KSgoKT0+e1xyXG4gICAgICAgIGxldCB3YXNDb250cm9sbGVkID0gaXNDb250cm9sbGVkUmVmLmN1cnJlbnQ7XHJcbiAgICAgICAgaWYgKHdhc0NvbnRyb2xsZWQgIT09IGlzQ29udHJvbGxlZCkgY29uc29sZS53YXJuKGBXQVJOOiBBIGNvbXBvbmVudCBjaGFuZ2VkIGZyb20gJHt3YXNDb250cm9sbGVkID8gXCJjb250cm9sbGVkXCIgOiBcInVuY29udHJvbGxlZFwifSB0byAke2lzQ29udHJvbGxlZCA/IFwiY29udHJvbGxlZFwiIDogXCJ1bmNvbnRyb2xsZWRcIn0uYCk7XHJcbiAgICAgICAgaXNDb250cm9sbGVkUmVmLmN1cnJlbnQgPSBpc0NvbnRyb2xsZWQ7XHJcbiAgICB9LCBbXHJcbiAgICAgICAgaXNDb250cm9sbGVkXHJcbiAgICBdKTtcclxuICAgIGxldCBjdXJyZW50VmFsdWUgPSBpc0NvbnRyb2xsZWQgPyB2YWx1ZSA6IHN0YXRlVmFsdWU7XHJcbiAgICBsZXQgc2V0VmFsdWUgPSAoMCwgJDZpbXVoJHVzZUNhbGxiYWNrKSgodmFsdWUsIC4uLmFyZ3MpPT57XHJcbiAgICAgICAgbGV0IG9uQ2hhbmdlQ2FsbGVyID0gKHZhbHVlLCAuLi5vbkNoYW5nZUFyZ3MpPT57XHJcbiAgICAgICAgICAgIGlmIChvbkNoYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFPYmplY3QuaXMoY3VycmVudFZhbHVlLCB2YWx1ZSkpIG9uQ2hhbmdlKHZhbHVlLCAuLi5vbkNoYW5nZUFyZ3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghaXNDb250cm9sbGVkKSAvLyBJZiB1bmNvbnRyb2xsZWQsIG11dGF0ZSB0aGUgY3VycmVudFZhbHVlIGxvY2FsIHZhcmlhYmxlIHNvIHRoYXRcclxuICAgICAgICAgICAgLy8gY2FsbGluZyBzZXRTdGF0ZSBtdWx0aXBsZSB0aW1lcyB3aXRoIHRoZSBzYW1lIHZhbHVlIG9ubHkgZW1pdHMgb25DaGFuZ2Ugb25jZS5cclxuICAgICAgICAgICAgLy8gV2UgZG8gbm90IHVzZSBhIHJlZiBmb3IgdGhpcyBiZWNhdXNlIHdlIHNwZWNpZmljYWxseSBfZG9fIHdhbnQgdGhlIHZhbHVlIHRvXHJcbiAgICAgICAgICAgIC8vIHJlc2V0IGV2ZXJ5IHJlbmRlciwgYW5kIGFzc2lnbmluZyB0byBhIHJlZiBpbiByZW5kZXIgYnJlYWtzIGFib3J0ZWQgc3VzcGVuZGVkIHJlbmRlcnMuXHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcclxuICAgICAgICAgICAgY3VycmVudFZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiV2UgY2FuIG5vdCBzdXBwb3J0IGEgZnVuY3Rpb24gY2FsbGJhY2suIFNlZSBHaXRodWIgSXNzdWVzIGZvciBkZXRhaWxzIGh0dHBzOi8vZ2l0aHViLmNvbS9hZG9iZS9yZWFjdC1zcGVjdHJ1bS9pc3N1ZXMvMjMyMFwiKTtcclxuICAgICAgICAgICAgLy8gdGhpcyBzdXBwb3J0cyBmdW5jdGlvbmFsIHVwZGF0ZXMgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL2hvb2tzLXJlZmVyZW5jZS5odG1sI2Z1bmN0aW9uYWwtdXBkYXRlc1xyXG4gICAgICAgICAgICAvLyB3aGVuIHNvbWVvbmUgdXNpbmcgdXNlQ29udHJvbGxlZFN0YXRlIGNhbGxzIHNldENvbnRyb2xsZWRTdGF0ZShteUZ1bmMpXHJcbiAgICAgICAgICAgIC8vIHRoaXMgd2lsbCBjYWxsIG91ciB1c2VTdGF0ZSBzZXRTdGF0ZSB3aXRoIGEgZnVuY3Rpb24gYXMgd2VsbCB3aGljaCBpbnZva2VzIG15RnVuYyBhbmQgY2FsbHMgb25DaGFuZ2Ugd2l0aCB0aGUgdmFsdWUgZnJvbSBteUZ1bmNcclxuICAgICAgICAgICAgLy8gaWYgd2UncmUgaW4gYW4gdW5jb250cm9sbGVkIHN0YXRlLCB0aGVuIHdlIGFsc28gcmV0dXJuIHRoZSB2YWx1ZSBvZiBteUZ1bmMgd2hpY2ggdG8gc2V0U3RhdGUgbG9va3MgYXMgdGhvdWdoIGl0IHdhcyBqdXN0IGNhbGxlZCB3aXRoIG15RnVuYyBmcm9tIHRoZSBiZWdpbm5pbmdcclxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIHdlIGp1c3QgcmV0dXJuIHRoZSBjb250cm9sbGVkIHZhbHVlLCB3aGljaCB3b24ndCBjYXVzZSBhIHJlcmVuZGVyIGJlY2F1c2UgUmVhY3Qga25vd3MgdG8gYmFpbCBvdXQgd2hlbiB0aGUgdmFsdWUgaXMgdGhlIHNhbWVcclxuICAgICAgICAgICAgbGV0IHVwZGF0ZUZ1bmN0aW9uID0gKG9sZFZhbHVlLCAuLi5mdW5jdGlvbkFyZ3MpPT57XHJcbiAgICAgICAgICAgICAgICBsZXQgaW50ZXJjZXB0ZWRWYWx1ZSA9IHZhbHVlKGlzQ29udHJvbGxlZCA/IGN1cnJlbnRWYWx1ZSA6IG9sZFZhbHVlLCAuLi5mdW5jdGlvbkFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgb25DaGFuZ2VDYWxsZXIoaW50ZXJjZXB0ZWRWYWx1ZSwgLi4uYXJncyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzQ29udHJvbGxlZCkgcmV0dXJuIGludGVyY2VwdGVkVmFsdWU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb2xkVmFsdWU7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHNldFN0YXRlVmFsdWUodXBkYXRlRnVuY3Rpb24pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICghaXNDb250cm9sbGVkKSBzZXRTdGF0ZVZhbHVlKHZhbHVlKTtcclxuICAgICAgICAgICAgb25DaGFuZ2VDYWxsZXIodmFsdWUsIC4uLmFyZ3MpO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFtcclxuICAgICAgICBpc0NvbnRyb2xsZWQsXHJcbiAgICAgICAgY3VycmVudFZhbHVlLFxyXG4gICAgICAgIG9uQ2hhbmdlXHJcbiAgICBdKTtcclxuICAgIHJldHVybiBbXHJcbiAgICAgICAgY3VycmVudFZhbHVlLFxyXG4gICAgICAgIHNldFZhbHVlXHJcbiAgICBdO1xyXG59XHJcblxyXG5cclxuLypcclxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcclxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXHJcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxyXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi8gLyoqXHJcbiAqIFRha2VzIGEgdmFsdWUgYW5kIGZvcmNlcyBpdCB0byB0aGUgY2xvc2VzdCBtaW4vbWF4IGlmIGl0J3Mgb3V0c2lkZS4gQWxzbyBmb3JjZXMgaXQgdG8gdGhlIGNsb3Nlc3QgdmFsaWQgc3RlcC5cclxuICovIGZ1bmN0aW9uICQ5NDQ2Y2NhOWEzODc1MTQ2JGV4cG9ydCQ3ZDE1YjY0Y2Y1YTNhNGM0KHZhbHVlLCBtaW4gPSAtSW5maW5pdHksIG1heCA9IEluZmluaXR5KSB7XHJcbiAgICBsZXQgbmV3VmFsdWUgPSBNYXRoLm1pbihNYXRoLm1heCh2YWx1ZSwgbWluKSwgbWF4KTtcclxuICAgIHJldHVybiBuZXdWYWx1ZTtcclxufVxyXG5mdW5jdGlvbiAkOTQ0NmNjYTlhMzg3NTE0NiRleHBvcnQkY2I2ZTBiYjUwYmMxOTQ2Myh2YWx1ZSwgbWluLCBtYXgsIHN0ZXApIHtcclxuICAgIG1pbiA9IE51bWJlcihtaW4pO1xyXG4gICAgbWF4ID0gTnVtYmVyKG1heCk7XHJcbiAgICBsZXQgcmVtYWluZGVyID0gKHZhbHVlIC0gKGlzTmFOKG1pbikgPyAwIDogbWluKSkgJSBzdGVwO1xyXG4gICAgbGV0IHNuYXBwZWRWYWx1ZSA9IE1hdGguYWJzKHJlbWFpbmRlcikgKiAyID49IHN0ZXAgPyB2YWx1ZSArIE1hdGguc2lnbihyZW1haW5kZXIpICogKHN0ZXAgLSBNYXRoLmFicyhyZW1haW5kZXIpKSA6IHZhbHVlIC0gcmVtYWluZGVyO1xyXG4gICAgaWYgKCFpc05hTihtaW4pKSB7XHJcbiAgICAgICAgaWYgKHNuYXBwZWRWYWx1ZSA8IG1pbikgc25hcHBlZFZhbHVlID0gbWluO1xyXG4gICAgICAgIGVsc2UgaWYgKCFpc05hTihtYXgpICYmIHNuYXBwZWRWYWx1ZSA+IG1heCkgc25hcHBlZFZhbHVlID0gbWluICsgTWF0aC5mbG9vcigobWF4IC0gbWluKSAvIHN0ZXApICogc3RlcDtcclxuICAgIH0gZWxzZSBpZiAoIWlzTmFOKG1heCkgJiYgc25hcHBlZFZhbHVlID4gbWF4KSBzbmFwcGVkVmFsdWUgPSBNYXRoLmZsb29yKG1heCAvIHN0ZXApICogc3RlcDtcclxuICAgIC8vIGNvcnJlY3QgZmxvYXRpbmcgcG9pbnQgYmVoYXZpb3IgYnkgcm91bmRpbmcgdG8gc3RlcCBwcmVjaXNpb25cclxuICAgIGxldCBzdHJpbmcgPSBzdGVwLnRvU3RyaW5nKCk7XHJcbiAgICBsZXQgaW5kZXggPSBzdHJpbmcuaW5kZXhPZihcIi5cIik7XHJcbiAgICBsZXQgcHJlY2lzaW9uID0gaW5kZXggPj0gMCA/IHN0cmluZy5sZW5ndGggLSBpbmRleCA6IDA7XHJcbiAgICBpZiAocHJlY2lzaW9uID4gMCkge1xyXG4gICAgICAgIGxldCBwb3cgPSBNYXRoLnBvdygxMCwgcHJlY2lzaW9uKTtcclxuICAgICAgICBzbmFwcGVkVmFsdWUgPSBNYXRoLnJvdW5kKHNuYXBwZWRWYWx1ZSAqIHBvdykgLyBwb3c7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc25hcHBlZFZhbHVlO1xyXG59XHJcbmZ1bmN0aW9uICQ5NDQ2Y2NhOWEzODc1MTQ2JGV4cG9ydCRiNjI2ODU1NGZiYTQ1MWYodmFsdWUsIGRpZ2l0cywgYmFzZSA9IDEwKSB7XHJcbiAgICBjb25zdCBwb3cgPSBNYXRoLnBvdyhiYXNlLCBkaWdpdHMpO1xyXG4gICAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgKiBwb3cpIC8gcG93O1xyXG59XHJcblxyXG5cclxuXHJcblxyXG5leHBvcnQgeyQ0NThiMGE1NTM2YzFhN2NmJGV4cG9ydCQ0MGJmYThjN2IwODMyNzE1IGFzIHVzZUNvbnRyb2xsZWRTdGF0ZSwgJDk0NDZjY2E5YTM4NzUxNDYkZXhwb3J0JDdkMTViNjRjZjVhM2E0YzQgYXMgY2xhbXAsICQ5NDQ2Y2NhOWEzODc1MTQ2JGV4cG9ydCRjYjZlMGJiNTBiYzE5NDYzIGFzIHNuYXBWYWx1ZVRvU3RlcCwgJDk0NDZjY2E5YTM4NzUxNDYkZXhwb3J0JGI2MjY4NTU0ZmJhNDUxZiBhcyB0b0ZpeGVkTnVtYmVyfTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxlLmpzLm1hcFxyXG4iXSwibmFtZXMiOlsidXNlU3RhdGUiLCIkNmltdWgkdXNlU3RhdGUiLCJ1c2VSZWYiLCIkNmltdWgkdXNlUmVmIiwidXNlRWZmZWN0IiwiJDZpbXVoJHVzZUVmZmVjdCIsInVzZUNhbGxiYWNrIiwiJDZpbXVoJHVzZUNhbGxiYWNrIiwiJDQ1OGIwYTU1MzZjMWE3Y2YkZXhwb3J0JDQwYmZhOGM3YjA4MzI3MTUiLCJ2YWx1ZSIsImRlZmF1bHRWYWx1ZSIsIm9uQ2hhbmdlIiwic3RhdGVWYWx1ZSIsInNldFN0YXRlVmFsdWUiLCJpc0NvbnRyb2xsZWRSZWYiLCJ1bmRlZmluZWQiLCJpc0NvbnRyb2xsZWQiLCJ3YXNDb250cm9sbGVkIiwiY3VycmVudCIsImNvbnNvbGUiLCJ3YXJuIiwiY3VycmVudFZhbHVlIiwic2V0VmFsdWUiLCJhcmdzIiwib25DaGFuZ2VDYWxsZXIiLCJvbkNoYW5nZUFyZ3MiLCJPYmplY3QiLCJpcyIsInVwZGF0ZUZ1bmN0aW9uIiwib2xkVmFsdWUiLCJmdW5jdGlvbkFyZ3MiLCJpbnRlcmNlcHRlZFZhbHVlIiwiJDk0NDZjY2E5YTM4NzUxNDYkZXhwb3J0JDdkMTViNjRjZjVhM2E0YzQiLCJtaW4iLCJJbmZpbml0eSIsIm1heCIsIm5ld1ZhbHVlIiwiTWF0aCIsIiQ5NDQ2Y2NhOWEzODc1MTQ2JGV4cG9ydCRjYjZlMGJiNTBiYzE5NDYzIiwic3RlcCIsIk51bWJlciIsInJlbWFpbmRlciIsImlzTmFOIiwic25hcHBlZFZhbHVlIiwiYWJzIiwic2lnbiIsImZsb29yIiwic3RyaW5nIiwidG9TdHJpbmciLCJpbmRleCIsImluZGV4T2YiLCJwcmVjaXNpb24iLCJsZW5ndGgiLCJwb3ciLCJyb3VuZCIsIiQ5NDQ2Y2NhOWEzODc1MTQ2JGV4cG9ydCRiNjI2ODU1NGZiYTQ1MWYiLCJkaWdpdHMiLCJiYXNlIiwidXNlQ29udHJvbGxlZFN0YXRlIiwiY2xhbXAiLCJzbmFwVmFsdWVUb1N0ZXAiLCJ0b0ZpeGVkTnVtYmVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/virtualizer/dist/import.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@react-stately/virtualizer/dist/import.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Layout: () => (/* binding */ $c74cda7d31af1253$export$c84671f46d6a1ca),\n/* harmony export */   LayoutInfo: () => (/* binding */ $d7fd61009c21d0bb$export$7e0eeb9da702a085),\n/* harmony export */   Point: () => (/* binding */ $3041db3296945e6e$export$baf26146a414f24a),\n/* harmony export */   Rect: () => (/* binding */ $60423f92c7f9ad87$export$c79fc6492f3af13d),\n/* harmony export */   ReusableView: () => (/* binding */ $ad1d98aa8f0c31b4$export$1a5223887c560441),\n/* harmony export */   Size: () => (/* binding */ $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec),\n/* harmony export */   useVirtualizerState: () => (/* binding */ $fc0b13b484ac1194$export$1505db82fe357e65)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-aria/utils */ \"(ssr)/./node_modules/@react-aria/utils/dist/import.mjs\");\n\n\n/*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ /*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ class $c74cda7d31af1253$export$c84671f46d6a1ca {\n    /**\r\n   * Returns whether the layout should invalidate in response to\r\n   * visible rectangle changes. By default, it only invalidates\r\n   * when the collection view's size changes. Return true always\r\n   * to make the layout invalidate while scrolling (e.g. sticky headers).\r\n   */ shouldInvalidate(newRect, oldRect) {\n        // By default, invalidate when the size changes\n        return newRect.width !== oldRect.width || newRect.height !== oldRect.height;\n    }\n    /**\r\n   * This method allows the layout to perform any pre-computation\r\n   * it needs to in order to prepare {@link LayoutInfo}s for retrieval.\r\n   * Called by the collection view before {@link getVisibleLayoutInfos}\r\n   * or {@link getLayoutInfo} are called.\r\n   */ validate(invalidationContext) {}\n    /**\r\n   * Returns a {@link DragTarget} describing a view at the given point to be dragged.\r\n   * Return `null` to cancel the drag. The default implementation returns the view at the given point.\r\n   * @param point The point at which the drag occurred.\r\n   */ // getDragTarget(point: Point): DragTarget | null {\n    //   let target = this.virtualizer.keyAtPoint(point);\n    //   if (!target) {\n    //     return null;\n    //   }\n    //   return {\n    //     type: 'item',\n    //     key: target\n    //   };\n    // }\n    /**\r\n   * Returns a {@link DragTarget} object describing where a drop should occur. Return `null`\r\n   * to reject the drop. The dropped items will be inserted before the resulting target.\r\n   * @param point The point at which the drop occurred.\r\n   */ // getDropTarget(point: Point): DropTarget | null {\n    //   return null;\n    // }\n    /**\r\n   * Returns the starting attributes for an animated insertion.\r\n   * The view is animated from this {@link LayoutInfo} to the one returned by {@link getLayoutInfo}.\r\n   * The default implementation just returns its input.\r\n   *\r\n   * @param layoutInfo The proposed LayoutInfo for this view.\r\n   */ getInitialLayoutInfo(layoutInfo) {\n        return layoutInfo;\n    }\n    /**\r\n   * Returns the ending attributes for an animated removal.\r\n   * The view is animated from the {@link LayoutInfo} returned by {@link getLayoutInfo}\r\n   * to the one returned by this method. The default implementation returns its input.\r\n   *\r\n   * @param layoutInfo The original LayoutInfo for this view.\r\n   */ getFinalLayoutInfo(layoutInfo) {\n        return layoutInfo;\n    }\n}\n/*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ class $d7fd61009c21d0bb$export$7e0eeb9da702a085 {\n    /**\r\n   * Returns a copy of the LayoutInfo.\r\n   */ copy() {\n        let res = new $d7fd61009c21d0bb$export$7e0eeb9da702a085(this.type, this.key, this.rect.copy());\n        res.estimatedSize = this.estimatedSize;\n        res.opacity = this.opacity;\n        res.transform = this.transform;\n        res.parentKey = this.parentKey;\n        res.isSticky = this.isSticky;\n        res.zIndex = this.zIndex;\n        res.allowOverflow = this.allowOverflow;\n        return res;\n    }\n    /**\r\n   * @param type A string representing the view type. Should be `'item'` for item views.\r\n                            Other types are used by supplementary views.\r\n   * @param key The unique key for this view.\r\n   * @param rect The rectangle describing the size and position of this view.\r\n   */ constructor(type, key, rect){\n        this.type = type;\n        this.key = key;\n        this.parentKey = null;\n        this.rect = rect;\n        this.estimatedSize = false;\n        this.isSticky = false;\n        this.opacity = 1;\n        this.transform = null;\n        this.zIndex = 0;\n        this.allowOverflow = false;\n    }\n}\n/*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ class $3041db3296945e6e$export$baf26146a414f24a {\n    /**\r\n   * Returns a copy of this point.\r\n   */ copy() {\n        return new $3041db3296945e6e$export$baf26146a414f24a(this.x, this.y);\n    }\n    /**\r\n   * Checks if two points are equal.\r\n   */ equals(point) {\n        return this.x === point.x && this.y === point.y;\n    }\n    /**\r\n   * Returns true if this point is the origin.\r\n   */ isOrigin() {\n        return this.x === 0 && this.y === 0;\n    }\n    constructor(x = 0, y = 0){\n        this.x = x;\n        this.y = y;\n    }\n}\n/*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ class $60423f92c7f9ad87$export$c79fc6492f3af13d {\n    /**\r\n   * The maximum x-coordinate in the rectangle.\r\n   */ get maxX() {\n        return this.x + this.width;\n    }\n    /**\r\n   * The maximum y-coordinate in the rectangle.\r\n   */ get maxY() {\n        return this.y + this.height;\n    }\n    /**\r\n   * The area of the rectangle.\r\n   */ get area() {\n        return this.width * this.height;\n    }\n    /**\r\n   * The top left corner of the rectangle.\r\n   */ get topLeft() {\n        return new (0, $3041db3296945e6e$export$baf26146a414f24a)(this.x, this.y);\n    }\n    /**\r\n   * The top right corner of the rectangle.\r\n   */ get topRight() {\n        return new (0, $3041db3296945e6e$export$baf26146a414f24a)(this.maxX, this.y);\n    }\n    /**\r\n   * The bottom left corner of the rectangle.\r\n   */ get bottomLeft() {\n        return new (0, $3041db3296945e6e$export$baf26146a414f24a)(this.x, this.maxY);\n    }\n    /**\r\n   * The bottom right corner of the rectangle.\r\n   */ get bottomRight() {\n        return new (0, $3041db3296945e6e$export$baf26146a414f24a)(this.maxX, this.maxY);\n    }\n    /**\r\n   * Returns whether this rectangle intersects another rectangle.\r\n   * @param rect - The rectangle to check.\r\n   */ intersects(rect) {\n        return this.x <= rect.x + rect.width && rect.x <= this.x + this.width && this.y <= rect.y + rect.height && rect.y <= this.y + this.height;\n    }\n    /**\r\n   * Returns whether this rectangle fully contains another rectangle.\r\n   * @param rect - The rectangle to check.\r\n   */ containsRect(rect) {\n        return this.x <= rect.x && this.y <= rect.y && this.maxX >= rect.maxX && this.maxY >= rect.maxY;\n    }\n    /**\r\n   * Returns whether the rectangle contains the given point.\r\n   * @param point - The point to check.\r\n   */ containsPoint(point) {\n        return this.x <= point.x && this.y <= point.y && this.maxX >= point.x && this.maxY >= point.y;\n    }\n    /**\r\n   * Returns the first corner of this rectangle (from top to bottom, left to right)\r\n   * that is contained in the given rectangle, or null of the rectangles do not intersect.\r\n   * @param rect - The rectangle to check.\r\n   */ getCornerInRect(rect) {\n        for (let key of [\n            \"topLeft\",\n            \"topRight\",\n            \"bottomLeft\",\n            \"bottomRight\"\n        ]){\n            if (rect.containsPoint(this[key])) return key;\n        }\n        return null;\n    }\n    equals(rect) {\n        return rect.x === this.x && rect.y === this.y && rect.width === this.width && rect.height === this.height;\n    }\n    pointEquals(point) {\n        return this.x === point.x && this.y === point.y;\n    }\n    sizeEquals(size) {\n        return this.width === size.width && this.height === size.height;\n    }\n    /**\r\n   * Returns the union of this Rect and another.\r\n   */ union(other) {\n        let x = Math.min(this.x, other.x);\n        let y = Math.min(this.y, other.y);\n        let width = Math.max(this.maxX, other.maxX) - x;\n        let height = Math.max(this.maxY, other.maxY) - y;\n        return new $60423f92c7f9ad87$export$c79fc6492f3af13d(x, y, width, height);\n    }\n    /**\r\n   * Returns the intersection of this Rect with another.\r\n   * If the rectangles do not intersect, an all zero Rect is returned.\r\n   */ intersection(other) {\n        if (!this.intersects(other)) return new $60423f92c7f9ad87$export$c79fc6492f3af13d(0, 0, 0, 0);\n        let x = Math.max(this.x, other.x);\n        let y = Math.max(this.y, other.y);\n        return new $60423f92c7f9ad87$export$c79fc6492f3af13d(x, y, Math.min(this.maxX, other.maxX) - x, Math.min(this.maxY, other.maxY) - y);\n    }\n    /**\r\n   * Returns a copy of this rectangle.\r\n   */ copy() {\n        return new $60423f92c7f9ad87$export$c79fc6492f3af13d(this.x, this.y, this.width, this.height);\n    }\n    constructor(x = 0, y = 0, width = 0, height = 0){\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n    }\n}\n/*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ class $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec {\n    /**\r\n   * Returns a copy of this size.\r\n   */ copy() {\n        return new $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec(this.width, this.height);\n    }\n    /**\r\n   * Returns whether this size is equal to another one.\r\n   */ equals(other) {\n        return this.width === other.width && this.height === other.height;\n    }\n    /**\r\n   * The total area of the Size.\r\n   */ get area() {\n        return this.width * this.height;\n    }\n    constructor(width = 0, height = 0){\n        this.width = width;\n        this.height = height;\n    }\n}\n/*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ let $ad1d98aa8f0c31b4$var$KEY = 0;\nclass $ad1d98aa8f0c31b4$export$1a5223887c560441 {\n    /**\r\n   * Prepares the view for reuse. Called just before the view is removed from the DOM.\r\n   */ prepareForReuse() {\n        this.content = null;\n        this.rendered = null;\n        this.layoutInfo = null;\n    }\n    constructor(virtualizer){\n        this.virtualizer = virtualizer;\n        this.key = ++$ad1d98aa8f0c31b4$var$KEY;\n    }\n}\n/*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ /*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ /*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ // use high res timer if available\nlet $3eb131dcf37ad5f8$var$perf =  false ? 0 : null;\n// @ts-ignore\nlet $3eb131dcf37ad5f8$var$perfNow = $3eb131dcf37ad5f8$var$perf && ($3eb131dcf37ad5f8$var$perf.now || $3eb131dcf37ad5f8$var$perf.webkitNow || $3eb131dcf37ad5f8$var$perf.msNow || $3eb131dcf37ad5f8$var$perf.mozNow);\nlet $3eb131dcf37ad5f8$var$getTime = $3eb131dcf37ad5f8$var$perfNow ? $3eb131dcf37ad5f8$var$perfNow.bind($3eb131dcf37ad5f8$var$perf) : function() {\n    return Date.now ? Date.now() : new Date().getTime();\n};\nlet $3eb131dcf37ad5f8$var$fixTs;\nfunction $3eb131dcf37ad5f8$export$dc0b63720788090c(begin, end, duration, ease, fn) {\n    let canceled = false;\n    let raf_id;\n    let promise = new Promise((resolve)=>{\n        let start = $3eb131dcf37ad5f8$var$getTime();\n        let diffX = end.x - begin.x;\n        let diffY = end.y - begin.y;\n        raf_id = requestAnimationFrame(function run(t) {\n            // if we're using a high res timer, make sure timestamp is not the old epoch-based value.\n            // http://updates.html5rocks.com/2012/05/requestAnimationFrame-API-now-with-sub-millisecond-precision\n            if ($3eb131dcf37ad5f8$var$fixTs == null) $3eb131dcf37ad5f8$var$fixTs = t > 1e12 !== $3eb131dcf37ad5f8$var$getTime() > 1e12;\n            if ($3eb131dcf37ad5f8$var$fixTs) t = $3eb131dcf37ad5f8$var$getTime();\n            // check if we're done\n            let delta = t - start;\n            if (delta > duration) {\n                fn(end);\n                resolve();\n            } else {\n                // call frame callback after computing eased time and get the next frame\n                let proceed = fn(new (0, $3041db3296945e6e$export$baf26146a414f24a)(begin.x + diffX * ease(delta / duration), begin.y + diffY * ease(delta / duration)));\n                if (proceed !== false && !canceled) raf_id = requestAnimationFrame(run);\n            }\n        });\n    });\n    promise.cancel = function() {\n        canceled = true;\n        cancelAnimationFrame(raf_id);\n    };\n    return promise;\n}\nfunction $3eb131dcf37ad5f8$export$77860c106b4a6a2e(t) {\n    return t;\n}\nfunction $3eb131dcf37ad5f8$export$57636bb43b1ccbb0(t) {\n    return Math.sin(t * Math.PI / 2);\n}\n/*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ function $fc36f9a046a9ce79$export$37a26b283fd7740e(a, b) {\n    let res = new Set();\n    for (let key of a.keys())if (!b.has(key)) res.add(key);\n    return res;\n}\nfunction $fc36f9a046a9ce79$export$acaf96a27438246b(a, b) {\n    let toRemove = $fc36f9a046a9ce79$export$37a26b283fd7740e(a, b);\n    let toAdd = $fc36f9a046a9ce79$export$37a26b283fd7740e(b, a);\n    let toUpdate = new Set;\n    for (let key of a.keys())if (b.has(key)) toUpdate.add(key);\n    return {\n        toRemove: toRemove,\n        toAdd: toAdd,\n        toUpdate: toUpdate\n    };\n}\nfunction* $fc36f9a046a9ce79$export$cfc14088dfefce5f(...iterators) {\n    for (let iterator of iterators)yield* iterator;\n}\nfunction $fc36f9a046a9ce79$export$6897c284b6f9f4dc(object) {\n    let res = {};\n    for(let key in object)res[object[key]] = key;\n    return res;\n}\nfunction $fc36f9a046a9ce79$export$a8d0d0c8d1c5df64(a, b) {\n    if (a === b) return true;\n    if (a.size !== b.size) return false;\n    for (let key of a){\n        if (!b.has(key)) return false;\n    }\n    return true;\n}\n/*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ class $364191b3decf3697$var$RollingAverage {\n    addSample(sample) {\n        this.count++;\n        this.value += (sample - this.value) / this.count;\n    }\n    constructor(){\n        this.count = 0;\n        this.value = 0;\n    }\n}\nclass $364191b3decf3697$export$4455ee6afb38dcbb {\n    setVisibleRect(rect) {\n        let time = performance.now() - this.startTime;\n        if (time < 500) {\n            this.averageTime.addSample(time);\n            if (rect.x !== this.visibleRect.x && time > 0) this.velocity.x = (rect.x - this.visibleRect.x) / time;\n            if (rect.y !== this.visibleRect.y && time > 0) this.velocity.y = (rect.y - this.visibleRect.y) / time;\n        }\n        this.startTime = performance.now();\n        this.visibleRect = rect;\n    }\n    collectMetrics() {\n        let time = performance.now() - this.startTime;\n        if (time < 500) this.averagePerf.addSample(time);\n        if (this.visibleRect.height > 0) {\n            let o = Math.abs(this.velocity.y * (this.averageTime.value + this.averagePerf.value));\n            this.overscanY.addSample(o);\n        }\n        if (this.visibleRect.width > 0) {\n            let o = Math.abs(this.velocity.x * (this.averageTime.value + this.averagePerf.value));\n            this.overscanX.addSample(o);\n        }\n    }\n    getOverscannedRect() {\n        let overscanned = this.visibleRect.copy();\n        let overscanY = Math.round(Math.min(this.visibleRect.height * 2, this.overscanY.value) / 100) * 100;\n        if (this.velocity.y > 0) {\n            overscanned.y -= overscanY * 0.2;\n            overscanned.height += overscanY + overscanY * 0.2;\n        } else {\n            overscanned.y -= overscanY;\n            overscanned.height += overscanY + overscanY * 0.2;\n        }\n        let overscanX = Math.round(Math.min(this.visibleRect.width * 2, this.overscanX.value) / 100) * 100;\n        if (this.velocity.x > 0) {\n            overscanned.x -= overscanX * 0.2;\n            overscanned.width += overscanX + overscanX * 0.2;\n        } else {\n            overscanned.x -= overscanX;\n            overscanned.width += overscanX + overscanX * 0.2;\n        }\n        return overscanned;\n    }\n    constructor(){\n        this.startTime = 0;\n        this.averagePerf = new $364191b3decf3697$var$RollingAverage();\n        this.averageTime = new $364191b3decf3697$var$RollingAverage();\n        this.velocity = new (0, $3041db3296945e6e$export$baf26146a414f24a)(5, 5);\n        this.overscanX = new $364191b3decf3697$var$RollingAverage();\n        this.overscanY = new $364191b3decf3697$var$RollingAverage();\n        this.visibleRect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)();\n    }\n}\n/*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ class $8e135e531d8dcb66$export$febc5573c75cefb0 {\n    constructor(){\n        this.level = 0;\n        this.actions = [];\n        this.animated = true;\n        this.initialMap = new Map();\n        this.finalMap = new Map();\n        this.initialLayoutInfo = new Map();\n        this.finalLayoutInfo = new Map();\n        this.removed = new Map();\n        this.toRemove = new Map();\n    }\n}\nclass $38b9490c1cca8fc4$export$89be5a243e59c4b2 {\n    _setContentSize(size) {\n        this._contentSize = size;\n        this.delegate.setContentSize(size);\n    }\n    _setContentOffset(offset) {\n        let rect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(offset.x, offset.y, this._visibleRect.width, this._visibleRect.height);\n        this.delegate.setVisibleRect(rect);\n    }\n    /**\r\n   * Get the size of the scrollable content.\r\n   */ get contentSize() {\n        return this._contentSize;\n    }\n    /**\r\n   * Get the collection view's currently visible rectangle.\r\n   */ get visibleRect() {\n        return this._visibleRect;\n    }\n    /**\r\n   * Set the collection view's currently visible rectangle.\r\n   */ set visibleRect(rect) {\n        this._setVisibleRect(rect);\n    }\n    _setVisibleRect(rect, forceUpdate = false) {\n        let current = this._visibleRect;\n        // Ignore if the rects are equal\n        if (rect.equals(current)) return;\n        if (this.shouldOverscan) this._overscanManager.setVisibleRect(rect);\n        let shouldInvalidate = this.layout && this.layout.shouldInvalidate(rect, this._visibleRect);\n        this._resetAnimatedContentOffset();\n        this._visibleRect = rect;\n        if (shouldInvalidate) this.relayoutNow({\n            offsetChanged: !rect.pointEquals(current),\n            sizeChanged: !rect.sizeEquals(current)\n        });\n        else this.updateSubviews(forceUpdate);\n    }\n    get collection() {\n        return this._collection;\n    }\n    set collection(data) {\n        this._setData(data);\n    }\n    _setData(data) {\n        if (data === this._collection) return;\n        if (this._collection) this._runTransaction(()=>{\n            this._collection = data;\n        }, this.transitionDuration > 0);\n        else {\n            this._collection = data;\n            this.reloadData();\n        }\n    }\n    /**\r\n   * Reloads the data from the data source and relayouts the collection view.\r\n   * Does not animate any changes. Equivalent to re-assigning the same data source\r\n   * to the collection view.\r\n   */ reloadData() {\n        this.relayout({\n            contentChanged: true\n        });\n    }\n    /**\r\n   * Returns the item with the given key.\r\n   */ getItem(key) {\n        return this._collection ? this._collection.getItem(key) : null;\n    }\n    /** The set of persisted keys are always present in the DOM, even if not currently in view. */ get persistedKeys() {\n        return this._persistedKeys;\n    }\n    /** The set of persisted keys are always present in the DOM, even if not currently in view. */ set persistedKeys(persistedKeys) {\n        if (!(0, $fc36f9a046a9ce79$export$a8d0d0c8d1c5df64)(persistedKeys, this._persistedKeys)) {\n            this._persistedKeys = persistedKeys;\n            this.updateSubviews();\n        }\n    }\n    /** Returns whether the given key, or an ancestor, is persisted. */ isPersistedKey(key) {\n        // Quick check if the key is directly in the set of persisted keys.\n        if (this._persistedKeys.has(key)) return true;\n        // If not, check if the key is an ancestor of any of the persisted keys.\n        for (let k of this._persistedKeys)while(k != null){\n            let layoutInfo = this.layout.getLayoutInfo(k);\n            if (!layoutInfo) break;\n            k = layoutInfo.parentKey;\n            if (k === key) return true;\n        }\n        return false;\n    }\n    /**\r\n   * Get the collection view's layout.\r\n   */ get layout() {\n        return this._layout;\n    }\n    /**\r\n   * Set the collection view's layout.\r\n   */ set layout(layout) {\n        this.setLayout(layout);\n    }\n    /**\r\n   * Sets the collection view's layout, optionally with an animated transition\r\n   * from the current layout to the new layout.\r\n   * @param layout The layout to switch to.\r\n   * @param animated Whether to animate the layout change.\r\n   */ setLayout(layout, animated = false) {\n        if (layout === this._layout) return;\n        let applyLayout = ()=>{\n            if (this._layout) this._layout.virtualizer = null;\n            layout.virtualizer = this;\n            this._layout = layout;\n        };\n        if (animated) // We just set the layout inside a transaction action, which runs after the initial\n        // layout infos for the animation are retrieved from the previous layout. Then, the\n        // final layout infos are retrieved from the new layout, and animations occur.\n        this._runTransaction(applyLayout);\n        else {\n            applyLayout();\n            this.relayout();\n        }\n    }\n    _getReuseType(layoutInfo, content) {\n        if (layoutInfo.type === \"item\" && content) {\n            let type = this.delegate.getType ? this.delegate.getType(content) : \"item\";\n            let reuseType = type === \"item\" ? \"item\" : layoutInfo.type + \"_\" + type;\n            return {\n                type: type,\n                reuseType: reuseType\n            };\n        }\n        return {\n            type: layoutInfo.type,\n            reuseType: layoutInfo.type\n        };\n    }\n    getReusableView(layoutInfo) {\n        let content = this.getItem(layoutInfo.key);\n        let { reuseType: reuseType } = this._getReuseType(layoutInfo, content);\n        if (!this._reusableViews[reuseType]) this._reusableViews[reuseType] = [];\n        let reusable = this._reusableViews[reuseType];\n        let view = reusable.length > 0 ? reusable.pop() : new (0, $ad1d98aa8f0c31b4$export$1a5223887c560441)(this);\n        view.viewType = reuseType;\n        if (!this._animatedContentOffset.isOrigin()) {\n            layoutInfo = layoutInfo.copy();\n            layoutInfo.rect.x += this._animatedContentOffset.x;\n            layoutInfo.rect.y += this._animatedContentOffset.y;\n        }\n        view.layoutInfo = layoutInfo;\n        this._renderView(view);\n        return view;\n    }\n    _renderView(reusableView) {\n        let { type: type, key: key } = reusableView.layoutInfo;\n        reusableView.content = this.getItem(key);\n        reusableView.rendered = this._renderContent(type, reusableView.content);\n    }\n    _renderContent(type, content) {\n        let cached = this._renderedContent.get(content);\n        if (cached != null) return cached;\n        let rendered = this.delegate.renderView(type, content);\n        if (content) this._renderedContent.set(content, rendered);\n        return rendered;\n    }\n    /**\r\n   * Returns an array of all currently visible views, including both\r\n   * item views and supplementary views.\r\n   */ get visibleViews() {\n        return Array.from(this._visibleViews.values());\n    }\n    /**\r\n   * Gets the visible view for the given type and key. Returns null if\r\n   * the view is not currently visible.\r\n   *\r\n   * @param key The key of the view to retrieve.\r\n   */ getView(key) {\n        return this._visibleViews.get(key) || null;\n    }\n    /**\r\n   * Returns an array of visible views matching the given type.\r\n   * @param type The view type to find.\r\n   */ getViewsOfType(type) {\n        return this.visibleViews.filter((v)=>v.layoutInfo && v.layoutInfo.type === type);\n    }\n    /**\r\n   * Returns the key for the given view. Returns null\r\n   * if the view is not currently visible.\r\n   */ keyForView(view) {\n        if (view && view.layoutInfo) return view.layoutInfo.key;\n        return null;\n    }\n    /**\r\n   * Returns the key for the item view currently at the given point.\r\n   */ keyAtPoint(point) {\n        let rect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(point.x, point.y, 1, 1);\n        let layoutInfos = this.layout.getVisibleLayoutInfos(rect);\n        // Layout may return multiple layout infos in the case of\n        // persisted keys, so find the first one that actually intersects.\n        for (let layoutInfo of layoutInfos){\n            if (layoutInfo.rect.intersects(rect)) return layoutInfo.key;\n        }\n        return null;\n    }\n    /**\r\n   * Cleanup for when the Virtualizer will be unmounted.\r\n   */ willUnmount() {\n        cancelAnimationFrame(this._relayoutRaf);\n    }\n    /**\r\n   * Triggers a layout invalidation, and updates the visible subviews.\r\n   */ relayout(context = {}) {\n        // Ignore relayouts while animating the scroll position\n        if (this._scrollAnimation || typeof requestAnimationFrame === \"undefined\") return;\n        // If we already scheduled a relayout, extend the invalidation\n        // context so we coalesce multiple relayouts in the same frame.\n        if (this._invalidationContext) {\n            Object.assign(this._invalidationContext, context);\n            return;\n        }\n        this._invalidationContext = context;\n    }\n    /**\r\n   * Performs a relayout immediately. Prefer {@link relayout} over this method\r\n   * where possible, since it coalesces multiple layout passes in the same tick.\r\n   */ relayoutNow(context = this._invalidationContext || {}) {\n        // Cancel the scheduled relayout, since we're doing it now.\n        if (this._relayoutRaf) {\n            cancelAnimationFrame(this._relayoutRaf);\n            this._relayoutRaf = null;\n            // Update the provided context with the current invalidationContext since we are cancelling\n            // a scheduled relayoutNow call that has this._invalidationContext set as its default context arg (relayoutNow() in relayout)\n            context = {\n                ...this._invalidationContext,\n                ...context\n            };\n        }\n        // Reset the invalidation context\n        this._invalidationContext = null;\n        // Do nothing if we don't have a layout or content, or we are\n        // in the middle of an animated scroll transition.\n        if (!this.layout || !this._collection || this._scrollAnimation) return;\n        let scrollAnchor = this._getScrollAnchor();\n        // Trigger the beforeLayout hook, if provided\n        if (typeof context.beforeLayout === \"function\") context.beforeLayout();\n        // Validate the layout\n        this.layout.validate(context);\n        this._setContentSize(this.layout.getContentSize());\n        // Trigger the afterLayout hook, if provided\n        if (typeof context.afterLayout === \"function\") context.afterLayout();\n        // Adjust scroll position based on scroll anchor, and constrain.\n        // If the content changed, scroll to the top.\n        let visibleRect = this.getVisibleRect();\n        let restoredScrollAnchor = this._restoreScrollAnchor(scrollAnchor, context);\n        let contentOffsetX = context.contentChanged ? 0 : restoredScrollAnchor.x;\n        let contentOffsetY = context.contentChanged ? 0 : restoredScrollAnchor.y;\n        contentOffsetX = Math.max(0, Math.min(this.contentSize.width - visibleRect.width, contentOffsetX));\n        contentOffsetY = Math.max(0, Math.min(this.contentSize.height - visibleRect.height, contentOffsetY));\n        let hasLayoutUpdates = false;\n        if (contentOffsetX !== visibleRect.x || contentOffsetY !== visibleRect.y) {\n            // If this is an animated relayout, we do not immediately scroll because it would be jittery.\n            // Save the difference between the current and new content offsets, and apply it to the\n            // individual content items instead. At the end of the animation, we'll reset and set the\n            // scroll offset for real. This ensures jitter-free animation since we don't need to sync\n            // the scroll animation and the content animation.\n            if (context.animated || !this._animatedContentOffset.isOrigin()) {\n                this._animatedContentOffset.x += visibleRect.x - contentOffsetX;\n                this._animatedContentOffset.y += visibleRect.y - contentOffsetY;\n                hasLayoutUpdates = this.updateSubviews(context.contentChanged);\n            } else this._setContentOffset(new (0, $3041db3296945e6e$export$baf26146a414f24a)(contentOffsetX, contentOffsetY));\n        } else hasLayoutUpdates = this.updateSubviews(context.contentChanged);\n        // Apply layout infos, unless this is coming from an animated transaction\n        if (!(context.transaction && context.animated)) this._applyLayoutInfos();\n        // Wait for animations, and apply the afterAnimation hook, if provided\n        if (context.animated && hasLayoutUpdates) {\n            this._enableTransitions();\n            let done = ()=>{\n                this._disableTransitions();\n                // Reset scroll position after animations (see above comment).\n                if (!this._animatedContentOffset.isOrigin()) {\n                    // Get the content offset to scroll to, taking _animatedContentOffset into account.\n                    let { x: x, y: y } = this.getVisibleRect();\n                    this._resetAnimatedContentOffset();\n                    this._setContentOffset(new (0, $3041db3296945e6e$export$baf26146a414f24a)(x, y));\n                }\n                if (typeof context.afterAnimation === \"function\") context.afterAnimation();\n            };\n            // Sometimes the animation takes slightly longer than expected.\n            setTimeout(done, this.transitionDuration + 100);\n            return;\n        } else if (typeof context.afterAnimation === \"function\") context.afterAnimation();\n    }\n    /**\r\n   * Corrects DOM order of visible views to match item order of collection.\r\n   */ _correctItemOrder() {\n        // Defer until after scrolling and animated transactions are complete\n        if (this._isScrolling || this._transaction) return;\n        for (let key of this._visibleLayoutInfos.keys()){\n            let view = this._visibleViews.get(key);\n            this._children.delete(view);\n            this._children.add(view);\n        }\n    }\n    _enableTransitions() {\n        this.delegate.beginAnimations();\n    }\n    _disableTransitions() {\n        this.delegate.endAnimations();\n    }\n    _getScrollAnchor() {\n        if (!this.anchorScrollPosition) return null;\n        let visibleRect = this.getVisibleRect();\n        // Ask the delegate to provide a scroll anchor, if possible\n        if (this.delegate.getScrollAnchor) {\n            let key = this.delegate.getScrollAnchor(visibleRect);\n            if (key != null) {\n                let layoutInfo = this.layout.getLayoutInfo(key);\n                let corner = layoutInfo.rect.getCornerInRect(visibleRect);\n                if (corner) {\n                    let key = layoutInfo.key;\n                    let offset = layoutInfo.rect[corner].y - visibleRect.y;\n                    return {\n                        key: key,\n                        layoutInfo: layoutInfo,\n                        corner: corner,\n                        offset: offset\n                    };\n                }\n            }\n        }\n        // No need to anchor the scroll position if it is at the top\n        if (visibleRect.y === 0 && !this.anchorScrollPositionAtTop) return null;\n        // Find a view with a visible corner that has the smallest distance to the top of the collection view\n        let cornerAnchor = null;\n        for (let [key, view] of this._visibleViews){\n            let layoutInfo = view.layoutInfo;\n            if (layoutInfo && layoutInfo.rect.area > 0) {\n                let corner = layoutInfo.rect.getCornerInRect(visibleRect);\n                if (corner) {\n                    let offset = layoutInfo.rect[corner].y - visibleRect.y;\n                    if (!cornerAnchor || offset < cornerAnchor.offset) cornerAnchor = {\n                        key: key,\n                        layoutInfo: layoutInfo,\n                        corner: corner,\n                        offset: offset\n                    };\n                }\n            }\n        }\n        return cornerAnchor;\n    }\n    _restoreScrollAnchor(scrollAnchor, context) {\n        let contentOffset = this.getVisibleRect();\n        if (scrollAnchor) {\n            var _context_transaction;\n            let finalAnchor = ((_context_transaction = context.transaction) === null || _context_transaction === void 0 ? void 0 : _context_transaction.animated) ? context.transaction.finalMap.get(scrollAnchor.key) : this.layout.getLayoutInfo(scrollAnchor.layoutInfo.key);\n            if (finalAnchor) {\n                let adjustment = finalAnchor.rect[scrollAnchor.corner].y - contentOffset.y - scrollAnchor.offset;\n                contentOffset.y += adjustment;\n            }\n        }\n        return contentOffset;\n    }\n    getVisibleRect() {\n        let v = this.visibleRect;\n        let x = v.x - this._animatedContentOffset.x;\n        let y = v.y - this._animatedContentOffset.y;\n        return new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(x, y, v.width, v.height);\n    }\n    getVisibleLayoutInfos() {\n        let rect = this.shouldOverscan ? this._overscanManager.getOverscannedRect() : this.getVisibleRect();\n        this._visibleLayoutInfos = this._getLayoutInfoMap(rect);\n        return this._visibleLayoutInfos;\n    }\n    _getLayoutInfoMap(rect, copy = false) {\n        let layoutInfos = this.layout.getVisibleLayoutInfos(rect);\n        let map = new Map;\n        for (let layoutInfo of layoutInfos){\n            if (copy) layoutInfo = layoutInfo.copy();\n            map.set(layoutInfo.key, layoutInfo);\n        }\n        return map;\n    }\n    updateSubviews(forceUpdate = false) {\n        if (!this._collection) return;\n        let visibleLayoutInfos = this.getVisibleLayoutInfos();\n        let currentlyVisible = this._visibleViews;\n        let toAdd, toRemove, toUpdate;\n        // If this is a force update, remove and re-add all views.\n        // Otherwise, find and update the diff.\n        if (forceUpdate) {\n            toAdd = visibleLayoutInfos;\n            toRemove = currentlyVisible;\n            toUpdate = new Set();\n        } else {\n            ({ toAdd: toAdd, toRemove: toRemove, toUpdate: toUpdate } = (0, $fc36f9a046a9ce79$export$acaf96a27438246b)(currentlyVisible, visibleLayoutInfos));\n            for (let key of toUpdate){\n                let view = currentlyVisible.get(key);\n                if (!view || !view.layoutInfo) continue;\n                let item = this.getItem(visibleLayoutInfos.get(key).key);\n                if (view.content === item) toUpdate.delete(key);\n                else {\n                    // If the view type changes, delete and recreate the view instead of updating\n                    let { reuseType: reuseType } = this._getReuseType(view.layoutInfo, item);\n                    if (view.viewType !== reuseType) {\n                        toUpdate.delete(key);\n                        toAdd.add(key);\n                        toRemove.add(key);\n                    }\n                }\n            }\n            // We are done if the sets are equal\n            if (toAdd.size === 0 && toRemove.size === 0 && toUpdate.size === 0) {\n                if (this._transaction) this._applyLayoutInfos();\n                return;\n            }\n        }\n        // Track views that should be removed. They are not removed from\n        // the DOM immediately, since we may reuse and need to re-insert\n        // them back into the DOM anyway.\n        let removed = new Set();\n        for (let key of toRemove.keys()){\n            let view = this._visibleViews.get(key);\n            if (view) {\n                removed.add(view);\n                this._visibleViews.delete(key);\n                // If we are in the middle of a transaction, wait until the end\n                // of the animations to remove the views from the DOM. Also means\n                // we can't reuse those views immediately.\n                if (this._transaction) this._transaction.toRemove.set(key, view);\n                else this.reuseView(view);\n            }\n        }\n        for (let key of toAdd.keys()){\n            let layoutInfo = visibleLayoutInfos.get(key);\n            let view;\n            // If we're in a transaction, and a layout change happens\n            // during the animations such that a view that was going\n            // to be removed is now not, we don't create a new view\n            // since the old one is still in the DOM, marked as toRemove.\n            if (this._transaction) {\n                // if transaction, get initial layout attributes for the animation\n                if (this._transaction.initialLayoutInfo.has(key)) layoutInfo = this._transaction.initialLayoutInfo.get(key);\n                view = this._transaction.toRemove.get(key);\n                if (view) {\n                    this._transaction.toRemove.delete(key);\n                    this._applyLayoutInfo(view, layoutInfo);\n                }\n            }\n            if (!view) {\n                // Create or reuse a view for this row\n                view = this.getReusableView(layoutInfo);\n                // Add the view to the DOM if needed\n                if (!removed.has(view)) this._children.add(view);\n            }\n            this._visibleViews.set(key, view);\n            removed.delete(view);\n        }\n        for (let key of toUpdate){\n            let view = currentlyVisible.get(key);\n            this._renderedContent.delete(key);\n            this._renderView(view);\n        }\n        // Remove the remaining rows to delete from the DOM\n        if (!this._transaction) this.removeViews(removed);\n        this._correctItemOrder();\n        this._flushVisibleViews();\n        let hasLayoutUpdates = this._transaction && (toAdd.size > 0 || toRemove.size > 0 || this._hasLayoutUpdates());\n        if (hasLayoutUpdates) requestAnimationFrame(()=>{\n            // If we're in a transaction, apply animations to visible views\n            // and \"to be removed\" views, which animate off screen.\n            if (this._transaction) requestAnimationFrame(()=>this._applyLayoutInfos());\n        });\n        return hasLayoutUpdates;\n    }\n    afterRender() {\n        if (this._transactionQueue.length > 0) this._processTransactionQueue();\n        else if (this._invalidationContext) this.relayoutNow();\n        if (this.shouldOverscan) this._overscanManager.collectMetrics();\n    }\n    _flushVisibleViews() {\n        // CollectionVirtualizer deals with a flattened set of LayoutInfos, but they can represent heirarchy\n        // by referencing a parentKey. Just before rendering the visible views, we rebuild this heirarchy\n        // by creating a mapping of views by parent key and recursively calling the delegate's renderWrapper\n        // method to build the final tree.\n        let viewsByParentKey = new Map([\n            [\n                null,\n                []\n            ]\n        ]);\n        for (let view of this._children){\n            var _view_layoutInfo, _viewsByParentKey_get, _view_layoutInfo1, _view_layoutInfo2, _view_layoutInfo3;\n            if (((_view_layoutInfo = view.layoutInfo) === null || _view_layoutInfo === void 0 ? void 0 : _view_layoutInfo.parentKey) != null && !viewsByParentKey.has(view.layoutInfo.parentKey)) viewsByParentKey.set(view.layoutInfo.parentKey, []);\n            (_viewsByParentKey_get = viewsByParentKey.get((_view_layoutInfo1 = view.layoutInfo) === null || _view_layoutInfo1 === void 0 ? void 0 : _view_layoutInfo1.parentKey)) === null || _viewsByParentKey_get === void 0 ? void 0 : _viewsByParentKey_get.push(view);\n            if (!viewsByParentKey.has((_view_layoutInfo2 = view.layoutInfo) === null || _view_layoutInfo2 === void 0 ? void 0 : _view_layoutInfo2.key)) viewsByParentKey.set((_view_layoutInfo3 = view.layoutInfo) === null || _view_layoutInfo3 === void 0 ? void 0 : _view_layoutInfo3.key, []);\n        }\n        let buildTree = (parent, views)=>views.map((view)=>{\n                let children = viewsByParentKey.get(view.layoutInfo.key);\n                return this.delegate.renderWrapper(parent, view, children, (childViews)=>buildTree(view, childViews));\n            });\n        let children = buildTree(null, viewsByParentKey.get(null));\n        this.delegate.setVisibleViews(children);\n    }\n    _applyLayoutInfo(view, layoutInfo) {\n        if (view.layoutInfo === layoutInfo) return false;\n        view.layoutInfo = layoutInfo;\n        return true;\n    }\n    _applyLayoutInfos() {\n        let updated = false;\n        // Apply layout infos to visible views\n        for (let view of this._visibleViews.values()){\n            let cur = view.layoutInfo;\n            if ((cur === null || cur === void 0 ? void 0 : cur.key) != null) {\n                let layoutInfo = this.layout.getLayoutInfo(cur.key);\n                if (this._applyLayoutInfo(view, layoutInfo)) updated = true;\n            }\n        }\n        // Apply final layout infos for views that will be removed\n        if (this._transaction) {\n            for (let view of this._transaction.toRemove.values()){\n                let cur = view.layoutInfo;\n                if ((cur === null || cur === void 0 ? void 0 : cur.key) != null) {\n                    let layoutInfo = this.layout.getLayoutInfo(cur.key);\n                    if (this._applyLayoutInfo(view, layoutInfo)) updated = true;\n                }\n            }\n            for (let view of this._transaction.removed.values()){\n                let cur = view.layoutInfo;\n                let layoutInfo = this._transaction.finalLayoutInfo.get(cur.key) || cur;\n                layoutInfo = this.layout.getFinalLayoutInfo(layoutInfo.copy());\n                if (this._applyLayoutInfo(view, layoutInfo)) updated = true;\n            }\n        }\n        if (updated) this._flushVisibleViews();\n    }\n    _hasLayoutUpdates() {\n        if (!this._transaction) return false;\n        for (let view of this._visibleViews.values()){\n            let cur = view.layoutInfo;\n            if (!cur) return true;\n            let layoutInfo = this.layout.getLayoutInfo(cur.key);\n            if (!cur.rect.equals(layoutInfo.rect) || cur.opacity !== layoutInfo.opacity || cur.transform !== layoutInfo.transform) return true;\n        }\n        return false;\n    }\n    reuseView(view) {\n        view.prepareForReuse();\n        this._reusableViews[view.viewType].push(view);\n    }\n    removeViews(toRemove) {\n        for (let view of toRemove)this._children.delete(view);\n    }\n    updateItemSize(key, size) {\n        // TODO: we should be able to invalidate a single index path\n        // @ts-ignore\n        if (!this.layout.updateItemSize) return;\n        // If the scroll position is currently animating, add the update\n        // to a queue to be processed after the animation is complete.\n        if (this._scrollAnimation) {\n            this._sizeUpdateQueue.set(key, size);\n            return;\n        }\n        // @ts-ignore\n        let changed = this.layout.updateItemSize(key, size);\n        if (changed) this.relayout();\n    }\n    startScrolling() {\n        this._isScrolling = true;\n    }\n    endScrolling() {\n        this._isScrolling = false;\n        this._correctItemOrder();\n        this._flushVisibleViews();\n    }\n    _resetAnimatedContentOffset() {\n        // Reset the animated content offset of subviews. See comment in relayoutNow for details.\n        if (!this._animatedContentOffset.isOrigin()) {\n            this._animatedContentOffset = new (0, $3041db3296945e6e$export$baf26146a414f24a)(0, 0);\n            this._applyLayoutInfos();\n        }\n    }\n    /**\r\n   * Scrolls the item with the given key into view, optionally with an animation.\r\n   * @param key The key of the item to scroll into view.\r\n   * @param duration The duration of the scroll animation.\r\n   */ scrollToItem(key, options) {\n        // key can be 0, so check if null or undefined\n        if (key == null) return;\n        let layoutInfo = this.layout.getLayoutInfo(key);\n        if (!layoutInfo) return;\n        let { duration: duration = 300, shouldScrollX: shouldScrollX = true, shouldScrollY: shouldScrollY = true, offsetX: offsetX = 0, offsetY: offsetY = 0 } = options;\n        let x = this.visibleRect.x;\n        let y = this.visibleRect.y;\n        let minX = layoutInfo.rect.x - offsetX;\n        let minY = layoutInfo.rect.y - offsetY;\n        let maxX = x + this.visibleRect.width;\n        let maxY = y + this.visibleRect.height;\n        if (shouldScrollX) {\n            if (minX <= x || maxX === 0) x = minX;\n            else if (layoutInfo.rect.maxX > maxX) x += layoutInfo.rect.maxX - maxX;\n        }\n        if (shouldScrollY) {\n            if (minY <= y || maxY === 0) y = minY;\n            else if (layoutInfo.rect.maxY > maxY) y += layoutInfo.rect.maxY - maxY;\n        }\n        return this.scrollTo(new (0, $3041db3296945e6e$export$baf26146a414f24a)(x, y), duration);\n    }\n    /**\r\n   * Performs an animated scroll to the given offset.\r\n   * @param offset - The offset to scroll to.\r\n   * @param duration The duration of the animation.\r\n   * @returns A promise that resolves when the animation is complete.\r\n   */ scrollTo(offset, duration = 300) {\n        // Cancel the current scroll animation\n        if (this._scrollAnimation) {\n            this._scrollAnimation.cancel();\n            this._scrollAnimation = null;\n        }\n        // Set the content offset synchronously if the duration is zero\n        if (duration <= 0 || this.visibleRect.pointEquals(offset)) {\n            this._setContentOffset(offset);\n            return Promise.resolve();\n        }\n        this.startScrolling();\n        this._scrollAnimation = (0, $3eb131dcf37ad5f8$export$dc0b63720788090c)(this.visibleRect, offset, duration, (0, $3eb131dcf37ad5f8$export$57636bb43b1ccbb0), (offset)=>{\n            this._setContentOffset(offset);\n        });\n        this._scrollAnimation.then(()=>{\n            this._scrollAnimation = null;\n            // Process view size updates that occurred during the animation.\n            // Only views that are still visible will be actually updated.\n            for (let [key, size] of this._sizeUpdateQueue)this.updateItemSize(key, size);\n            this._sizeUpdateQueue.clear();\n            this.relayout();\n            this._processTransactionQueue();\n            this.endScrolling();\n        });\n        return this._scrollAnimation;\n    }\n    _runTransaction(action, animated) {\n        this._startTransaction();\n        if (this._nextTransaction) this._nextTransaction.actions.push(action);\n        this._endTransaction(animated);\n    }\n    _startTransaction() {\n        if (!this._nextTransaction) this._nextTransaction = new (0, $8e135e531d8dcb66$export$febc5573c75cefb0);\n        this._nextTransaction.level++;\n    }\n    _endTransaction(animated) {\n        if (!this._nextTransaction) return false;\n        // Save whether the transaction should be animated.\n        if (animated != null) this._nextTransaction.animated = animated;\n        // If we haven't reached level 0, we are still in a\n        // nested transaction. Wait for the parent to end.\n        if (--this._nextTransaction.level > 0) return false;\n        // Do nothing for empty transactions\n        if (this._nextTransaction.actions.length === 0) {\n            this._nextTransaction = null;\n            return false;\n        }\n        // Default animations to true\n        if (this._nextTransaction.animated == null) this._nextTransaction.animated = true;\n        // Enqueue the transaction\n        this._transactionQueue.push(this._nextTransaction);\n        this._nextTransaction = null;\n        return true;\n    }\n    _processTransactionQueue() {\n        // If the current transaction is animating, wait until the end\n        // to process the next transaction.\n        if (this._transaction || this._scrollAnimation) return;\n        let next = this._transactionQueue.shift();\n        if (next) this._performTransaction(next);\n    }\n    _getContentRect() {\n        return new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(0, 0, this.contentSize.width, this.contentSize.height);\n    }\n    _performTransaction(transaction) {\n        this._transaction = transaction;\n        this.relayoutNow({\n            transaction: transaction,\n            animated: transaction.animated,\n            beforeLayout: ()=>{\n                // Get the initial layout infos for all views before the updates\n                // so we can figure out which views to add and remove.\n                if (transaction.animated) transaction.initialMap = this._getLayoutInfoMap(this._getContentRect(), true);\n                // Apply the actions that occurred during this transaction\n                for (let action of transaction.actions)action();\n            },\n            afterLayout: ()=>{\n                // Get the final layout infos after the updates\n                if (transaction.animated) {\n                    transaction.finalMap = this._getLayoutInfoMap(this._getContentRect());\n                    this._setupTransactionAnimations(transaction);\n                } else this._transaction = null;\n            },\n            afterAnimation: ()=>{\n                // Remove and reuse views when animations are done\n                if (transaction.toRemove.size > 0 || transaction.removed.size > 0) for (let view of (0, $fc36f9a046a9ce79$export$cfc14088dfefce5f)(transaction.toRemove.values(), transaction.removed.values())){\n                    this._children.delete(view);\n                    this.reuseView(view);\n                }\n                this._transaction = null;\n                // Ensure DOM order is correct for accessibility after animations are complete\n                this._correctItemOrder();\n                this._flushVisibleViews();\n                this._processTransactionQueue();\n            }\n        });\n    }\n    _setupTransactionAnimations(transaction) {\n        let { initialMap: initialMap, finalMap: finalMap } = transaction;\n        // Store initial and final layout infos for animations\n        for (let [key, layoutInfo] of initialMap)if (finalMap.has(key)) transaction.initialLayoutInfo.set(key, layoutInfo);\n        else // in Layout#getFinalLayoutInfo during animations.\n        transaction.finalLayoutInfo.set(layoutInfo.key, layoutInfo);\n        // Get initial layout infos for views that were added\n        for (let [key, layoutInfo] of finalMap)if (!initialMap.has(key)) {\n            let initialLayoutInfo = this.layout.getInitialLayoutInfo(layoutInfo.copy());\n            transaction.initialLayoutInfo.set(key, initialLayoutInfo);\n        }\n        // Figure out which views were removed.\n        for (let [key, view] of this._visibleViews)// Removing an item with  width of 0 can cause a loop where the item gets added, removed,\n        // added, removed... etc in a loop.\n        if (!finalMap.has(key) && view.layoutInfo.rect.width > 0) {\n            transaction.removed.set(key, view);\n            this._visibleViews.delete(key);\n            // In case something weird happened, where we have a view but no\n            // initial layout info, use the one attached to the view.\n            if (view.layoutInfo) {\n                if (!transaction.finalLayoutInfo.has(view.layoutInfo.key)) transaction.finalLayoutInfo.set(view.layoutInfo.key, view.layoutInfo);\n            }\n        }\n    }\n    constructor(options = {}){\n        this._contentSize = new (0, $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec);\n        this._visibleRect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d);\n        this._reusableViews = {};\n        this._visibleLayoutInfos = new Map();\n        this._visibleViews = new Map();\n        this._renderedContent = new WeakMap();\n        this._children = new Set();\n        this._invalidationContext = null;\n        this._overscanManager = new (0, $364191b3decf3697$export$4455ee6afb38dcbb)();\n        this._persistedKeys = new Set();\n        this._scrollAnimation = null;\n        this._isScrolling = false;\n        this._sizeUpdateQueue = new Map();\n        this._animatedContentOffset = new (0, $3041db3296945e6e$export$baf26146a414f24a)(0, 0);\n        this._transaction = null;\n        this._nextTransaction = null;\n        this._transactionQueue = [];\n        var _options_transitionDuration;\n        // Set options from passed object if given\n        this.transitionDuration = (_options_transitionDuration = options.transitionDuration) !== null && _options_transitionDuration !== void 0 ? _options_transitionDuration : 500;\n        this.anchorScrollPosition = options.anchorScrollPosition || false;\n        this.anchorScrollPositionAtTop = options.anchorScrollPositionAtTop || false;\n        this.shouldOverscan = options.shouldOverscan !== false;\n        for (let key of [\n            \"delegate\",\n            \"size\",\n            \"layout\",\n            \"collection\"\n        ])if (options[key]) this[key] = options[key];\n    }\n}\nfunction $fc0b13b484ac1194$export$1505db82fe357e65(opts) {\n    let [visibleViews, setVisibleViews] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    let [contentSize, setContentSize] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(new (0, $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec)());\n    let [isAnimating, setAnimating] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    let [isScrolling, setScrolling] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    let virtualizer = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>new (0, $38b9490c1cca8fc4$export$89be5a243e59c4b2)(), []);\n    virtualizer.delegate = {\n        setVisibleViews: setVisibleViews,\n        setVisibleRect (rect) {\n            virtualizer.visibleRect = rect;\n            opts.onVisibleRectChange(rect);\n        },\n        setContentSize: setContentSize,\n        renderView: opts.renderView,\n        renderWrapper: opts.renderWrapper,\n        beginAnimations: ()=>setAnimating(true),\n        endAnimations: ()=>setAnimating(false),\n        getScrollAnchor: opts.getScrollAnchor\n    };\n    virtualizer.layout = opts.layout;\n    virtualizer.collection = opts.collection;\n    virtualizer.transitionDuration = opts.transitionDuration;\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect)(()=>{\n        virtualizer.afterRender();\n    });\n    // eslint-disable-next-line arrow-body-style\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return ()=>virtualizer.willUnmount();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    let setVisibleRect = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((rect)=>{\n        virtualizer.visibleRect = rect;\n    }, [\n        virtualizer\n    ]);\n    let startScrolling = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        virtualizer.startScrolling();\n        setScrolling(true);\n    }, [\n        virtualizer\n    ]);\n    let endScrolling = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        virtualizer.endScrolling();\n        setScrolling(false);\n    }, [\n        virtualizer\n    ]);\n    let state = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            virtualizer: virtualizer,\n            visibleViews: visibleViews,\n            setVisibleRect: setVisibleRect,\n            contentSize: contentSize,\n            isAnimating: isAnimating,\n            isScrolling: isScrolling,\n            startScrolling: startScrolling,\n            endScrolling: endScrolling\n        }), [\n        virtualizer,\n        visibleViews,\n        setVisibleRect,\n        contentSize,\n        isAnimating,\n        isScrolling,\n        startScrolling,\n        endScrolling\n    ]);\n    return state;\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvdmlydHVhbGl6ZXIvZGlzdC9pbXBvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUErSTtBQUNuRTtBQUU1RTs7Ozs7Ozs7OztDQVVDLEdBQUc7Ozs7Ozs7Ozs7Q0FVSCxHQUFHLE1BQU1VO0lBQ047Ozs7O0dBS0QsR0FBR0MsaUJBQWlCQyxPQUFPLEVBQUVDLE9BQU8sRUFBRTtRQUNqQywrQ0FBK0M7UUFDL0MsT0FBT0QsUUFBUUUsS0FBSyxLQUFLRCxRQUFRQyxLQUFLLElBQUlGLFFBQVFHLE1BQU0sS0FBS0YsUUFBUUUsTUFBTTtJQUMvRTtJQUNBOzs7OztHQUtELEdBQUdDLFNBQVNDLG1CQUFtQixFQUFFLENBQUM7SUFDakM7Ozs7R0FJRCxHQUFHLG1EQUFtRDtJQUNyRCxxREFBcUQ7SUFDckQsbUJBQW1CO0lBQ25CLG1CQUFtQjtJQUNuQixNQUFNO0lBQ04sYUFBYTtJQUNiLG9CQUFvQjtJQUNwQixrQkFBa0I7SUFDbEIsT0FBTztJQUNQLElBQUk7SUFDSjs7OztHQUlELEdBQUcsbURBQW1EO0lBQ3JELGlCQUFpQjtJQUNqQixJQUFJO0lBQ0o7Ozs7OztHQU1ELEdBQUdDLHFCQUFxQkMsVUFBVSxFQUFFO1FBQy9CLE9BQU9BO0lBQ1g7SUFDQTs7Ozs7O0dBTUQsR0FBR0MsbUJBQW1CRCxVQUFVLEVBQUU7UUFDN0IsT0FBT0E7SUFDWDtBQUNKO0FBR0E7Ozs7Ozs7Ozs7Q0FVQyxHQUFHLE1BQU1FO0lBQ047O0dBRUQsR0FBR0MsT0FBTztRQUNMLElBQUlDLE1BQU0sSUFBSUYsMENBQTBDLElBQUksQ0FBQ0csSUFBSSxFQUFFLElBQUksQ0FBQ0MsR0FBRyxFQUFFLElBQUksQ0FBQ0MsSUFBSSxDQUFDSixJQUFJO1FBQzNGQyxJQUFJSSxhQUFhLEdBQUcsSUFBSSxDQUFDQSxhQUFhO1FBQ3RDSixJQUFJSyxPQUFPLEdBQUcsSUFBSSxDQUFDQSxPQUFPO1FBQzFCTCxJQUFJTSxTQUFT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LDhDQUFpQixFQUFHLENBQUNtQjtRQUMxQzBDLFlBQVlrRSxXQUFXLEdBQUc1RztJQUM5QixHQUFHO1FBQ0MwQztLQUNIO0lBQ0QsSUFBSXVPLGlCQUFpQixDQUFDLEdBQUdwUyw4Q0FBaUIsRUFBRztRQUN6QzZELFlBQVl1TyxjQUFjO1FBQzFCNkIsYUFBYTtJQUNqQixHQUFHO1FBQ0NwUTtLQUNIO0lBQ0QsSUFBSXdPLGVBQWUsQ0FBQyxHQUFHclMsOENBQWlCLEVBQUc7UUFDdkM2RCxZQUFZd08sWUFBWTtRQUN4QjRCLGFBQWE7SUFDakIsR0FBRztRQUNDcFE7S0FDSDtJQUNELElBQUlzUSxRQUFRLENBQUMsR0FBR3ZVLDBDQUFhLEVBQUcsSUFBSztZQUM3QmlFLGFBQWFBO1lBQ2JnSixjQUFjQTtZQUNkbEYsZ0JBQWdCQTtZQUNoQmlDLGFBQWFBO1lBQ2JrSyxhQUFhQTtZQUNiRSxhQUFhQTtZQUNiNUIsZ0JBQWdCQTtZQUNoQkMsY0FBY0E7UUFDbEIsSUFBSTtRQUNKeE87UUFDQWdKO1FBQ0FsRjtRQUNBaUM7UUFDQWtLO1FBQ0FFO1FBQ0E1QjtRQUNBQztLQUNIO0lBQ0QsT0FBTzhCO0FBQ1g7QUFLNFksQ0FDNVksa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGFuYW1vbm5leHRfdWkvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvdmlydHVhbGl6ZXIvZGlzdC9pbXBvcnQubWpzP2U5YTEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHt1c2VTdGF0ZSBhcyAkOEQzbnIkdXNlU3RhdGUsIHVzZU1lbW8gYXMgJDhEM25yJHVzZU1lbW8sIHVzZUVmZmVjdCBhcyAkOEQzbnIkdXNlRWZmZWN0LCB1c2VDYWxsYmFjayBhcyAkOEQzbnIkdXNlQ2FsbGJhY2t9IGZyb20gXCJyZWFjdFwiO1xyXG5pbXBvcnQge3VzZUxheW91dEVmZmVjdCBhcyAkOEQzbnIkdXNlTGF5b3V0RWZmZWN0fSBmcm9tIFwiQHJlYWN0LWFyaWEvdXRpbHNcIjtcclxuXHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XHJcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXHJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xyXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcclxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovIC8qXHJcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XHJcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXHJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xyXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcclxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovIGNsYXNzICRjNzRjZGE3ZDMxYWYxMjUzJGV4cG9ydCRjODQ2NzFmNDZkNmExY2Ege1xyXG4gICAgLyoqXHJcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBsYXlvdXQgc2hvdWxkIGludmFsaWRhdGUgaW4gcmVzcG9uc2UgdG9cclxuICAgKiB2aXNpYmxlIHJlY3RhbmdsZSBjaGFuZ2VzLiBCeSBkZWZhdWx0LCBpdCBvbmx5IGludmFsaWRhdGVzXHJcbiAgICogd2hlbiB0aGUgY29sbGVjdGlvbiB2aWV3J3Mgc2l6ZSBjaGFuZ2VzLiBSZXR1cm4gdHJ1ZSBhbHdheXNcclxuICAgKiB0byBtYWtlIHRoZSBsYXlvdXQgaW52YWxpZGF0ZSB3aGlsZSBzY3JvbGxpbmcgKGUuZy4gc3RpY2t5IGhlYWRlcnMpLlxyXG4gICAqLyBzaG91bGRJbnZhbGlkYXRlKG5ld1JlY3QsIG9sZFJlY3QpIHtcclxuICAgICAgICAvLyBCeSBkZWZhdWx0LCBpbnZhbGlkYXRlIHdoZW4gdGhlIHNpemUgY2hhbmdlc1xyXG4gICAgICAgIHJldHVybiBuZXdSZWN0LndpZHRoICE9PSBvbGRSZWN0LndpZHRoIHx8IG5ld1JlY3QuaGVpZ2h0ICE9PSBvbGRSZWN0LmhlaWdodDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAqIFRoaXMgbWV0aG9kIGFsbG93cyB0aGUgbGF5b3V0IHRvIHBlcmZvcm0gYW55IHByZS1jb21wdXRhdGlvblxyXG4gICAqIGl0IG5lZWRzIHRvIGluIG9yZGVyIHRvIHByZXBhcmUge0BsaW5rIExheW91dEluZm99cyBmb3IgcmV0cmlldmFsLlxyXG4gICAqIENhbGxlZCBieSB0aGUgY29sbGVjdGlvbiB2aWV3IGJlZm9yZSB7QGxpbmsgZ2V0VmlzaWJsZUxheW91dEluZm9zfVxyXG4gICAqIG9yIHtAbGluayBnZXRMYXlvdXRJbmZvfSBhcmUgY2FsbGVkLlxyXG4gICAqLyB2YWxpZGF0ZShpbnZhbGlkYXRpb25Db250ZXh0KSB7fVxyXG4gICAgLyoqXHJcbiAgICogUmV0dXJucyBhIHtAbGluayBEcmFnVGFyZ2V0fSBkZXNjcmliaW5nIGEgdmlldyBhdCB0aGUgZ2l2ZW4gcG9pbnQgdG8gYmUgZHJhZ2dlZC5cclxuICAgKiBSZXR1cm4gYG51bGxgIHRvIGNhbmNlbCB0aGUgZHJhZy4gVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gcmV0dXJucyB0aGUgdmlldyBhdCB0aGUgZ2l2ZW4gcG9pbnQuXHJcbiAgICogQHBhcmFtIHBvaW50IFRoZSBwb2ludCBhdCB3aGljaCB0aGUgZHJhZyBvY2N1cnJlZC5cclxuICAgKi8gLy8gZ2V0RHJhZ1RhcmdldChwb2ludDogUG9pbnQpOiBEcmFnVGFyZ2V0IHwgbnVsbCB7XHJcbiAgICAvLyAgIGxldCB0YXJnZXQgPSB0aGlzLnZpcnR1YWxpemVyLmtleUF0UG9pbnQocG9pbnQpO1xyXG4gICAgLy8gICBpZiAoIXRhcmdldCkge1xyXG4gICAgLy8gICAgIHJldHVybiBudWxsO1xyXG4gICAgLy8gICB9XHJcbiAgICAvLyAgIHJldHVybiB7XHJcbiAgICAvLyAgICAgdHlwZTogJ2l0ZW0nLFxyXG4gICAgLy8gICAgIGtleTogdGFyZ2V0XHJcbiAgICAvLyAgIH07XHJcbiAgICAvLyB9XHJcbiAgICAvKipcclxuICAgKiBSZXR1cm5zIGEge0BsaW5rIERyYWdUYXJnZXR9IG9iamVjdCBkZXNjcmliaW5nIHdoZXJlIGEgZHJvcCBzaG91bGQgb2NjdXIuIFJldHVybiBgbnVsbGBcclxuICAgKiB0byByZWplY3QgdGhlIGRyb3AuIFRoZSBkcm9wcGVkIGl0ZW1zIHdpbGwgYmUgaW5zZXJ0ZWQgYmVmb3JlIHRoZSByZXN1bHRpbmcgdGFyZ2V0LlxyXG4gICAqIEBwYXJhbSBwb2ludCBUaGUgcG9pbnQgYXQgd2hpY2ggdGhlIGRyb3Agb2NjdXJyZWQuXHJcbiAgICovIC8vIGdldERyb3BUYXJnZXQocG9pbnQ6IFBvaW50KTogRHJvcFRhcmdldCB8IG51bGwge1xyXG4gICAgLy8gICByZXR1cm4gbnVsbDtcclxuICAgIC8vIH1cclxuICAgIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIHN0YXJ0aW5nIGF0dHJpYnV0ZXMgZm9yIGFuIGFuaW1hdGVkIGluc2VydGlvbi5cclxuICAgKiBUaGUgdmlldyBpcyBhbmltYXRlZCBmcm9tIHRoaXMge0BsaW5rIExheW91dEluZm99IHRvIHRoZSBvbmUgcmV0dXJuZWQgYnkge0BsaW5rIGdldExheW91dEluZm99LlxyXG4gICAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGp1c3QgcmV0dXJucyBpdHMgaW5wdXQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gbGF5b3V0SW5mbyBUaGUgcHJvcG9zZWQgTGF5b3V0SW5mbyBmb3IgdGhpcyB2aWV3LlxyXG4gICAqLyBnZXRJbml0aWFsTGF5b3V0SW5mbyhsYXlvdXRJbmZvKSB7XHJcbiAgICAgICAgcmV0dXJuIGxheW91dEluZm87XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBlbmRpbmcgYXR0cmlidXRlcyBmb3IgYW4gYW5pbWF0ZWQgcmVtb3ZhbC5cclxuICAgKiBUaGUgdmlldyBpcyBhbmltYXRlZCBmcm9tIHRoZSB7QGxpbmsgTGF5b3V0SW5mb30gcmV0dXJuZWQgYnkge0BsaW5rIGdldExheW91dEluZm99XHJcbiAgICogdG8gdGhlIG9uZSByZXR1cm5lZCBieSB0aGlzIG1ldGhvZC4gVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gcmV0dXJucyBpdHMgaW5wdXQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gbGF5b3V0SW5mbyBUaGUgb3JpZ2luYWwgTGF5b3V0SW5mbyBmb3IgdGhpcyB2aWV3LlxyXG4gICAqLyBnZXRGaW5hbExheW91dEluZm8obGF5b3V0SW5mbykge1xyXG4gICAgICAgIHJldHVybiBsYXlvdXRJbmZvO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuLypcclxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcclxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXHJcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxyXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi8gY2xhc3MgJGQ3ZmQ2MTAwOWMyMWQwYmIkZXhwb3J0JDdlMGVlYjlkYTcwMmEwODUge1xyXG4gICAgLyoqXHJcbiAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhlIExheW91dEluZm8uXHJcbiAgICovIGNvcHkoKSB7XHJcbiAgICAgICAgbGV0IHJlcyA9IG5ldyAkZDdmZDYxMDA5YzIxZDBiYiRleHBvcnQkN2UwZWViOWRhNzAyYTA4NSh0aGlzLnR5cGUsIHRoaXMua2V5LCB0aGlzLnJlY3QuY29weSgpKTtcclxuICAgICAgICByZXMuZXN0aW1hdGVkU2l6ZSA9IHRoaXMuZXN0aW1hdGVkU2l6ZTtcclxuICAgICAgICByZXMub3BhY2l0eSA9IHRoaXMub3BhY2l0eTtcclxuICAgICAgICByZXMudHJhbnNmb3JtID0gdGhpcy50cmFuc2Zvcm07XHJcbiAgICAgICAgcmVzLnBhcmVudEtleSA9IHRoaXMucGFyZW50S2V5O1xyXG4gICAgICAgIHJlcy5pc1N0aWNreSA9IHRoaXMuaXNTdGlja3k7XHJcbiAgICAgICAgcmVzLnpJbmRleCA9IHRoaXMuekluZGV4O1xyXG4gICAgICAgIHJlcy5hbGxvd092ZXJmbG93ID0gdGhpcy5hbGxvd092ZXJmbG93O1xyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgKiBAcGFyYW0gdHlwZSBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZpZXcgdHlwZS4gU2hvdWxkIGJlIGAnaXRlbSdgIGZvciBpdGVtIHZpZXdzLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgT3RoZXIgdHlwZXMgYXJlIHVzZWQgYnkgc3VwcGxlbWVudGFyeSB2aWV3cy5cclxuICAgKiBAcGFyYW0ga2V5IFRoZSB1bmlxdWUga2V5IGZvciB0aGlzIHZpZXcuXHJcbiAgICogQHBhcmFtIHJlY3QgVGhlIHJlY3RhbmdsZSBkZXNjcmliaW5nIHRoZSBzaXplIGFuZCBwb3NpdGlvbiBvZiB0aGlzIHZpZXcuXHJcbiAgICovIGNvbnN0cnVjdG9yKHR5cGUsIGtleSwgcmVjdCl7XHJcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcclxuICAgICAgICB0aGlzLmtleSA9IGtleTtcclxuICAgICAgICB0aGlzLnBhcmVudEtleSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5yZWN0ID0gcmVjdDtcclxuICAgICAgICB0aGlzLmVzdGltYXRlZFNpemUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmlzU3RpY2t5ID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5vcGFjaXR5ID0gMTtcclxuICAgICAgICB0aGlzLnRyYW5zZm9ybSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy56SW5kZXggPSAwO1xyXG4gICAgICAgIHRoaXMuYWxsb3dPdmVyZmxvdyA9IGZhbHNlO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuLypcclxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcclxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXHJcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxyXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi8gY2xhc3MgJDMwNDFkYjMyOTY5NDVlNmUkZXhwb3J0JGJhZjI2MTQ2YTQxNGYyNGEge1xyXG4gICAgLyoqXHJcbiAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhpcyBwb2ludC5cclxuICAgKi8gY29weSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3ICQzMDQxZGIzMjk2OTQ1ZTZlJGV4cG9ydCRiYWYyNjE0NmE0MTRmMjRhKHRoaXMueCwgdGhpcy55KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAqIENoZWNrcyBpZiB0d28gcG9pbnRzIGFyZSBlcXVhbC5cclxuICAgKi8gZXF1YWxzKHBvaW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMueCA9PT0gcG9pbnQueCAmJiB0aGlzLnkgPT09IHBvaW50Lnk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBwb2ludCBpcyB0aGUgb3JpZ2luLlxyXG4gICAqLyBpc09yaWdpbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy54ID09PSAwICYmIHRoaXMueSA9PT0gMDtcclxuICAgIH1cclxuICAgIGNvbnN0cnVjdG9yKHggPSAwLCB5ID0gMCl7XHJcbiAgICAgICAgdGhpcy54ID0geDtcclxuICAgICAgICB0aGlzLnkgPSB5O1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuLypcclxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcclxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXHJcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxyXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi8gXHJcbmNsYXNzICQ2MDQyM2Y5MmM3ZjlhZDg3JGV4cG9ydCRjNzlmYzY0OTJmM2FmMTNkIHtcclxuICAgIC8qKlxyXG4gICAqIFRoZSBtYXhpbXVtIHgtY29vcmRpbmF0ZSBpbiB0aGUgcmVjdGFuZ2xlLlxyXG4gICAqLyBnZXQgbWF4WCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy54ICsgdGhpcy53aWR0aDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAqIFRoZSBtYXhpbXVtIHktY29vcmRpbmF0ZSBpbiB0aGUgcmVjdGFuZ2xlLlxyXG4gICAqLyBnZXQgbWF4WSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy55ICsgdGhpcy5oZWlnaHQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgKiBUaGUgYXJlYSBvZiB0aGUgcmVjdGFuZ2xlLlxyXG4gICAqLyBnZXQgYXJlYSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy53aWR0aCAqIHRoaXMuaGVpZ2h0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICogVGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlLlxyXG4gICAqLyBnZXQgdG9wTGVmdCgpIHtcclxuICAgICAgICByZXR1cm4gbmV3ICgwLCAkMzA0MWRiMzI5Njk0NWU2ZSRleHBvcnQkYmFmMjYxNDZhNDE0ZjI0YSkodGhpcy54LCB0aGlzLnkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICogVGhlIHRvcCByaWdodCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZS5cclxuICAgKi8gZ2V0IHRvcFJpZ2h0KCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgKDAsICQzMDQxZGIzMjk2OTQ1ZTZlJGV4cG9ydCRiYWYyNjE0NmE0MTRmMjRhKSh0aGlzLm1heFgsIHRoaXMueSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgKiBUaGUgYm90dG9tIGxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGUuXHJcbiAgICovIGdldCBib3R0b21MZWZ0KCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgKDAsICQzMDQxZGIzMjk2OTQ1ZTZlJGV4cG9ydCRiYWYyNjE0NmE0MTRmMjRhKSh0aGlzLngsIHRoaXMubWF4WSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgKiBUaGUgYm90dG9tIHJpZ2h0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlLlxyXG4gICAqLyBnZXQgYm90dG9tUmlnaHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyAoMCwgJDMwNDFkYjMyOTY5NDVlNmUkZXhwb3J0JGJhZjI2MTQ2YTQxNGYyNGEpKHRoaXMubWF4WCwgdGhpcy5tYXhZKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAqIFJldHVybnMgd2hldGhlciB0aGlzIHJlY3RhbmdsZSBpbnRlcnNlY3RzIGFub3RoZXIgcmVjdGFuZ2xlLlxyXG4gICAqIEBwYXJhbSByZWN0IC0gVGhlIHJlY3RhbmdsZSB0byBjaGVjay5cclxuICAgKi8gaW50ZXJzZWN0cyhyZWN0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMueCA8PSByZWN0LnggKyByZWN0LndpZHRoICYmIHJlY3QueCA8PSB0aGlzLnggKyB0aGlzLndpZHRoICYmIHRoaXMueSA8PSByZWN0LnkgKyByZWN0LmhlaWdodCAmJiByZWN0LnkgPD0gdGhpcy55ICsgdGhpcy5oZWlnaHQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyByZWN0YW5nbGUgZnVsbHkgY29udGFpbnMgYW5vdGhlciByZWN0YW5nbGUuXHJcbiAgICogQHBhcmFtIHJlY3QgLSBUaGUgcmVjdGFuZ2xlIHRvIGNoZWNrLlxyXG4gICAqLyBjb250YWluc1JlY3QocmVjdCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnggPD0gcmVjdC54ICYmIHRoaXMueSA8PSByZWN0LnkgJiYgdGhpcy5tYXhYID49IHJlY3QubWF4WCAmJiB0aGlzLm1heFkgPj0gcmVjdC5tYXhZO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSByZWN0YW5nbGUgY29udGFpbnMgdGhlIGdpdmVuIHBvaW50LlxyXG4gICAqIEBwYXJhbSBwb2ludCAtIFRoZSBwb2ludCB0byBjaGVjay5cclxuICAgKi8gY29udGFpbnNQb2ludChwb2ludCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnggPD0gcG9pbnQueCAmJiB0aGlzLnkgPD0gcG9pbnQueSAmJiB0aGlzLm1heFggPj0gcG9pbnQueCAmJiB0aGlzLm1heFkgPj0gcG9pbnQueTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIGZpcnN0IGNvcm5lciBvZiB0aGlzIHJlY3RhbmdsZSAoZnJvbSB0b3AgdG8gYm90dG9tLCBsZWZ0IHRvIHJpZ2h0KVxyXG4gICAqIHRoYXQgaXMgY29udGFpbmVkIGluIHRoZSBnaXZlbiByZWN0YW5nbGUsIG9yIG51bGwgb2YgdGhlIHJlY3RhbmdsZXMgZG8gbm90IGludGVyc2VjdC5cclxuICAgKiBAcGFyYW0gcmVjdCAtIFRoZSByZWN0YW5nbGUgdG8gY2hlY2suXHJcbiAgICovIGdldENvcm5lckluUmVjdChyZWN0KSB7XHJcbiAgICAgICAgZm9yIChsZXQga2V5IG9mIFtcclxuICAgICAgICAgICAgXCJ0b3BMZWZ0XCIsXHJcbiAgICAgICAgICAgIFwidG9wUmlnaHRcIixcclxuICAgICAgICAgICAgXCJib3R0b21MZWZ0XCIsXHJcbiAgICAgICAgICAgIFwiYm90dG9tUmlnaHRcIlxyXG4gICAgICAgIF0pe1xyXG4gICAgICAgICAgICBpZiAocmVjdC5jb250YWluc1BvaW50KHRoaXNba2V5XSkpIHJldHVybiBrZXk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgZXF1YWxzKHJlY3QpIHtcclxuICAgICAgICByZXR1cm4gcmVjdC54ID09PSB0aGlzLnggJiYgcmVjdC55ID09PSB0aGlzLnkgJiYgcmVjdC53aWR0aCA9PT0gdGhpcy53aWR0aCAmJiByZWN0LmhlaWdodCA9PT0gdGhpcy5oZWlnaHQ7XHJcbiAgICB9XHJcbiAgICBwb2ludEVxdWFscyhwb2ludCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnggPT09IHBvaW50LnggJiYgdGhpcy55ID09PSBwb2ludC55O1xyXG4gICAgfVxyXG4gICAgc2l6ZUVxdWFscyhzaXplKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMud2lkdGggPT09IHNpemUud2lkdGggJiYgdGhpcy5oZWlnaHQgPT09IHNpemUuaGVpZ2h0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgdW5pb24gb2YgdGhpcyBSZWN0IGFuZCBhbm90aGVyLlxyXG4gICAqLyB1bmlvbihvdGhlcikge1xyXG4gICAgICAgIGxldCB4ID0gTWF0aC5taW4odGhpcy54LCBvdGhlci54KTtcclxuICAgICAgICBsZXQgeSA9IE1hdGgubWluKHRoaXMueSwgb3RoZXIueSk7XHJcbiAgICAgICAgbGV0IHdpZHRoID0gTWF0aC5tYXgodGhpcy5tYXhYLCBvdGhlci5tYXhYKSAtIHg7XHJcbiAgICAgICAgbGV0IGhlaWdodCA9IE1hdGgubWF4KHRoaXMubWF4WSwgb3RoZXIubWF4WSkgLSB5O1xyXG4gICAgICAgIHJldHVybiBuZXcgJDYwNDIzZjkyYzdmOWFkODckZXhwb3J0JGM3OWZjNjQ5MmYzYWYxM2QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBpbnRlcnNlY3Rpb24gb2YgdGhpcyBSZWN0IHdpdGggYW5vdGhlci5cclxuICAgKiBJZiB0aGUgcmVjdGFuZ2xlcyBkbyBub3QgaW50ZXJzZWN0LCBhbiBhbGwgemVybyBSZWN0IGlzIHJldHVybmVkLlxyXG4gICAqLyBpbnRlcnNlY3Rpb24ob3RoZXIpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaW50ZXJzZWN0cyhvdGhlcikpIHJldHVybiBuZXcgJDYwNDIzZjkyYzdmOWFkODckZXhwb3J0JGM3OWZjNjQ5MmYzYWYxM2QoMCwgMCwgMCwgMCk7XHJcbiAgICAgICAgbGV0IHggPSBNYXRoLm1heCh0aGlzLngsIG90aGVyLngpO1xyXG4gICAgICAgIGxldCB5ID0gTWF0aC5tYXgodGhpcy55LCBvdGhlci55KTtcclxuICAgICAgICByZXR1cm4gbmV3ICQ2MDQyM2Y5MmM3ZjlhZDg3JGV4cG9ydCRjNzlmYzY0OTJmM2FmMTNkKHgsIHksIE1hdGgubWluKHRoaXMubWF4WCwgb3RoZXIubWF4WCkgLSB4LCBNYXRoLm1pbih0aGlzLm1heFksIG90aGVyLm1heFkpIC0geSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGlzIHJlY3RhbmdsZS5cclxuICAgKi8gY29weSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3ICQ2MDQyM2Y5MmM3ZjlhZDg3JGV4cG9ydCRjNzlmYzY0OTJmM2FmMTNkKHRoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XHJcbiAgICB9XHJcbiAgICBjb25zdHJ1Y3Rvcih4ID0gMCwgeSA9IDAsIHdpZHRoID0gMCwgaGVpZ2h0ID0gMCl7XHJcbiAgICAgICAgdGhpcy54ID0geDtcclxuICAgICAgICB0aGlzLnkgPSB5O1xyXG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuICAgIH1cclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XHJcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXHJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xyXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcclxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovIGNsYXNzICRlZTFiZmE5MGE5NTdmYjhhJGV4cG9ydCRjYjZkYTg5YzZhZjFhOGVjIHtcclxuICAgIC8qKlxyXG4gICAqIFJldHVybnMgYSBjb3B5IG9mIHRoaXMgc2l6ZS5cclxuICAgKi8gY29weSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3ICRlZTFiZmE5MGE5NTdmYjhhJGV4cG9ydCRjYjZkYTg5YzZhZjFhOGVjKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAqIFJldHVybnMgd2hldGhlciB0aGlzIHNpemUgaXMgZXF1YWwgdG8gYW5vdGhlciBvbmUuXHJcbiAgICovIGVxdWFscyhvdGhlcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLndpZHRoID09PSBvdGhlci53aWR0aCAmJiB0aGlzLmhlaWdodCA9PT0gb3RoZXIuaGVpZ2h0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICogVGhlIHRvdGFsIGFyZWEgb2YgdGhlIFNpemUuXHJcbiAgICovIGdldCBhcmVhKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLndpZHRoICogdGhpcy5oZWlnaHQ7XHJcbiAgICB9XHJcbiAgICBjb25zdHJ1Y3Rvcih3aWR0aCA9IDAsIGhlaWdodCA9IDApe1xyXG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuICAgIH1cclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XHJcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXHJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xyXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcclxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovIGxldCAkYWQxZDk4YWE4ZjBjMzFiNCR2YXIkS0VZID0gMDtcclxuY2xhc3MgJGFkMWQ5OGFhOGYwYzMxYjQkZXhwb3J0JDFhNTIyMzg4N2M1NjA0NDEge1xyXG4gICAgLyoqXHJcbiAgICogUHJlcGFyZXMgdGhlIHZpZXcgZm9yIHJldXNlLiBDYWxsZWQganVzdCBiZWZvcmUgdGhlIHZpZXcgaXMgcmVtb3ZlZCBmcm9tIHRoZSBET00uXHJcbiAgICovIHByZXBhcmVGb3JSZXVzZSgpIHtcclxuICAgICAgICB0aGlzLmNvbnRlbnQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucmVuZGVyZWQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMubGF5b3V0SW5mbyA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBjb25zdHJ1Y3Rvcih2aXJ0dWFsaXplcil7XHJcbiAgICAgICAgdGhpcy52aXJ0dWFsaXplciA9IHZpcnR1YWxpemVyO1xyXG4gICAgICAgIHRoaXMua2V5ID0gKyskYWQxZDk4YWE4ZjBjMzFiNCR2YXIkS0VZO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuLypcclxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcclxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXHJcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxyXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi8gXHJcblxyXG5cclxuLypcclxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcclxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXHJcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxyXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi8gLypcclxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcclxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXHJcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxyXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi8gXHJcbi8vIHVzZSBoaWdoIHJlcyB0aW1lciBpZiBhdmFpbGFibGVcclxubGV0ICQzZWIxMzFkY2YzN2FkNWY4JHZhciRwZXJmID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5wZXJmb3JtYW5jZSA6IG51bGw7XHJcbi8vIEB0cy1pZ25vcmVcclxubGV0ICQzZWIxMzFkY2YzN2FkNWY4JHZhciRwZXJmTm93ID0gJDNlYjEzMWRjZjM3YWQ1ZjgkdmFyJHBlcmYgJiYgKCQzZWIxMzFkY2YzN2FkNWY4JHZhciRwZXJmLm5vdyB8fCAkM2ViMTMxZGNmMzdhZDVmOCR2YXIkcGVyZi53ZWJraXROb3cgfHwgJDNlYjEzMWRjZjM3YWQ1ZjgkdmFyJHBlcmYubXNOb3cgfHwgJDNlYjEzMWRjZjM3YWQ1ZjgkdmFyJHBlcmYubW96Tm93KTtcclxubGV0ICQzZWIxMzFkY2YzN2FkNWY4JHZhciRnZXRUaW1lID0gJDNlYjEzMWRjZjM3YWQ1ZjgkdmFyJHBlcmZOb3cgPyAkM2ViMTMxZGNmMzdhZDVmOCR2YXIkcGVyZk5vdy5iaW5kKCQzZWIxMzFkY2YzN2FkNWY4JHZhciRwZXJmKSA6IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIERhdGUubm93ID8gRGF0ZS5ub3coKSA6IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG59O1xyXG5sZXQgJDNlYjEzMWRjZjM3YWQ1ZjgkdmFyJGZpeFRzO1xyXG5mdW5jdGlvbiAkM2ViMTMxZGNmMzdhZDVmOCRleHBvcnQkZGMwYjYzNzIwNzg4MDkwYyhiZWdpbiwgZW5kLCBkdXJhdGlvbiwgZWFzZSwgZm4pIHtcclxuICAgIGxldCBjYW5jZWxlZCA9IGZhbHNlO1xyXG4gICAgbGV0IHJhZl9pZDtcclxuICAgIGxldCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpPT57XHJcbiAgICAgICAgbGV0IHN0YXJ0ID0gJDNlYjEzMWRjZjM3YWQ1ZjgkdmFyJGdldFRpbWUoKTtcclxuICAgICAgICBsZXQgZGlmZlggPSBlbmQueCAtIGJlZ2luLng7XHJcbiAgICAgICAgbGV0IGRpZmZZID0gZW5kLnkgLSBiZWdpbi55O1xyXG4gICAgICAgIHJhZl9pZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiBydW4odCkge1xyXG4gICAgICAgICAgICAvLyBpZiB3ZSdyZSB1c2luZyBhIGhpZ2ggcmVzIHRpbWVyLCBtYWtlIHN1cmUgdGltZXN0YW1wIGlzIG5vdCB0aGUgb2xkIGVwb2NoLWJhc2VkIHZhbHVlLlxyXG4gICAgICAgICAgICAvLyBodHRwOi8vdXBkYXRlcy5odG1sNXJvY2tzLmNvbS8yMDEyLzA1L3JlcXVlc3RBbmltYXRpb25GcmFtZS1BUEktbm93LXdpdGgtc3ViLW1pbGxpc2Vjb25kLXByZWNpc2lvblxyXG4gICAgICAgICAgICBpZiAoJDNlYjEzMWRjZjM3YWQ1ZjgkdmFyJGZpeFRzID09IG51bGwpICQzZWIxMzFkY2YzN2FkNWY4JHZhciRmaXhUcyA9IHQgPiAxZTEyICE9PSAkM2ViMTMxZGNmMzdhZDVmOCR2YXIkZ2V0VGltZSgpID4gMWUxMjtcclxuICAgICAgICAgICAgaWYgKCQzZWIxMzFkY2YzN2FkNWY4JHZhciRmaXhUcykgdCA9ICQzZWIxMzFkY2YzN2FkNWY4JHZhciRnZXRUaW1lKCk7XHJcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHdlJ3JlIGRvbmVcclxuICAgICAgICAgICAgbGV0IGRlbHRhID0gdCAtIHN0YXJ0O1xyXG4gICAgICAgICAgICBpZiAoZGVsdGEgPiBkdXJhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgZm4oZW5kKTtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIGNhbGwgZnJhbWUgY2FsbGJhY2sgYWZ0ZXIgY29tcHV0aW5nIGVhc2VkIHRpbWUgYW5kIGdldCB0aGUgbmV4dCBmcmFtZVxyXG4gICAgICAgICAgICAgICAgbGV0IHByb2NlZWQgPSBmbihuZXcgKDAsICQzMDQxZGIzMjk2OTQ1ZTZlJGV4cG9ydCRiYWYyNjE0NmE0MTRmMjRhKShiZWdpbi54ICsgZGlmZlggKiBlYXNlKGRlbHRhIC8gZHVyYXRpb24pLCBiZWdpbi55ICsgZGlmZlkgKiBlYXNlKGRlbHRhIC8gZHVyYXRpb24pKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJvY2VlZCAhPT0gZmFsc2UgJiYgIWNhbmNlbGVkKSByYWZfaWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocnVuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgICBwcm9taXNlLmNhbmNlbCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGNhbmNlbGVkID0gdHJ1ZTtcclxuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShyYWZfaWQpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBwcm9taXNlO1xyXG59XHJcbmZ1bmN0aW9uICQzZWIxMzFkY2YzN2FkNWY4JGV4cG9ydCQ3Nzg2MGMxMDZiNGE2YTJlKHQpIHtcclxuICAgIHJldHVybiB0O1xyXG59XHJcbmZ1bmN0aW9uICQzZWIxMzFkY2YzN2FkNWY4JGV4cG9ydCQ1NzYzNmJiNDNiMWNjYmIwKHQpIHtcclxuICAgIHJldHVybiBNYXRoLnNpbih0ICogTWF0aC5QSSAvIDIpO1xyXG59XHJcblxyXG5cclxuLypcclxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcclxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXHJcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxyXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi8gZnVuY3Rpb24gJGZjMzZmOWEwNDZhOWNlNzkkZXhwb3J0JDM3YTI2YjI4M2ZkNzc0MGUoYSwgYikge1xyXG4gICAgbGV0IHJlcyA9IG5ldyBTZXQoKTtcclxuICAgIGZvciAobGV0IGtleSBvZiBhLmtleXMoKSlpZiAoIWIuaGFzKGtleSkpIHJlcy5hZGQoa2V5KTtcclxuICAgIHJldHVybiByZXM7XHJcbn1cclxuZnVuY3Rpb24gJGZjMzZmOWEwNDZhOWNlNzkkZXhwb3J0JGFjYWY5NmEyNzQzODI0NmIoYSwgYikge1xyXG4gICAgbGV0IHRvUmVtb3ZlID0gJGZjMzZmOWEwNDZhOWNlNzkkZXhwb3J0JDM3YTI2YjI4M2ZkNzc0MGUoYSwgYik7XHJcbiAgICBsZXQgdG9BZGQgPSAkZmMzNmY5YTA0NmE5Y2U3OSRleHBvcnQkMzdhMjZiMjgzZmQ3NzQwZShiLCBhKTtcclxuICAgIGxldCB0b1VwZGF0ZSA9IG5ldyBTZXQ7XHJcbiAgICBmb3IgKGxldCBrZXkgb2YgYS5rZXlzKCkpaWYgKGIuaGFzKGtleSkpIHRvVXBkYXRlLmFkZChrZXkpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0b1JlbW92ZTogdG9SZW1vdmUsXHJcbiAgICAgICAgdG9BZGQ6IHRvQWRkLFxyXG4gICAgICAgIHRvVXBkYXRlOiB0b1VwZGF0ZVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiogJGZjMzZmOWEwNDZhOWNlNzkkZXhwb3J0JGNmYzE0MDg4ZGZlZmNlNWYoLi4uaXRlcmF0b3JzKSB7XHJcbiAgICBmb3IgKGxldCBpdGVyYXRvciBvZiBpdGVyYXRvcnMpeWllbGQqIGl0ZXJhdG9yO1xyXG59XHJcbmZ1bmN0aW9uICRmYzM2ZjlhMDQ2YTljZTc5JGV4cG9ydCQ2ODk3YzI4NGI2ZjlmNGRjKG9iamVjdCkge1xyXG4gICAgbGV0IHJlcyA9IHt9O1xyXG4gICAgZm9yKGxldCBrZXkgaW4gb2JqZWN0KXJlc1tvYmplY3Rba2V5XV0gPSBrZXk7XHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcbmZ1bmN0aW9uICRmYzM2ZjlhMDQ2YTljZTc5JGV4cG9ydCRhOGQwZDBjOGQxYzVkZjY0KGEsIGIpIHtcclxuICAgIGlmIChhID09PSBiKSByZXR1cm4gdHJ1ZTtcclxuICAgIGlmIChhLnNpemUgIT09IGIuc2l6ZSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgZm9yIChsZXQga2V5IG9mIGEpe1xyXG4gICAgICAgIGlmICghYi5oYXMoa2V5KSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxyXG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcclxuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXHJcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqLyBcclxuXHJcbmNsYXNzICQzNjQxOTFiM2RlY2YzNjk3JHZhciRSb2xsaW5nQXZlcmFnZSB7XHJcbiAgICBhZGRTYW1wbGUoc2FtcGxlKSB7XHJcbiAgICAgICAgdGhpcy5jb3VudCsrO1xyXG4gICAgICAgIHRoaXMudmFsdWUgKz0gKHNhbXBsZSAtIHRoaXMudmFsdWUpIC8gdGhpcy5jb3VudDtcclxuICAgIH1cclxuICAgIGNvbnN0cnVjdG9yKCl7XHJcbiAgICAgICAgdGhpcy5jb3VudCA9IDA7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IDA7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgJDM2NDE5MWIzZGVjZjM2OTckZXhwb3J0JDQ0NTVlZTZhZmIzOGRjYmIge1xyXG4gICAgc2V0VmlzaWJsZVJlY3QocmVjdCkge1xyXG4gICAgICAgIGxldCB0aW1lID0gcGVyZm9ybWFuY2Uubm93KCkgLSB0aGlzLnN0YXJ0VGltZTtcclxuICAgICAgICBpZiAodGltZSA8IDUwMCkge1xyXG4gICAgICAgICAgICB0aGlzLmF2ZXJhZ2VUaW1lLmFkZFNhbXBsZSh0aW1lKTtcclxuICAgICAgICAgICAgaWYgKHJlY3QueCAhPT0gdGhpcy52aXNpYmxlUmVjdC54ICYmIHRpbWUgPiAwKSB0aGlzLnZlbG9jaXR5LnggPSAocmVjdC54IC0gdGhpcy52aXNpYmxlUmVjdC54KSAvIHRpbWU7XHJcbiAgICAgICAgICAgIGlmIChyZWN0LnkgIT09IHRoaXMudmlzaWJsZVJlY3QueSAmJiB0aW1lID4gMCkgdGhpcy52ZWxvY2l0eS55ID0gKHJlY3QueSAtIHRoaXMudmlzaWJsZVJlY3QueSkgLyB0aW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgICAgIHRoaXMudmlzaWJsZVJlY3QgPSByZWN0O1xyXG4gICAgfVxyXG4gICAgY29sbGVjdE1ldHJpY3MoKSB7XHJcbiAgICAgICAgbGV0IHRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHRoaXMuc3RhcnRUaW1lO1xyXG4gICAgICAgIGlmICh0aW1lIDwgNTAwKSB0aGlzLmF2ZXJhZ2VQZXJmLmFkZFNhbXBsZSh0aW1lKTtcclxuICAgICAgICBpZiAodGhpcy52aXNpYmxlUmVjdC5oZWlnaHQgPiAwKSB7XHJcbiAgICAgICAgICAgIGxldCBvID0gTWF0aC5hYnModGhpcy52ZWxvY2l0eS55ICogKHRoaXMuYXZlcmFnZVRpbWUudmFsdWUgKyB0aGlzLmF2ZXJhZ2VQZXJmLnZhbHVlKSk7XHJcbiAgICAgICAgICAgIHRoaXMub3ZlcnNjYW5ZLmFkZFNhbXBsZShvKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMudmlzaWJsZVJlY3Qud2lkdGggPiAwKSB7XHJcbiAgICAgICAgICAgIGxldCBvID0gTWF0aC5hYnModGhpcy52ZWxvY2l0eS54ICogKHRoaXMuYXZlcmFnZVRpbWUudmFsdWUgKyB0aGlzLmF2ZXJhZ2VQZXJmLnZhbHVlKSk7XHJcbiAgICAgICAgICAgIHRoaXMub3ZlcnNjYW5YLmFkZFNhbXBsZShvKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRPdmVyc2Nhbm5lZFJlY3QoKSB7XHJcbiAgICAgICAgbGV0IG92ZXJzY2FubmVkID0gdGhpcy52aXNpYmxlUmVjdC5jb3B5KCk7XHJcbiAgICAgICAgbGV0IG92ZXJzY2FuWSA9IE1hdGgucm91bmQoTWF0aC5taW4odGhpcy52aXNpYmxlUmVjdC5oZWlnaHQgKiAyLCB0aGlzLm92ZXJzY2FuWS52YWx1ZSkgLyAxMDApICogMTAwO1xyXG4gICAgICAgIGlmICh0aGlzLnZlbG9jaXR5LnkgPiAwKSB7XHJcbiAgICAgICAgICAgIG92ZXJzY2FubmVkLnkgLT0gb3ZlcnNjYW5ZICogMC4yO1xyXG4gICAgICAgICAgICBvdmVyc2Nhbm5lZC5oZWlnaHQgKz0gb3ZlcnNjYW5ZICsgb3ZlcnNjYW5ZICogMC4yO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG92ZXJzY2FubmVkLnkgLT0gb3ZlcnNjYW5ZO1xyXG4gICAgICAgICAgICBvdmVyc2Nhbm5lZC5oZWlnaHQgKz0gb3ZlcnNjYW5ZICsgb3ZlcnNjYW5ZICogMC4yO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgb3ZlcnNjYW5YID0gTWF0aC5yb3VuZChNYXRoLm1pbih0aGlzLnZpc2libGVSZWN0LndpZHRoICogMiwgdGhpcy5vdmVyc2NhblgudmFsdWUpIC8gMTAwKSAqIDEwMDtcclxuICAgICAgICBpZiAodGhpcy52ZWxvY2l0eS54ID4gMCkge1xyXG4gICAgICAgICAgICBvdmVyc2Nhbm5lZC54IC09IG92ZXJzY2FuWCAqIDAuMjtcclxuICAgICAgICAgICAgb3ZlcnNjYW5uZWQud2lkdGggKz0gb3ZlcnNjYW5YICsgb3ZlcnNjYW5YICogMC4yO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG92ZXJzY2FubmVkLnggLT0gb3ZlcnNjYW5YO1xyXG4gICAgICAgICAgICBvdmVyc2Nhbm5lZC53aWR0aCArPSBvdmVyc2NhblggKyBvdmVyc2NhblggKiAwLjI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvdmVyc2Nhbm5lZDtcclxuICAgIH1cclxuICAgIGNvbnN0cnVjdG9yKCl7XHJcbiAgICAgICAgdGhpcy5zdGFydFRpbWUgPSAwO1xyXG4gICAgICAgIHRoaXMuYXZlcmFnZVBlcmYgPSBuZXcgJDM2NDE5MWIzZGVjZjM2OTckdmFyJFJvbGxpbmdBdmVyYWdlKCk7XHJcbiAgICAgICAgdGhpcy5hdmVyYWdlVGltZSA9IG5ldyAkMzY0MTkxYjNkZWNmMzY5NyR2YXIkUm9sbGluZ0F2ZXJhZ2UoKTtcclxuICAgICAgICB0aGlzLnZlbG9jaXR5ID0gbmV3ICgwLCAkMzA0MWRiMzI5Njk0NWU2ZSRleHBvcnQkYmFmMjYxNDZhNDE0ZjI0YSkoNSwgNSk7XHJcbiAgICAgICAgdGhpcy5vdmVyc2NhblggPSBuZXcgJDM2NDE5MWIzZGVjZjM2OTckdmFyJFJvbGxpbmdBdmVyYWdlKCk7XHJcbiAgICAgICAgdGhpcy5vdmVyc2NhblkgPSBuZXcgJDM2NDE5MWIzZGVjZjM2OTckdmFyJFJvbGxpbmdBdmVyYWdlKCk7XHJcbiAgICAgICAgdGhpcy52aXNpYmxlUmVjdCA9IG5ldyAoMCwgJDYwNDIzZjkyYzdmOWFkODckZXhwb3J0JGM3OWZjNjQ5MmYzYWYxM2QpKCk7XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuLypcclxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcclxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXHJcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxyXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi8gY2xhc3MgJDhlMTM1ZTUzMWQ4ZGNiNjYkZXhwb3J0JGZlYmM1NTczYzc1Y2VmYjAge1xyXG4gICAgY29uc3RydWN0b3IoKXtcclxuICAgICAgICB0aGlzLmxldmVsID0gMDtcclxuICAgICAgICB0aGlzLmFjdGlvbnMgPSBbXTtcclxuICAgICAgICB0aGlzLmFuaW1hdGVkID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmluaXRpYWxNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5maW5hbE1hcCA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLmluaXRpYWxMYXlvdXRJbmZvID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuZmluYWxMYXlvdXRJbmZvID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMucmVtb3ZlZCA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLnRvUmVtb3ZlID0gbmV3IE1hcCgpO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuY2xhc3MgJDM4Yjk0OTBjMWNjYThmYzQkZXhwb3J0JDg5YmU1YTI0M2U1OWM0YjIge1xyXG4gICAgX3NldENvbnRlbnRTaXplKHNpemUpIHtcclxuICAgICAgICB0aGlzLl9jb250ZW50U2l6ZSA9IHNpemU7XHJcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZS5zZXRDb250ZW50U2l6ZShzaXplKTtcclxuICAgIH1cclxuICAgIF9zZXRDb250ZW50T2Zmc2V0KG9mZnNldCkge1xyXG4gICAgICAgIGxldCByZWN0ID0gbmV3ICgwLCAkNjA0MjNmOTJjN2Y5YWQ4NyRleHBvcnQkYzc5ZmM2NDkyZjNhZjEzZCkob2Zmc2V0LngsIG9mZnNldC55LCB0aGlzLl92aXNpYmxlUmVjdC53aWR0aCwgdGhpcy5fdmlzaWJsZVJlY3QuaGVpZ2h0KTtcclxuICAgICAgICB0aGlzLmRlbGVnYXRlLnNldFZpc2libGVSZWN0KHJlY3QpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICogR2V0IHRoZSBzaXplIG9mIHRoZSBzY3JvbGxhYmxlIGNvbnRlbnQuXHJcbiAgICovIGdldCBjb250ZW50U2l6ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY29udGVudFNpemU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgKiBHZXQgdGhlIGNvbGxlY3Rpb24gdmlldydzIGN1cnJlbnRseSB2aXNpYmxlIHJlY3RhbmdsZS5cclxuICAgKi8gZ2V0IHZpc2libGVSZWN0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl92aXNpYmxlUmVjdDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAqIFNldCB0aGUgY29sbGVjdGlvbiB2aWV3J3MgY3VycmVudGx5IHZpc2libGUgcmVjdGFuZ2xlLlxyXG4gICAqLyBzZXQgdmlzaWJsZVJlY3QocmVjdCkge1xyXG4gICAgICAgIHRoaXMuX3NldFZpc2libGVSZWN0KHJlY3QpO1xyXG4gICAgfVxyXG4gICAgX3NldFZpc2libGVSZWN0KHJlY3QsIGZvcmNlVXBkYXRlID0gZmFsc2UpIHtcclxuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuX3Zpc2libGVSZWN0O1xyXG4gICAgICAgIC8vIElnbm9yZSBpZiB0aGUgcmVjdHMgYXJlIGVxdWFsXHJcbiAgICAgICAgaWYgKHJlY3QuZXF1YWxzKGN1cnJlbnQpKSByZXR1cm47XHJcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkT3ZlcnNjYW4pIHRoaXMuX292ZXJzY2FuTWFuYWdlci5zZXRWaXNpYmxlUmVjdChyZWN0KTtcclxuICAgICAgICBsZXQgc2hvdWxkSW52YWxpZGF0ZSA9IHRoaXMubGF5b3V0ICYmIHRoaXMubGF5b3V0LnNob3VsZEludmFsaWRhdGUocmVjdCwgdGhpcy5fdmlzaWJsZVJlY3QpO1xyXG4gICAgICAgIHRoaXMuX3Jlc2V0QW5pbWF0ZWRDb250ZW50T2Zmc2V0KCk7XHJcbiAgICAgICAgdGhpcy5fdmlzaWJsZVJlY3QgPSByZWN0O1xyXG4gICAgICAgIGlmIChzaG91bGRJbnZhbGlkYXRlKSAvLyBXZSBhcmUgYWxyZWFkeSBpbiBhIGxheW91dCBlZmZlY3Qgd2hlbiB0aGlzIG1ldGhvZCBpcyBjYWxsZWQsIHNvIHJlbGF5b3V0Tm93IGlzIGFwcHJvcHJpYXRlLlxyXG4gICAgICAgIHRoaXMucmVsYXlvdXROb3coe1xyXG4gICAgICAgICAgICBvZmZzZXRDaGFuZ2VkOiAhcmVjdC5wb2ludEVxdWFscyhjdXJyZW50KSxcclxuICAgICAgICAgICAgc2l6ZUNoYW5nZWQ6ICFyZWN0LnNpemVFcXVhbHMoY3VycmVudClcclxuICAgICAgICB9KTtcclxuICAgICAgICBlbHNlIHRoaXMudXBkYXRlU3Vidmlld3MoZm9yY2VVcGRhdGUpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGNvbGxlY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbGxlY3Rpb247XHJcbiAgICB9XHJcbiAgICBzZXQgY29sbGVjdGlvbihkYXRhKSB7XHJcbiAgICAgICAgdGhpcy5fc2V0RGF0YShkYXRhKTtcclxuICAgIH1cclxuICAgIF9zZXREYXRhKGRhdGEpIHtcclxuICAgICAgICBpZiAoZGF0YSA9PT0gdGhpcy5fY29sbGVjdGlvbikgcmV0dXJuO1xyXG4gICAgICAgIGlmICh0aGlzLl9jb2xsZWN0aW9uKSB0aGlzLl9ydW5UcmFuc2FjdGlvbigoKT0+e1xyXG4gICAgICAgICAgICB0aGlzLl9jb2xsZWN0aW9uID0gZGF0YTtcclxuICAgICAgICB9LCB0aGlzLnRyYW5zaXRpb25EdXJhdGlvbiA+IDApO1xyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9jb2xsZWN0aW9uID0gZGF0YTtcclxuICAgICAgICAgICAgdGhpcy5yZWxvYWREYXRhKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICogUmVsb2FkcyB0aGUgZGF0YSBmcm9tIHRoZSBkYXRhIHNvdXJjZSBhbmQgcmVsYXlvdXRzIHRoZSBjb2xsZWN0aW9uIHZpZXcuXHJcbiAgICogRG9lcyBub3QgYW5pbWF0ZSBhbnkgY2hhbmdlcy4gRXF1aXZhbGVudCB0byByZS1hc3NpZ25pbmcgdGhlIHNhbWUgZGF0YSBzb3VyY2VcclxuICAgKiB0byB0aGUgY29sbGVjdGlvbiB2aWV3LlxyXG4gICAqLyByZWxvYWREYXRhKCkge1xyXG4gICAgICAgIHRoaXMucmVsYXlvdXQoe1xyXG4gICAgICAgICAgICBjb250ZW50Q2hhbmdlZDogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgaXRlbSB3aXRoIHRoZSBnaXZlbiBrZXkuXHJcbiAgICovIGdldEl0ZW0oa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbGxlY3Rpb24gPyB0aGlzLl9jb2xsZWN0aW9uLmdldEl0ZW0oa2V5KSA6IG51bGw7XHJcbiAgICB9XHJcbiAgICAvKiogVGhlIHNldCBvZiBwZXJzaXN0ZWQga2V5cyBhcmUgYWx3YXlzIHByZXNlbnQgaW4gdGhlIERPTSwgZXZlbiBpZiBub3QgY3VycmVudGx5IGluIHZpZXcuICovIGdldCBwZXJzaXN0ZWRLZXlzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9wZXJzaXN0ZWRLZXlzO1xyXG4gICAgfVxyXG4gICAgLyoqIFRoZSBzZXQgb2YgcGVyc2lzdGVkIGtleXMgYXJlIGFsd2F5cyBwcmVzZW50IGluIHRoZSBET00sIGV2ZW4gaWYgbm90IGN1cnJlbnRseSBpbiB2aWV3LiAqLyBzZXQgcGVyc2lzdGVkS2V5cyhwZXJzaXN0ZWRLZXlzKSB7XHJcbiAgICAgICAgaWYgKCEoMCwgJGZjMzZmOWEwNDZhOWNlNzkkZXhwb3J0JGE4ZDBkMGM4ZDFjNWRmNjQpKHBlcnNpc3RlZEtleXMsIHRoaXMuX3BlcnNpc3RlZEtleXMpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3BlcnNpc3RlZEtleXMgPSBwZXJzaXN0ZWRLZXlzO1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN1YnZpZXdzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqIFJldHVybnMgd2hldGhlciB0aGUgZ2l2ZW4ga2V5LCBvciBhbiBhbmNlc3RvciwgaXMgcGVyc2lzdGVkLiAqLyBpc1BlcnNpc3RlZEtleShrZXkpIHtcclxuICAgICAgICAvLyBRdWljayBjaGVjayBpZiB0aGUga2V5IGlzIGRpcmVjdGx5IGluIHRoZSBzZXQgb2YgcGVyc2lzdGVkIGtleXMuXHJcbiAgICAgICAgaWYgKHRoaXMuX3BlcnNpc3RlZEtleXMuaGFzKGtleSkpIHJldHVybiB0cnVlO1xyXG4gICAgICAgIC8vIElmIG5vdCwgY2hlY2sgaWYgdGhlIGtleSBpcyBhbiBhbmNlc3RvciBvZiBhbnkgb2YgdGhlIHBlcnNpc3RlZCBrZXlzLlxyXG4gICAgICAgIGZvciAobGV0IGsgb2YgdGhpcy5fcGVyc2lzdGVkS2V5cyl3aGlsZShrICE9IG51bGwpe1xyXG4gICAgICAgICAgICBsZXQgbGF5b3V0SW5mbyA9IHRoaXMubGF5b3V0LmdldExheW91dEluZm8oayk7XHJcbiAgICAgICAgICAgIGlmICghbGF5b3V0SW5mbykgYnJlYWs7XHJcbiAgICAgICAgICAgIGsgPSBsYXlvdXRJbmZvLnBhcmVudEtleTtcclxuICAgICAgICAgICAgaWYgKGsgPT09IGtleSkgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAqIEdldCB0aGUgY29sbGVjdGlvbiB2aWV3J3MgbGF5b3V0LlxyXG4gICAqLyBnZXQgbGF5b3V0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9sYXlvdXQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgKiBTZXQgdGhlIGNvbGxlY3Rpb24gdmlldydzIGxheW91dC5cclxuICAgKi8gc2V0IGxheW91dChsYXlvdXQpIHtcclxuICAgICAgICB0aGlzLnNldExheW91dChsYXlvdXQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICogU2V0cyB0aGUgY29sbGVjdGlvbiB2aWV3J3MgbGF5b3V0LCBvcHRpb25hbGx5IHdpdGggYW4gYW5pbWF0ZWQgdHJhbnNpdGlvblxyXG4gICAqIGZyb20gdGhlIGN1cnJlbnQgbGF5b3V0IHRvIHRoZSBuZXcgbGF5b3V0LlxyXG4gICAqIEBwYXJhbSBsYXlvdXQgVGhlIGxheW91dCB0byBzd2l0Y2ggdG8uXHJcbiAgICogQHBhcmFtIGFuaW1hdGVkIFdoZXRoZXIgdG8gYW5pbWF0ZSB0aGUgbGF5b3V0IGNoYW5nZS5cclxuICAgKi8gc2V0TGF5b3V0KGxheW91dCwgYW5pbWF0ZWQgPSBmYWxzZSkge1xyXG4gICAgICAgIGlmIChsYXlvdXQgPT09IHRoaXMuX2xheW91dCkgcmV0dXJuO1xyXG4gICAgICAgIGxldCBhcHBseUxheW91dCA9ICgpPT57XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9sYXlvdXQpIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICAgICAgdGhpcy5fbGF5b3V0LnZpcnR1YWxpemVyID0gbnVsbDtcclxuICAgICAgICAgICAgbGF5b3V0LnZpcnR1YWxpemVyID0gdGhpcztcclxuICAgICAgICAgICAgdGhpcy5fbGF5b3V0ID0gbGF5b3V0O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKGFuaW1hdGVkKSAvLyBBbmltYXRlZCBsYXlvdXQgdHJhbnNpdGlvbnMgYXJlIHJlYWxseSBzaW1wbGUsIHRoYW5rcyB0byBvdXIgdHJhbnNhY3Rpb24gc3VwcG9ydC5cclxuICAgICAgICAvLyBXZSBqdXN0IHNldCB0aGUgbGF5b3V0IGluc2lkZSBhIHRyYW5zYWN0aW9uIGFjdGlvbiwgd2hpY2ggcnVucyBhZnRlciB0aGUgaW5pdGlhbFxyXG4gICAgICAgIC8vIGxheW91dCBpbmZvcyBmb3IgdGhlIGFuaW1hdGlvbiBhcmUgcmV0cmlldmVkIGZyb20gdGhlIHByZXZpb3VzIGxheW91dC4gVGhlbiwgdGhlXHJcbiAgICAgICAgLy8gZmluYWwgbGF5b3V0IGluZm9zIGFyZSByZXRyaWV2ZWQgZnJvbSB0aGUgbmV3IGxheW91dCwgYW5kIGFuaW1hdGlvbnMgb2NjdXIuXHJcbiAgICAgICAgdGhpcy5fcnVuVHJhbnNhY3Rpb24oYXBwbHlMYXlvdXQpO1xyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBhcHBseUxheW91dCgpO1xyXG4gICAgICAgICAgICB0aGlzLnJlbGF5b3V0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2dldFJldXNlVHlwZShsYXlvdXRJbmZvLCBjb250ZW50KSB7XHJcbiAgICAgICAgaWYgKGxheW91dEluZm8udHlwZSA9PT0gXCJpdGVtXCIgJiYgY29udGVudCkge1xyXG4gICAgICAgICAgICBsZXQgdHlwZSA9IHRoaXMuZGVsZWdhdGUuZ2V0VHlwZSA/IHRoaXMuZGVsZWdhdGUuZ2V0VHlwZShjb250ZW50KSA6IFwiaXRlbVwiO1xyXG4gICAgICAgICAgICBsZXQgcmV1c2VUeXBlID0gdHlwZSA9PT0gXCJpdGVtXCIgPyBcIml0ZW1cIiA6IGxheW91dEluZm8udHlwZSArIFwiX1wiICsgdHlwZTtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXHJcbiAgICAgICAgICAgICAgICByZXVzZVR5cGU6IHJldXNlVHlwZVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiBsYXlvdXRJbmZvLnR5cGUsXHJcbiAgICAgICAgICAgIHJldXNlVHlwZTogbGF5b3V0SW5mby50eXBlXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGdldFJldXNhYmxlVmlldyhsYXlvdXRJbmZvKSB7XHJcbiAgICAgICAgbGV0IGNvbnRlbnQgPSB0aGlzLmdldEl0ZW0obGF5b3V0SW5mby5rZXkpO1xyXG4gICAgICAgIGxldCB7IHJldXNlVHlwZTogcmV1c2VUeXBlIH0gPSB0aGlzLl9nZXRSZXVzZVR5cGUobGF5b3V0SW5mbywgY29udGVudCk7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9yZXVzYWJsZVZpZXdzW3JldXNlVHlwZV0pIHRoaXMuX3JldXNhYmxlVmlld3NbcmV1c2VUeXBlXSA9IFtdO1xyXG4gICAgICAgIGxldCByZXVzYWJsZSA9IHRoaXMuX3JldXNhYmxlVmlld3NbcmV1c2VUeXBlXTtcclxuICAgICAgICBsZXQgdmlldyA9IHJldXNhYmxlLmxlbmd0aCA+IDAgPyByZXVzYWJsZS5wb3AoKSA6IG5ldyAoMCwgJGFkMWQ5OGFhOGYwYzMxYjQkZXhwb3J0JDFhNTIyMzg4N2M1NjA0NDEpKHRoaXMpO1xyXG4gICAgICAgIHZpZXcudmlld1R5cGUgPSByZXVzZVR5cGU7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9hbmltYXRlZENvbnRlbnRPZmZzZXQuaXNPcmlnaW4oKSkge1xyXG4gICAgICAgICAgICBsYXlvdXRJbmZvID0gbGF5b3V0SW5mby5jb3B5KCk7XHJcbiAgICAgICAgICAgIGxheW91dEluZm8ucmVjdC54ICs9IHRoaXMuX2FuaW1hdGVkQ29udGVudE9mZnNldC54O1xyXG4gICAgICAgICAgICBsYXlvdXRJbmZvLnJlY3QueSArPSB0aGlzLl9hbmltYXRlZENvbnRlbnRPZmZzZXQueTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmlldy5sYXlvdXRJbmZvID0gbGF5b3V0SW5mbztcclxuICAgICAgICB0aGlzLl9yZW5kZXJWaWV3KHZpZXcpO1xyXG4gICAgICAgIHJldHVybiB2aWV3O1xyXG4gICAgfVxyXG4gICAgX3JlbmRlclZpZXcocmV1c2FibGVWaWV3KSB7XHJcbiAgICAgICAgbGV0IHsgdHlwZTogdHlwZSwga2V5OiBrZXkgfSA9IHJldXNhYmxlVmlldy5sYXlvdXRJbmZvO1xyXG4gICAgICAgIHJldXNhYmxlVmlldy5jb250ZW50ID0gdGhpcy5nZXRJdGVtKGtleSk7XHJcbiAgICAgICAgcmV1c2FibGVWaWV3LnJlbmRlcmVkID0gdGhpcy5fcmVuZGVyQ29udGVudCh0eXBlLCByZXVzYWJsZVZpZXcuY29udGVudCk7XHJcbiAgICB9XHJcbiAgICBfcmVuZGVyQ29udGVudCh0eXBlLCBjb250ZW50KSB7XHJcbiAgICAgICAgbGV0IGNhY2hlZCA9IHRoaXMuX3JlbmRlcmVkQ29udGVudC5nZXQoY29udGVudCk7XHJcbiAgICAgICAgaWYgKGNhY2hlZCAhPSBudWxsKSByZXR1cm4gY2FjaGVkO1xyXG4gICAgICAgIGxldCByZW5kZXJlZCA9IHRoaXMuZGVsZWdhdGUucmVuZGVyVmlldyh0eXBlLCBjb250ZW50KTtcclxuICAgICAgICBpZiAoY29udGVudCkgdGhpcy5fcmVuZGVyZWRDb250ZW50LnNldChjb250ZW50LCByZW5kZXJlZCk7XHJcbiAgICAgICAgcmV0dXJuIHJlbmRlcmVkO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICogUmV0dXJucyBhbiBhcnJheSBvZiBhbGwgY3VycmVudGx5IHZpc2libGUgdmlld3MsIGluY2x1ZGluZyBib3RoXHJcbiAgICogaXRlbSB2aWV3cyBhbmQgc3VwcGxlbWVudGFyeSB2aWV3cy5cclxuICAgKi8gZ2V0IHZpc2libGVWaWV3cygpIHtcclxuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLl92aXNpYmxlVmlld3MudmFsdWVzKCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICogR2V0cyB0aGUgdmlzaWJsZSB2aWV3IGZvciB0aGUgZ2l2ZW4gdHlwZSBhbmQga2V5LiBSZXR1cm5zIG51bGwgaWZcclxuICAgKiB0aGUgdmlldyBpcyBub3QgY3VycmVudGx5IHZpc2libGUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIHZpZXcgdG8gcmV0cmlldmUuXHJcbiAgICovIGdldFZpZXcoa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2libGVWaWV3cy5nZXQoa2V5KSB8fCBudWxsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICogUmV0dXJucyBhbiBhcnJheSBvZiB2aXNpYmxlIHZpZXdzIG1hdGNoaW5nIHRoZSBnaXZlbiB0eXBlLlxyXG4gICAqIEBwYXJhbSB0eXBlIFRoZSB2aWV3IHR5cGUgdG8gZmluZC5cclxuICAgKi8gZ2V0Vmlld3NPZlR5cGUodHlwZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZpc2libGVWaWV3cy5maWx0ZXIoKHYpPT52LmxheW91dEluZm8gJiYgdi5sYXlvdXRJbmZvLnR5cGUgPT09IHR5cGUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUga2V5IGZvciB0aGUgZ2l2ZW4gdmlldy4gUmV0dXJucyBudWxsXHJcbiAgICogaWYgdGhlIHZpZXcgaXMgbm90IGN1cnJlbnRseSB2aXNpYmxlLlxyXG4gICAqLyBrZXlGb3JWaWV3KHZpZXcpIHtcclxuICAgICAgICBpZiAodmlldyAmJiB2aWV3LmxheW91dEluZm8pIHJldHVybiB2aWV3LmxheW91dEluZm8ua2V5O1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUga2V5IGZvciB0aGUgaXRlbSB2aWV3IGN1cnJlbnRseSBhdCB0aGUgZ2l2ZW4gcG9pbnQuXHJcbiAgICovIGtleUF0UG9pbnQocG9pbnQpIHtcclxuICAgICAgICBsZXQgcmVjdCA9IG5ldyAoMCwgJDYwNDIzZjkyYzdmOWFkODckZXhwb3J0JGM3OWZjNjQ5MmYzYWYxM2QpKHBvaW50LngsIHBvaW50LnksIDEsIDEpO1xyXG4gICAgICAgIGxldCBsYXlvdXRJbmZvcyA9IHRoaXMubGF5b3V0LmdldFZpc2libGVMYXlvdXRJbmZvcyhyZWN0KTtcclxuICAgICAgICAvLyBMYXlvdXQgbWF5IHJldHVybiBtdWx0aXBsZSBsYXlvdXQgaW5mb3MgaW4gdGhlIGNhc2Ugb2ZcclxuICAgICAgICAvLyBwZXJzaXN0ZWQga2V5cywgc28gZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgYWN0dWFsbHkgaW50ZXJzZWN0cy5cclxuICAgICAgICBmb3IgKGxldCBsYXlvdXRJbmZvIG9mIGxheW91dEluZm9zKXtcclxuICAgICAgICAgICAgaWYgKGxheW91dEluZm8ucmVjdC5pbnRlcnNlY3RzKHJlY3QpKSByZXR1cm4gbGF5b3V0SW5mby5rZXk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICogQ2xlYW51cCBmb3Igd2hlbiB0aGUgVmlydHVhbGl6ZXIgd2lsbCBiZSB1bm1vdW50ZWQuXHJcbiAgICovIHdpbGxVbm1vdW50KCkge1xyXG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX3JlbGF5b3V0UmFmKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAqIFRyaWdnZXJzIGEgbGF5b3V0IGludmFsaWRhdGlvbiwgYW5kIHVwZGF0ZXMgdGhlIHZpc2libGUgc3Vidmlld3MuXHJcbiAgICovIHJlbGF5b3V0KGNvbnRleHQgPSB7fSkge1xyXG4gICAgICAgIC8vIElnbm9yZSByZWxheW91dHMgd2hpbGUgYW5pbWF0aW5nIHRoZSBzY3JvbGwgcG9zaXRpb25cclxuICAgICAgICBpZiAodGhpcy5fc2Nyb2xsQW5pbWF0aW9uIHx8IHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT09IFwidW5kZWZpbmVkXCIpIHJldHVybjtcclxuICAgICAgICAvLyBJZiB3ZSBhbHJlYWR5IHNjaGVkdWxlZCBhIHJlbGF5b3V0LCBleHRlbmQgdGhlIGludmFsaWRhdGlvblxyXG4gICAgICAgIC8vIGNvbnRleHQgc28gd2UgY29hbGVzY2UgbXVsdGlwbGUgcmVsYXlvdXRzIGluIHRoZSBzYW1lIGZyYW1lLlxyXG4gICAgICAgIGlmICh0aGlzLl9pbnZhbGlkYXRpb25Db250ZXh0KSB7XHJcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5faW52YWxpZGF0aW9uQ29udGV4dCwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5faW52YWxpZGF0aW9uQ29udGV4dCA9IGNvbnRleHQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgKiBQZXJmb3JtcyBhIHJlbGF5b3V0IGltbWVkaWF0ZWx5LiBQcmVmZXIge0BsaW5rIHJlbGF5b3V0fSBvdmVyIHRoaXMgbWV0aG9kXHJcbiAgICogd2hlcmUgcG9zc2libGUsIHNpbmNlIGl0IGNvYWxlc2NlcyBtdWx0aXBsZSBsYXlvdXQgcGFzc2VzIGluIHRoZSBzYW1lIHRpY2suXHJcbiAgICovIHJlbGF5b3V0Tm93KGNvbnRleHQgPSB0aGlzLl9pbnZhbGlkYXRpb25Db250ZXh0IHx8IHt9KSB7XHJcbiAgICAgICAgLy8gQ2FuY2VsIHRoZSBzY2hlZHVsZWQgcmVsYXlvdXQsIHNpbmNlIHdlJ3JlIGRvaW5nIGl0IG5vdy5cclxuICAgICAgICBpZiAodGhpcy5fcmVsYXlvdXRSYWYpIHtcclxuICAgICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5fcmVsYXlvdXRSYWYpO1xyXG4gICAgICAgICAgICB0aGlzLl9yZWxheW91dFJhZiA9IG51bGw7XHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgcHJvdmlkZWQgY29udGV4dCB3aXRoIHRoZSBjdXJyZW50IGludmFsaWRhdGlvbkNvbnRleHQgc2luY2Ugd2UgYXJlIGNhbmNlbGxpbmdcclxuICAgICAgICAgICAgLy8gYSBzY2hlZHVsZWQgcmVsYXlvdXROb3cgY2FsbCB0aGF0IGhhcyB0aGlzLl9pbnZhbGlkYXRpb25Db250ZXh0IHNldCBhcyBpdHMgZGVmYXVsdCBjb250ZXh0IGFyZyAocmVsYXlvdXROb3coKSBpbiByZWxheW91dClcclxuICAgICAgICAgICAgY29udGV4dCA9IHtcclxuICAgICAgICAgICAgICAgIC4uLnRoaXMuX2ludmFsaWRhdGlvbkNvbnRleHQsXHJcbiAgICAgICAgICAgICAgICAuLi5jb250ZXh0XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFJlc2V0IHRoZSBpbnZhbGlkYXRpb24gY29udGV4dFxyXG4gICAgICAgIHRoaXMuX2ludmFsaWRhdGlvbkNvbnRleHQgPSBudWxsO1xyXG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgd2UgZG9uJ3QgaGF2ZSBhIGxheW91dCBvciBjb250ZW50LCBvciB3ZSBhcmVcclxuICAgICAgICAvLyBpbiB0aGUgbWlkZGxlIG9mIGFuIGFuaW1hdGVkIHNjcm9sbCB0cmFuc2l0aW9uLlxyXG4gICAgICAgIGlmICghdGhpcy5sYXlvdXQgfHwgIXRoaXMuX2NvbGxlY3Rpb24gfHwgdGhpcy5fc2Nyb2xsQW5pbWF0aW9uKSByZXR1cm47XHJcbiAgICAgICAgbGV0IHNjcm9sbEFuY2hvciA9IHRoaXMuX2dldFNjcm9sbEFuY2hvcigpO1xyXG4gICAgICAgIC8vIFRyaWdnZXIgdGhlIGJlZm9yZUxheW91dCBob29rLCBpZiBwcm92aWRlZFxyXG4gICAgICAgIGlmICh0eXBlb2YgY29udGV4dC5iZWZvcmVMYXlvdXQgPT09IFwiZnVuY3Rpb25cIikgY29udGV4dC5iZWZvcmVMYXlvdXQoKTtcclxuICAgICAgICAvLyBWYWxpZGF0ZSB0aGUgbGF5b3V0XHJcbiAgICAgICAgdGhpcy5sYXlvdXQudmFsaWRhdGUoY29udGV4dCk7XHJcbiAgICAgICAgdGhpcy5fc2V0Q29udGVudFNpemUodGhpcy5sYXlvdXQuZ2V0Q29udGVudFNpemUoKSk7XHJcbiAgICAgICAgLy8gVHJpZ2dlciB0aGUgYWZ0ZXJMYXlvdXQgaG9vaywgaWYgcHJvdmlkZWRcclxuICAgICAgICBpZiAodHlwZW9mIGNvbnRleHQuYWZ0ZXJMYXlvdXQgPT09IFwiZnVuY3Rpb25cIikgY29udGV4dC5hZnRlckxheW91dCgpO1xyXG4gICAgICAgIC8vIEFkanVzdCBzY3JvbGwgcG9zaXRpb24gYmFzZWQgb24gc2Nyb2xsIGFuY2hvciwgYW5kIGNvbnN0cmFpbi5cclxuICAgICAgICAvLyBJZiB0aGUgY29udGVudCBjaGFuZ2VkLCBzY3JvbGwgdG8gdGhlIHRvcC5cclxuICAgICAgICBsZXQgdmlzaWJsZVJlY3QgPSB0aGlzLmdldFZpc2libGVSZWN0KCk7XHJcbiAgICAgICAgbGV0IHJlc3RvcmVkU2Nyb2xsQW5jaG9yID0gdGhpcy5fcmVzdG9yZVNjcm9sbEFuY2hvcihzY3JvbGxBbmNob3IsIGNvbnRleHQpO1xyXG4gICAgICAgIGxldCBjb250ZW50T2Zmc2V0WCA9IGNvbnRleHQuY29udGVudENoYW5nZWQgPyAwIDogcmVzdG9yZWRTY3JvbGxBbmNob3IueDtcclxuICAgICAgICBsZXQgY29udGVudE9mZnNldFkgPSBjb250ZXh0LmNvbnRlbnRDaGFuZ2VkID8gMCA6IHJlc3RvcmVkU2Nyb2xsQW5jaG9yLnk7XHJcbiAgICAgICAgY29udGVudE9mZnNldFggPSBNYXRoLm1heCgwLCBNYXRoLm1pbih0aGlzLmNvbnRlbnRTaXplLndpZHRoIC0gdmlzaWJsZVJlY3Qud2lkdGgsIGNvbnRlbnRPZmZzZXRYKSk7XHJcbiAgICAgICAgY29udGVudE9mZnNldFkgPSBNYXRoLm1heCgwLCBNYXRoLm1pbih0aGlzLmNvbnRlbnRTaXplLmhlaWdodCAtIHZpc2libGVSZWN0LmhlaWdodCwgY29udGVudE9mZnNldFkpKTtcclxuICAgICAgICBsZXQgaGFzTGF5b3V0VXBkYXRlcyA9IGZhbHNlO1xyXG4gICAgICAgIGlmIChjb250ZW50T2Zmc2V0WCAhPT0gdmlzaWJsZVJlY3QueCB8fCBjb250ZW50T2Zmc2V0WSAhPT0gdmlzaWJsZVJlY3QueSkge1xyXG4gICAgICAgICAgICAvLyBJZiB0aGlzIGlzIGFuIGFuaW1hdGVkIHJlbGF5b3V0LCB3ZSBkbyBub3QgaW1tZWRpYXRlbHkgc2Nyb2xsIGJlY2F1c2UgaXQgd291bGQgYmUgaml0dGVyeS5cclxuICAgICAgICAgICAgLy8gU2F2ZSB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBjdXJyZW50IGFuZCBuZXcgY29udGVudCBvZmZzZXRzLCBhbmQgYXBwbHkgaXQgdG8gdGhlXHJcbiAgICAgICAgICAgIC8vIGluZGl2aWR1YWwgY29udGVudCBpdGVtcyBpbnN0ZWFkLiBBdCB0aGUgZW5kIG9mIHRoZSBhbmltYXRpb24sIHdlJ2xsIHJlc2V0IGFuZCBzZXQgdGhlXHJcbiAgICAgICAgICAgIC8vIHNjcm9sbCBvZmZzZXQgZm9yIHJlYWwuIFRoaXMgZW5zdXJlcyBqaXR0ZXItZnJlZSBhbmltYXRpb24gc2luY2Ugd2UgZG9uJ3QgbmVlZCB0byBzeW5jXHJcbiAgICAgICAgICAgIC8vIHRoZSBzY3JvbGwgYW5pbWF0aW9uIGFuZCB0aGUgY29udGVudCBhbmltYXRpb24uXHJcbiAgICAgICAgICAgIGlmIChjb250ZXh0LmFuaW1hdGVkIHx8ICF0aGlzLl9hbmltYXRlZENvbnRlbnRPZmZzZXQuaXNPcmlnaW4oKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYW5pbWF0ZWRDb250ZW50T2Zmc2V0LnggKz0gdmlzaWJsZVJlY3QueCAtIGNvbnRlbnRPZmZzZXRYO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYW5pbWF0ZWRDb250ZW50T2Zmc2V0LnkgKz0gdmlzaWJsZVJlY3QueSAtIGNvbnRlbnRPZmZzZXRZO1xyXG4gICAgICAgICAgICAgICAgaGFzTGF5b3V0VXBkYXRlcyA9IHRoaXMudXBkYXRlU3Vidmlld3MoY29udGV4dC5jb250ZW50Q2hhbmdlZCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB0aGlzLl9zZXRDb250ZW50T2Zmc2V0KG5ldyAoMCwgJDMwNDFkYjMyOTY5NDVlNmUkZXhwb3J0JGJhZjI2MTQ2YTQxNGYyNGEpKGNvbnRlbnRPZmZzZXRYLCBjb250ZW50T2Zmc2V0WSkpO1xyXG4gICAgICAgIH0gZWxzZSBoYXNMYXlvdXRVcGRhdGVzID0gdGhpcy51cGRhdGVTdWJ2aWV3cyhjb250ZXh0LmNvbnRlbnRDaGFuZ2VkKTtcclxuICAgICAgICAvLyBBcHBseSBsYXlvdXQgaW5mb3MsIHVubGVzcyB0aGlzIGlzIGNvbWluZyBmcm9tIGFuIGFuaW1hdGVkIHRyYW5zYWN0aW9uXHJcbiAgICAgICAgaWYgKCEoY29udGV4dC50cmFuc2FjdGlvbiAmJiBjb250ZXh0LmFuaW1hdGVkKSkgdGhpcy5fYXBwbHlMYXlvdXRJbmZvcygpO1xyXG4gICAgICAgIC8vIFdhaXQgZm9yIGFuaW1hdGlvbnMsIGFuZCBhcHBseSB0aGUgYWZ0ZXJBbmltYXRpb24gaG9vaywgaWYgcHJvdmlkZWRcclxuICAgICAgICBpZiAoY29udGV4dC5hbmltYXRlZCAmJiBoYXNMYXlvdXRVcGRhdGVzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2VuYWJsZVRyYW5zaXRpb25zKCk7XHJcbiAgICAgICAgICAgIGxldCBkb25lID0gKCk9PntcclxuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc2FibGVUcmFuc2l0aW9ucygpO1xyXG4gICAgICAgICAgICAgICAgLy8gUmVzZXQgc2Nyb2xsIHBvc2l0aW9uIGFmdGVyIGFuaW1hdGlvbnMgKHNlZSBhYm92ZSBjb21tZW50KS5cclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fYW5pbWF0ZWRDb250ZW50T2Zmc2V0LmlzT3JpZ2luKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIGNvbnRlbnQgb2Zmc2V0IHRvIHNjcm9sbCB0bywgdGFraW5nIF9hbmltYXRlZENvbnRlbnRPZmZzZXQgaW50byBhY2NvdW50LlxyXG4gICAgICAgICAgICAgICAgICAgIGxldCB7IHg6IHgsIHk6IHkgfSA9IHRoaXMuZ2V0VmlzaWJsZVJlY3QoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXNldEFuaW1hdGVkQ29udGVudE9mZnNldCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldENvbnRlbnRPZmZzZXQobmV3ICgwLCAkMzA0MWRiMzI5Njk0NWU2ZSRleHBvcnQkYmFmMjYxNDZhNDE0ZjI0YSkoeCwgeSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZXh0LmFmdGVyQW5pbWF0aW9uID09PSBcImZ1bmN0aW9uXCIpIGNvbnRleHQuYWZ0ZXJBbmltYXRpb24oKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLy8gU29tZXRpbWVzIHRoZSBhbmltYXRpb24gdGFrZXMgc2xpZ2h0bHkgbG9uZ2VyIHRoYW4gZXhwZWN0ZWQuXHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZG9uZSwgdGhpcy50cmFuc2l0aW9uRHVyYXRpb24gKyAxMDApO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY29udGV4dC5hZnRlckFuaW1hdGlvbiA9PT0gXCJmdW5jdGlvblwiKSBjb250ZXh0LmFmdGVyQW5pbWF0aW9uKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgKiBDb3JyZWN0cyBET00gb3JkZXIgb2YgdmlzaWJsZSB2aWV3cyB0byBtYXRjaCBpdGVtIG9yZGVyIG9mIGNvbGxlY3Rpb24uXHJcbiAgICovIF9jb3JyZWN0SXRlbU9yZGVyKCkge1xyXG4gICAgICAgIC8vIERlZmVyIHVudGlsIGFmdGVyIHNjcm9sbGluZyBhbmQgYW5pbWF0ZWQgdHJhbnNhY3Rpb25zIGFyZSBjb21wbGV0ZVxyXG4gICAgICAgIGlmICh0aGlzLl9pc1Njcm9sbGluZyB8fCB0aGlzLl90cmFuc2FjdGlvbikgcmV0dXJuO1xyXG4gICAgICAgIGZvciAobGV0IGtleSBvZiB0aGlzLl92aXNpYmxlTGF5b3V0SW5mb3Mua2V5cygpKXtcclxuICAgICAgICAgICAgbGV0IHZpZXcgPSB0aGlzLl92aXNpYmxlVmlld3MuZ2V0KGtleSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2NoaWxkcmVuLmRlbGV0ZSh2aWV3KTtcclxuICAgICAgICAgICAgdGhpcy5fY2hpbGRyZW4uYWRkKHZpZXcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9lbmFibGVUcmFuc2l0aW9ucygpIHtcclxuICAgICAgICB0aGlzLmRlbGVnYXRlLmJlZ2luQW5pbWF0aW9ucygpO1xyXG4gICAgfVxyXG4gICAgX2Rpc2FibGVUcmFuc2l0aW9ucygpIHtcclxuICAgICAgICB0aGlzLmRlbGVnYXRlLmVuZEFuaW1hdGlvbnMoKTtcclxuICAgIH1cclxuICAgIF9nZXRTY3JvbGxBbmNob3IoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmFuY2hvclNjcm9sbFBvc2l0aW9uKSByZXR1cm4gbnVsbDtcclxuICAgICAgICBsZXQgdmlzaWJsZVJlY3QgPSB0aGlzLmdldFZpc2libGVSZWN0KCk7XHJcbiAgICAgICAgLy8gQXNrIHRoZSBkZWxlZ2F0ZSB0byBwcm92aWRlIGEgc2Nyb2xsIGFuY2hvciwgaWYgcG9zc2libGVcclxuICAgICAgICBpZiAodGhpcy5kZWxlZ2F0ZS5nZXRTY3JvbGxBbmNob3IpIHtcclxuICAgICAgICAgICAgbGV0IGtleSA9IHRoaXMuZGVsZWdhdGUuZ2V0U2Nyb2xsQW5jaG9yKHZpc2libGVSZWN0KTtcclxuICAgICAgICAgICAgaWYgKGtleSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgbGF5b3V0SW5mbyA9IHRoaXMubGF5b3V0LmdldExheW91dEluZm8oa2V5KTtcclxuICAgICAgICAgICAgICAgIGxldCBjb3JuZXIgPSBsYXlvdXRJbmZvLnJlY3QuZ2V0Q29ybmVySW5SZWN0KHZpc2libGVSZWN0KTtcclxuICAgICAgICAgICAgICAgIGlmIChjb3JuZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQga2V5ID0gbGF5b3V0SW5mby5rZXk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9mZnNldCA9IGxheW91dEluZm8ucmVjdFtjb3JuZXJdLnkgLSB2aXNpYmxlUmVjdC55O1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleToga2V5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXlvdXRJbmZvOiBsYXlvdXRJbmZvLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3JuZXI6IGNvcm5lcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXRcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE5vIG5lZWQgdG8gYW5jaG9yIHRoZSBzY3JvbGwgcG9zaXRpb24gaWYgaXQgaXMgYXQgdGhlIHRvcFxyXG4gICAgICAgIGlmICh2aXNpYmxlUmVjdC55ID09PSAwICYmICF0aGlzLmFuY2hvclNjcm9sbFBvc2l0aW9uQXRUb3ApIHJldHVybiBudWxsO1xyXG4gICAgICAgIC8vIEZpbmQgYSB2aWV3IHdpdGggYSB2aXNpYmxlIGNvcm5lciB0aGF0IGhhcyB0aGUgc21hbGxlc3QgZGlzdGFuY2UgdG8gdGhlIHRvcCBvZiB0aGUgY29sbGVjdGlvbiB2aWV3XHJcbiAgICAgICAgbGV0IGNvcm5lckFuY2hvciA9IG51bGw7XHJcbiAgICAgICAgZm9yIChsZXQgW2tleSwgdmlld10gb2YgdGhpcy5fdmlzaWJsZVZpZXdzKXtcclxuICAgICAgICAgICAgbGV0IGxheW91dEluZm8gPSB2aWV3LmxheW91dEluZm87XHJcbiAgICAgICAgICAgIGlmIChsYXlvdXRJbmZvICYmIGxheW91dEluZm8ucmVjdC5hcmVhID4gMCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGNvcm5lciA9IGxheW91dEluZm8ucmVjdC5nZXRDb3JuZXJJblJlY3QodmlzaWJsZVJlY3QpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvcm5lcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBvZmZzZXQgPSBsYXlvdXRJbmZvLnJlY3RbY29ybmVyXS55IC0gdmlzaWJsZVJlY3QueTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvcm5lckFuY2hvciB8fCBvZmZzZXQgPCBjb3JuZXJBbmNob3Iub2Zmc2V0KSBjb3JuZXJBbmNob3IgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleToga2V5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXlvdXRJbmZvOiBsYXlvdXRJbmZvLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3JuZXI6IGNvcm5lcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXRcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb3JuZXJBbmNob3I7XHJcbiAgICB9XHJcbiAgICBfcmVzdG9yZVNjcm9sbEFuY2hvcihzY3JvbGxBbmNob3IsIGNvbnRleHQpIHtcclxuICAgICAgICBsZXQgY29udGVudE9mZnNldCA9IHRoaXMuZ2V0VmlzaWJsZVJlY3QoKTtcclxuICAgICAgICBpZiAoc2Nyb2xsQW5jaG9yKSB7XHJcbiAgICAgICAgICAgIHZhciBfY29udGV4dF90cmFuc2FjdGlvbjtcclxuICAgICAgICAgICAgbGV0IGZpbmFsQW5jaG9yID0gKChfY29udGV4dF90cmFuc2FjdGlvbiA9IGNvbnRleHQudHJhbnNhY3Rpb24pID09PSBudWxsIHx8IF9jb250ZXh0X3RyYW5zYWN0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfY29udGV4dF90cmFuc2FjdGlvbi5hbmltYXRlZCkgPyBjb250ZXh0LnRyYW5zYWN0aW9uLmZpbmFsTWFwLmdldChzY3JvbGxBbmNob3Iua2V5KSA6IHRoaXMubGF5b3V0LmdldExheW91dEluZm8oc2Nyb2xsQW5jaG9yLmxheW91dEluZm8ua2V5KTtcclxuICAgICAgICAgICAgaWYgKGZpbmFsQW5jaG9yKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgYWRqdXN0bWVudCA9IGZpbmFsQW5jaG9yLnJlY3Rbc2Nyb2xsQW5jaG9yLmNvcm5lcl0ueSAtIGNvbnRlbnRPZmZzZXQueSAtIHNjcm9sbEFuY2hvci5vZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICBjb250ZW50T2Zmc2V0LnkgKz0gYWRqdXN0bWVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY29udGVudE9mZnNldDtcclxuICAgIH1cclxuICAgIGdldFZpc2libGVSZWN0KCkge1xyXG4gICAgICAgIGxldCB2ID0gdGhpcy52aXNpYmxlUmVjdDtcclxuICAgICAgICBsZXQgeCA9IHYueCAtIHRoaXMuX2FuaW1hdGVkQ29udGVudE9mZnNldC54O1xyXG4gICAgICAgIGxldCB5ID0gdi55IC0gdGhpcy5fYW5pbWF0ZWRDb250ZW50T2Zmc2V0Lnk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyAoMCwgJDYwNDIzZjkyYzdmOWFkODckZXhwb3J0JGM3OWZjNjQ5MmYzYWYxM2QpKHgsIHksIHYud2lkdGgsIHYuaGVpZ2h0KTtcclxuICAgIH1cclxuICAgIGdldFZpc2libGVMYXlvdXRJbmZvcygpIHtcclxuICAgICAgICBsZXQgcmVjdCA9IHRoaXMuc2hvdWxkT3ZlcnNjYW4gPyB0aGlzLl9vdmVyc2Nhbk1hbmFnZXIuZ2V0T3ZlcnNjYW5uZWRSZWN0KCkgOiB0aGlzLmdldFZpc2libGVSZWN0KCk7XHJcbiAgICAgICAgdGhpcy5fdmlzaWJsZUxheW91dEluZm9zID0gdGhpcy5fZ2V0TGF5b3V0SW5mb01hcChyZWN0KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdmlzaWJsZUxheW91dEluZm9zO1xyXG4gICAgfVxyXG4gICAgX2dldExheW91dEluZm9NYXAocmVjdCwgY29weSA9IGZhbHNlKSB7XHJcbiAgICAgICAgbGV0IGxheW91dEluZm9zID0gdGhpcy5sYXlvdXQuZ2V0VmlzaWJsZUxheW91dEluZm9zKHJlY3QpO1xyXG4gICAgICAgIGxldCBtYXAgPSBuZXcgTWFwO1xyXG4gICAgICAgIGZvciAobGV0IGxheW91dEluZm8gb2YgbGF5b3V0SW5mb3Mpe1xyXG4gICAgICAgICAgICBpZiAoY29weSkgbGF5b3V0SW5mbyA9IGxheW91dEluZm8uY29weSgpO1xyXG4gICAgICAgICAgICBtYXAuc2V0KGxheW91dEluZm8ua2V5LCBsYXlvdXRJbmZvKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1hcDtcclxuICAgIH1cclxuICAgIHVwZGF0ZVN1YnZpZXdzKGZvcmNlVXBkYXRlID0gZmFsc2UpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2NvbGxlY3Rpb24pIHJldHVybjtcclxuICAgICAgICBsZXQgdmlzaWJsZUxheW91dEluZm9zID0gdGhpcy5nZXRWaXNpYmxlTGF5b3V0SW5mb3MoKTtcclxuICAgICAgICBsZXQgY3VycmVudGx5VmlzaWJsZSA9IHRoaXMuX3Zpc2libGVWaWV3cztcclxuICAgICAgICBsZXQgdG9BZGQsIHRvUmVtb3ZlLCB0b1VwZGF0ZTtcclxuICAgICAgICAvLyBJZiB0aGlzIGlzIGEgZm9yY2UgdXBkYXRlLCByZW1vdmUgYW5kIHJlLWFkZCBhbGwgdmlld3MuXHJcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBmaW5kIGFuZCB1cGRhdGUgdGhlIGRpZmYuXHJcbiAgICAgICAgaWYgKGZvcmNlVXBkYXRlKSB7XHJcbiAgICAgICAgICAgIHRvQWRkID0gdmlzaWJsZUxheW91dEluZm9zO1xyXG4gICAgICAgICAgICB0b1JlbW92ZSA9IGN1cnJlbnRseVZpc2libGU7XHJcbiAgICAgICAgICAgIHRvVXBkYXRlID0gbmV3IFNldCgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICh7IHRvQWRkOiB0b0FkZCwgdG9SZW1vdmU6IHRvUmVtb3ZlLCB0b1VwZGF0ZTogdG9VcGRhdGUgfSA9ICgwLCAkZmMzNmY5YTA0NmE5Y2U3OSRleHBvcnQkYWNhZjk2YTI3NDM4MjQ2YikoY3VycmVudGx5VmlzaWJsZSwgdmlzaWJsZUxheW91dEluZm9zKSk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGtleSBvZiB0b1VwZGF0ZSl7XHJcbiAgICAgICAgICAgICAgICBsZXQgdmlldyA9IGN1cnJlbnRseVZpc2libGUuZ2V0KGtleSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXZpZXcgfHwgIXZpZXcubGF5b3V0SW5mbykgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBsZXQgaXRlbSA9IHRoaXMuZ2V0SXRlbSh2aXNpYmxlTGF5b3V0SW5mb3MuZ2V0KGtleSkua2V5KTtcclxuICAgICAgICAgICAgICAgIGlmICh2aWV3LmNvbnRlbnQgPT09IGl0ZW0pIHRvVXBkYXRlLmRlbGV0ZShrZXkpO1xyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHZpZXcgdHlwZSBjaGFuZ2VzLCBkZWxldGUgYW5kIHJlY3JlYXRlIHRoZSB2aWV3IGluc3RlYWQgb2YgdXBkYXRpbmdcclxuICAgICAgICAgICAgICAgICAgICBsZXQgeyByZXVzZVR5cGU6IHJldXNlVHlwZSB9ID0gdGhpcy5fZ2V0UmV1c2VUeXBlKHZpZXcubGF5b3V0SW5mbywgaXRlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZpZXcudmlld1R5cGUgIT09IHJldXNlVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b1VwZGF0ZS5kZWxldGUoa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9BZGQuYWRkKGtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvUmVtb3ZlLmFkZChrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBXZSBhcmUgZG9uZSBpZiB0aGUgc2V0cyBhcmUgZXF1YWxcclxuICAgICAgICAgICAgaWYgKHRvQWRkLnNpemUgPT09IDAgJiYgdG9SZW1vdmUuc2l6ZSA9PT0gMCAmJiB0b1VwZGF0ZS5zaXplID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdHJhbnNhY3Rpb24pIHRoaXMuX2FwcGx5TGF5b3V0SW5mb3MoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUcmFjayB2aWV3cyB0aGF0IHNob3VsZCBiZSByZW1vdmVkLiBUaGV5IGFyZSBub3QgcmVtb3ZlZCBmcm9tXHJcbiAgICAgICAgLy8gdGhlIERPTSBpbW1lZGlhdGVseSwgc2luY2Ugd2UgbWF5IHJldXNlIGFuZCBuZWVkIHRvIHJlLWluc2VydFxyXG4gICAgICAgIC8vIHRoZW0gYmFjayBpbnRvIHRoZSBET00gYW55d2F5LlxyXG4gICAgICAgIGxldCByZW1vdmVkID0gbmV3IFNldCgpO1xyXG4gICAgICAgIGZvciAobGV0IGtleSBvZiB0b1JlbW92ZS5rZXlzKCkpe1xyXG4gICAgICAgICAgICBsZXQgdmlldyA9IHRoaXMuX3Zpc2libGVWaWV3cy5nZXQoa2V5KTtcclxuICAgICAgICAgICAgaWYgKHZpZXcpIHtcclxuICAgICAgICAgICAgICAgIHJlbW92ZWQuYWRkKHZpZXcpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdmlzaWJsZVZpZXdzLmRlbGV0ZShrZXkpO1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgYXJlIGluIHRoZSBtaWRkbGUgb2YgYSB0cmFuc2FjdGlvbiwgd2FpdCB1bnRpbCB0aGUgZW5kXHJcbiAgICAgICAgICAgICAgICAvLyBvZiB0aGUgYW5pbWF0aW9ucyB0byByZW1vdmUgdGhlIHZpZXdzIGZyb20gdGhlIERPTS4gQWxzbyBtZWFuc1xyXG4gICAgICAgICAgICAgICAgLy8gd2UgY2FuJ3QgcmV1c2UgdGhvc2Ugdmlld3MgaW1tZWRpYXRlbHkuXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdHJhbnNhY3Rpb24pIHRoaXMuX3RyYW5zYWN0aW9uLnRvUmVtb3ZlLnNldChrZXksIHZpZXcpO1xyXG4gICAgICAgICAgICAgICAgZWxzZSB0aGlzLnJldXNlVmlldyh2aWV3KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBrZXkgb2YgdG9BZGQua2V5cygpKXtcclxuICAgICAgICAgICAgbGV0IGxheW91dEluZm8gPSB2aXNpYmxlTGF5b3V0SW5mb3MuZ2V0KGtleSk7XHJcbiAgICAgICAgICAgIGxldCB2aWV3O1xyXG4gICAgICAgICAgICAvLyBJZiB3ZSdyZSBpbiBhIHRyYW5zYWN0aW9uLCBhbmQgYSBsYXlvdXQgY2hhbmdlIGhhcHBlbnNcclxuICAgICAgICAgICAgLy8gZHVyaW5nIHRoZSBhbmltYXRpb25zIHN1Y2ggdGhhdCBhIHZpZXcgdGhhdCB3YXMgZ29pbmdcclxuICAgICAgICAgICAgLy8gdG8gYmUgcmVtb3ZlZCBpcyBub3cgbm90LCB3ZSBkb24ndCBjcmVhdGUgYSBuZXcgdmlld1xyXG4gICAgICAgICAgICAvLyBzaW5jZSB0aGUgb2xkIG9uZSBpcyBzdGlsbCBpbiB0aGUgRE9NLCBtYXJrZWQgYXMgdG9SZW1vdmUuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLl90cmFuc2FjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgLy8gaWYgdHJhbnNhY3Rpb24sIGdldCBpbml0aWFsIGxheW91dCBhdHRyaWJ1dGVzIGZvciB0aGUgYW5pbWF0aW9uXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdHJhbnNhY3Rpb24uaW5pdGlhbExheW91dEluZm8uaGFzKGtleSkpIGxheW91dEluZm8gPSB0aGlzLl90cmFuc2FjdGlvbi5pbml0aWFsTGF5b3V0SW5mby5nZXQoa2V5KTtcclxuICAgICAgICAgICAgICAgIHZpZXcgPSB0aGlzLl90cmFuc2FjdGlvbi50b1JlbW92ZS5nZXQoa2V5KTtcclxuICAgICAgICAgICAgICAgIGlmICh2aWV3KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNhY3Rpb24udG9SZW1vdmUuZGVsZXRlKGtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXBwbHlMYXlvdXRJbmZvKHZpZXcsIGxheW91dEluZm8pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghdmlldykge1xyXG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIG9yIHJldXNlIGEgdmlldyBmb3IgdGhpcyByb3dcclxuICAgICAgICAgICAgICAgIHZpZXcgPSB0aGlzLmdldFJldXNhYmxlVmlldyhsYXlvdXRJbmZvKTtcclxuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgdmlldyB0byB0aGUgRE9NIGlmIG5lZWRlZFxyXG4gICAgICAgICAgICAgICAgaWYgKCFyZW1vdmVkLmhhcyh2aWV3KSkgdGhpcy5fY2hpbGRyZW4uYWRkKHZpZXcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3Zpc2libGVWaWV3cy5zZXQoa2V5LCB2aWV3KTtcclxuICAgICAgICAgICAgcmVtb3ZlZC5kZWxldGUodmlldyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGtleSBvZiB0b1VwZGF0ZSl7XHJcbiAgICAgICAgICAgIGxldCB2aWV3ID0gY3VycmVudGx5VmlzaWJsZS5nZXQoa2V5KTtcclxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZWRDb250ZW50LmRlbGV0ZShrZXkpO1xyXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJWaWV3KHZpZXcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBSZW1vdmUgdGhlIHJlbWFpbmluZyByb3dzIHRvIGRlbGV0ZSBmcm9tIHRoZSBET01cclxuICAgICAgICBpZiAoIXRoaXMuX3RyYW5zYWN0aW9uKSB0aGlzLnJlbW92ZVZpZXdzKHJlbW92ZWQpO1xyXG4gICAgICAgIHRoaXMuX2NvcnJlY3RJdGVtT3JkZXIoKTtcclxuICAgICAgICB0aGlzLl9mbHVzaFZpc2libGVWaWV3cygpO1xyXG4gICAgICAgIGxldCBoYXNMYXlvdXRVcGRhdGVzID0gdGhpcy5fdHJhbnNhY3Rpb24gJiYgKHRvQWRkLnNpemUgPiAwIHx8IHRvUmVtb3ZlLnNpemUgPiAwIHx8IHRoaXMuX2hhc0xheW91dFVwZGF0ZXMoKSk7XHJcbiAgICAgICAgaWYgKGhhc0xheW91dFVwZGF0ZXMpIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKT0+e1xyXG4gICAgICAgICAgICAvLyBJZiB3ZSdyZSBpbiBhIHRyYW5zYWN0aW9uLCBhcHBseSBhbmltYXRpb25zIHRvIHZpc2libGUgdmlld3NcclxuICAgICAgICAgICAgLy8gYW5kIFwidG8gYmUgcmVtb3ZlZFwiIHZpZXdzLCB3aGljaCBhbmltYXRlIG9mZiBzY3JlZW4uXHJcbiAgICAgICAgICAgIGlmICh0aGlzLl90cmFuc2FjdGlvbikgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpPT50aGlzLl9hcHBseUxheW91dEluZm9zKCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBoYXNMYXlvdXRVcGRhdGVzO1xyXG4gICAgfVxyXG4gICAgYWZ0ZXJSZW5kZXIoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3RyYW5zYWN0aW9uUXVldWUubGVuZ3RoID4gMCkgdGhpcy5fcHJvY2Vzc1RyYW5zYWN0aW9uUXVldWUoKTtcclxuICAgICAgICBlbHNlIGlmICh0aGlzLl9pbnZhbGlkYXRpb25Db250ZXh0KSB0aGlzLnJlbGF5b3V0Tm93KCk7XHJcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkT3ZlcnNjYW4pIHRoaXMuX292ZXJzY2FuTWFuYWdlci5jb2xsZWN0TWV0cmljcygpO1xyXG4gICAgfVxyXG4gICAgX2ZsdXNoVmlzaWJsZVZpZXdzKCkge1xyXG4gICAgICAgIC8vIENvbGxlY3Rpb25WaXJ0dWFsaXplciBkZWFscyB3aXRoIGEgZmxhdHRlbmVkIHNldCBvZiBMYXlvdXRJbmZvcywgYnV0IHRoZXkgY2FuIHJlcHJlc2VudCBoZWlyYXJjaHlcclxuICAgICAgICAvLyBieSByZWZlcmVuY2luZyBhIHBhcmVudEtleS4gSnVzdCBiZWZvcmUgcmVuZGVyaW5nIHRoZSB2aXNpYmxlIHZpZXdzLCB3ZSByZWJ1aWxkIHRoaXMgaGVpcmFyY2h5XHJcbiAgICAgICAgLy8gYnkgY3JlYXRpbmcgYSBtYXBwaW5nIG9mIHZpZXdzIGJ5IHBhcmVudCBrZXkgYW5kIHJlY3Vyc2l2ZWx5IGNhbGxpbmcgdGhlIGRlbGVnYXRlJ3MgcmVuZGVyV3JhcHBlclxyXG4gICAgICAgIC8vIG1ldGhvZCB0byBidWlsZCB0aGUgZmluYWwgdHJlZS5cclxuICAgICAgICBsZXQgdmlld3NCeVBhcmVudEtleSA9IG5ldyBNYXAoW1xyXG4gICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICBudWxsLFxyXG4gICAgICAgICAgICAgICAgW11cclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIF0pO1xyXG4gICAgICAgIGZvciAobGV0IHZpZXcgb2YgdGhpcy5fY2hpbGRyZW4pe1xyXG4gICAgICAgICAgICB2YXIgX3ZpZXdfbGF5b3V0SW5mbywgX3ZpZXdzQnlQYXJlbnRLZXlfZ2V0LCBfdmlld19sYXlvdXRJbmZvMSwgX3ZpZXdfbGF5b3V0SW5mbzIsIF92aWV3X2xheW91dEluZm8zO1xyXG4gICAgICAgICAgICBpZiAoKChfdmlld19sYXlvdXRJbmZvID0gdmlldy5sYXlvdXRJbmZvKSA9PT0gbnVsbCB8fCBfdmlld19sYXlvdXRJbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdmlld19sYXlvdXRJbmZvLnBhcmVudEtleSkgIT0gbnVsbCAmJiAhdmlld3NCeVBhcmVudEtleS5oYXModmlldy5sYXlvdXRJbmZvLnBhcmVudEtleSkpIHZpZXdzQnlQYXJlbnRLZXkuc2V0KHZpZXcubGF5b3V0SW5mby5wYXJlbnRLZXksIFtdKTtcclxuICAgICAgICAgICAgKF92aWV3c0J5UGFyZW50S2V5X2dldCA9IHZpZXdzQnlQYXJlbnRLZXkuZ2V0KChfdmlld19sYXlvdXRJbmZvMSA9IHZpZXcubGF5b3V0SW5mbykgPT09IG51bGwgfHwgX3ZpZXdfbGF5b3V0SW5mbzEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF92aWV3X2xheW91dEluZm8xLnBhcmVudEtleSkpID09PSBudWxsIHx8IF92aWV3c0J5UGFyZW50S2V5X2dldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3ZpZXdzQnlQYXJlbnRLZXlfZ2V0LnB1c2godmlldyk7XHJcbiAgICAgICAgICAgIGlmICghdmlld3NCeVBhcmVudEtleS5oYXMoKF92aWV3X2xheW91dEluZm8yID0gdmlldy5sYXlvdXRJbmZvKSA9PT0gbnVsbCB8fCBfdmlld19sYXlvdXRJbmZvMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3ZpZXdfbGF5b3V0SW5mbzIua2V5KSkgdmlld3NCeVBhcmVudEtleS5zZXQoKF92aWV3X2xheW91dEluZm8zID0gdmlldy5sYXlvdXRJbmZvKSA9PT0gbnVsbCB8fCBfdmlld19sYXlvdXRJbmZvMyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3ZpZXdfbGF5b3V0SW5mbzMua2V5LCBbXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBidWlsZFRyZWUgPSAocGFyZW50LCB2aWV3cyk9PnZpZXdzLm1hcCgodmlldyk9PntcclxuICAgICAgICAgICAgICAgIGxldCBjaGlsZHJlbiA9IHZpZXdzQnlQYXJlbnRLZXkuZ2V0KHZpZXcubGF5b3V0SW5mby5rZXkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGUucmVuZGVyV3JhcHBlcihwYXJlbnQsIHZpZXcsIGNoaWxkcmVuLCAoY2hpbGRWaWV3cyk9PmJ1aWxkVHJlZSh2aWV3LCBjaGlsZFZpZXdzKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIGxldCBjaGlsZHJlbiA9IGJ1aWxkVHJlZShudWxsLCB2aWV3c0J5UGFyZW50S2V5LmdldChudWxsKSk7XHJcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZS5zZXRWaXNpYmxlVmlld3MoY2hpbGRyZW4pO1xyXG4gICAgfVxyXG4gICAgX2FwcGx5TGF5b3V0SW5mbyh2aWV3LCBsYXlvdXRJbmZvKSB7XHJcbiAgICAgICAgaWYgKHZpZXcubGF5b3V0SW5mbyA9PT0gbGF5b3V0SW5mbykgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIHZpZXcubGF5b3V0SW5mbyA9IGxheW91dEluZm87XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBfYXBwbHlMYXlvdXRJbmZvcygpIHtcclxuICAgICAgICBsZXQgdXBkYXRlZCA9IGZhbHNlO1xyXG4gICAgICAgIC8vIEFwcGx5IGxheW91dCBpbmZvcyB0byB2aXNpYmxlIHZpZXdzXHJcbiAgICAgICAgZm9yIChsZXQgdmlldyBvZiB0aGlzLl92aXNpYmxlVmlld3MudmFsdWVzKCkpe1xyXG4gICAgICAgICAgICBsZXQgY3VyID0gdmlldy5sYXlvdXRJbmZvO1xyXG4gICAgICAgICAgICBpZiAoKGN1ciA9PT0gbnVsbCB8fCBjdXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1ci5rZXkpICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGxldCBsYXlvdXRJbmZvID0gdGhpcy5sYXlvdXQuZ2V0TGF5b3V0SW5mbyhjdXIua2V5KTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9hcHBseUxheW91dEluZm8odmlldywgbGF5b3V0SW5mbykpIHVwZGF0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEFwcGx5IGZpbmFsIGxheW91dCBpbmZvcyBmb3Igdmlld3MgdGhhdCB3aWxsIGJlIHJlbW92ZWRcclxuICAgICAgICBpZiAodGhpcy5fdHJhbnNhY3Rpb24pIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgdmlldyBvZiB0aGlzLl90cmFuc2FjdGlvbi50b1JlbW92ZS52YWx1ZXMoKSl7XHJcbiAgICAgICAgICAgICAgICBsZXQgY3VyID0gdmlldy5sYXlvdXRJbmZvO1xyXG4gICAgICAgICAgICAgICAgaWYgKChjdXIgPT09IG51bGwgfHwgY3VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXIua2V5KSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxheW91dEluZm8gPSB0aGlzLmxheW91dC5nZXRMYXlvdXRJbmZvKGN1ci5rZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9hcHBseUxheW91dEluZm8odmlldywgbGF5b3V0SW5mbykpIHVwZGF0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAobGV0IHZpZXcgb2YgdGhpcy5fdHJhbnNhY3Rpb24ucmVtb3ZlZC52YWx1ZXMoKSl7XHJcbiAgICAgICAgICAgICAgICBsZXQgY3VyID0gdmlldy5sYXlvdXRJbmZvO1xyXG4gICAgICAgICAgICAgICAgbGV0IGxheW91dEluZm8gPSB0aGlzLl90cmFuc2FjdGlvbi5maW5hbExheW91dEluZm8uZ2V0KGN1ci5rZXkpIHx8IGN1cjtcclxuICAgICAgICAgICAgICAgIGxheW91dEluZm8gPSB0aGlzLmxheW91dC5nZXRGaW5hbExheW91dEluZm8obGF5b3V0SW5mby5jb3B5KCkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2FwcGx5TGF5b3V0SW5mbyh2aWV3LCBsYXlvdXRJbmZvKSkgdXBkYXRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHVwZGF0ZWQpIHRoaXMuX2ZsdXNoVmlzaWJsZVZpZXdzKCk7XHJcbiAgICB9XHJcbiAgICBfaGFzTGF5b3V0VXBkYXRlcygpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX3RyYW5zYWN0aW9uKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgZm9yIChsZXQgdmlldyBvZiB0aGlzLl92aXNpYmxlVmlld3MudmFsdWVzKCkpe1xyXG4gICAgICAgICAgICBsZXQgY3VyID0gdmlldy5sYXlvdXRJbmZvO1xyXG4gICAgICAgICAgICBpZiAoIWN1cikgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIGxldCBsYXlvdXRJbmZvID0gdGhpcy5sYXlvdXQuZ2V0TGF5b3V0SW5mbyhjdXIua2V5KTtcclxuICAgICAgICAgICAgaWYgKC8vIFVzZXMgZXF1YWxzIHJhdGhlciB0aGFuIHBvaW50RXF1YWxzIHNvIHRoYXQgd2lkdGgvaGVpZ2h0IGNoYW5nZXMgYXJlIHRha2VuIGludG8gYWNjb3VudFxyXG4gICAgICAgICAgICAhY3VyLnJlY3QuZXF1YWxzKGxheW91dEluZm8ucmVjdCkgfHwgY3VyLm9wYWNpdHkgIT09IGxheW91dEluZm8ub3BhY2l0eSB8fCBjdXIudHJhbnNmb3JtICE9PSBsYXlvdXRJbmZvLnRyYW5zZm9ybSkgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldXNlVmlldyh2aWV3KSB7XHJcbiAgICAgICAgdmlldy5wcmVwYXJlRm9yUmV1c2UoKTtcclxuICAgICAgICB0aGlzLl9yZXVzYWJsZVZpZXdzW3ZpZXcudmlld1R5cGVdLnB1c2godmlldyk7XHJcbiAgICB9XHJcbiAgICByZW1vdmVWaWV3cyh0b1JlbW92ZSkge1xyXG4gICAgICAgIGZvciAobGV0IHZpZXcgb2YgdG9SZW1vdmUpdGhpcy5fY2hpbGRyZW4uZGVsZXRlKHZpZXcpO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlSXRlbVNpemUoa2V5LCBzaXplKSB7XHJcbiAgICAgICAgLy8gVE9ETzogd2Ugc2hvdWxkIGJlIGFibGUgdG8gaW52YWxpZGF0ZSBhIHNpbmdsZSBpbmRleCBwYXRoXHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgIGlmICghdGhpcy5sYXlvdXQudXBkYXRlSXRlbVNpemUpIHJldHVybjtcclxuICAgICAgICAvLyBJZiB0aGUgc2Nyb2xsIHBvc2l0aW9uIGlzIGN1cnJlbnRseSBhbmltYXRpbmcsIGFkZCB0aGUgdXBkYXRlXHJcbiAgICAgICAgLy8gdG8gYSBxdWV1ZSB0byBiZSBwcm9jZXNzZWQgYWZ0ZXIgdGhlIGFuaW1hdGlvbiBpcyBjb21wbGV0ZS5cclxuICAgICAgICBpZiAodGhpcy5fc2Nyb2xsQW5pbWF0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NpemVVcGRhdGVRdWV1ZS5zZXQoa2V5LCBzaXplKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICAgbGV0IGNoYW5nZWQgPSB0aGlzLmxheW91dC51cGRhdGVJdGVtU2l6ZShrZXksIHNpemUpO1xyXG4gICAgICAgIGlmIChjaGFuZ2VkKSB0aGlzLnJlbGF5b3V0KCk7XHJcbiAgICB9XHJcbiAgICBzdGFydFNjcm9sbGluZygpIHtcclxuICAgICAgICB0aGlzLl9pc1Njcm9sbGluZyA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBlbmRTY3JvbGxpbmcoKSB7XHJcbiAgICAgICAgdGhpcy5faXNTY3JvbGxpbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9jb3JyZWN0SXRlbU9yZGVyKCk7XHJcbiAgICAgICAgdGhpcy5fZmx1c2hWaXNpYmxlVmlld3MoKTtcclxuICAgIH1cclxuICAgIF9yZXNldEFuaW1hdGVkQ29udGVudE9mZnNldCgpIHtcclxuICAgICAgICAvLyBSZXNldCB0aGUgYW5pbWF0ZWQgY29udGVudCBvZmZzZXQgb2Ygc3Vidmlld3MuIFNlZSBjb21tZW50IGluIHJlbGF5b3V0Tm93IGZvciBkZXRhaWxzLlxyXG4gICAgICAgIGlmICghdGhpcy5fYW5pbWF0ZWRDb250ZW50T2Zmc2V0LmlzT3JpZ2luKCkpIHtcclxuICAgICAgICAgICAgdGhpcy5fYW5pbWF0ZWRDb250ZW50T2Zmc2V0ID0gbmV3ICgwLCAkMzA0MWRiMzI5Njk0NWU2ZSRleHBvcnQkYmFmMjYxNDZhNDE0ZjI0YSkoMCwgMCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2FwcGx5TGF5b3V0SW5mb3MoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgKiBTY3JvbGxzIHRoZSBpdGVtIHdpdGggdGhlIGdpdmVuIGtleSBpbnRvIHZpZXcsIG9wdGlvbmFsbHkgd2l0aCBhbiBhbmltYXRpb24uXHJcbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBpdGVtIHRvIHNjcm9sbCBpbnRvIHZpZXcuXHJcbiAgICogQHBhcmFtIGR1cmF0aW9uIFRoZSBkdXJhdGlvbiBvZiB0aGUgc2Nyb2xsIGFuaW1hdGlvbi5cclxuICAgKi8gc2Nyb2xsVG9JdGVtKGtleSwgb3B0aW9ucykge1xyXG4gICAgICAgIC8vIGtleSBjYW4gYmUgMCwgc28gY2hlY2sgaWYgbnVsbCBvciB1bmRlZmluZWRcclxuICAgICAgICBpZiAoa2V5ID09IG51bGwpIHJldHVybjtcclxuICAgICAgICBsZXQgbGF5b3V0SW5mbyA9IHRoaXMubGF5b3V0LmdldExheW91dEluZm8oa2V5KTtcclxuICAgICAgICBpZiAoIWxheW91dEluZm8pIHJldHVybjtcclxuICAgICAgICBsZXQgeyBkdXJhdGlvbjogZHVyYXRpb24gPSAzMDAsIHNob3VsZFNjcm9sbFg6IHNob3VsZFNjcm9sbFggPSB0cnVlLCBzaG91bGRTY3JvbGxZOiBzaG91bGRTY3JvbGxZID0gdHJ1ZSwgb2Zmc2V0WDogb2Zmc2V0WCA9IDAsIG9mZnNldFk6IG9mZnNldFkgPSAwIH0gPSBvcHRpb25zO1xyXG4gICAgICAgIGxldCB4ID0gdGhpcy52aXNpYmxlUmVjdC54O1xyXG4gICAgICAgIGxldCB5ID0gdGhpcy52aXNpYmxlUmVjdC55O1xyXG4gICAgICAgIGxldCBtaW5YID0gbGF5b3V0SW5mby5yZWN0LnggLSBvZmZzZXRYO1xyXG4gICAgICAgIGxldCBtaW5ZID0gbGF5b3V0SW5mby5yZWN0LnkgLSBvZmZzZXRZO1xyXG4gICAgICAgIGxldCBtYXhYID0geCArIHRoaXMudmlzaWJsZVJlY3Qud2lkdGg7XHJcbiAgICAgICAgbGV0IG1heFkgPSB5ICsgdGhpcy52aXNpYmxlUmVjdC5oZWlnaHQ7XHJcbiAgICAgICAgaWYgKHNob3VsZFNjcm9sbFgpIHtcclxuICAgICAgICAgICAgaWYgKG1pblggPD0geCB8fCBtYXhYID09PSAwKSB4ID0gbWluWDtcclxuICAgICAgICAgICAgZWxzZSBpZiAobGF5b3V0SW5mby5yZWN0Lm1heFggPiBtYXhYKSB4ICs9IGxheW91dEluZm8ucmVjdC5tYXhYIC0gbWF4WDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNob3VsZFNjcm9sbFkpIHtcclxuICAgICAgICAgICAgaWYgKG1pblkgPD0geSB8fCBtYXhZID09PSAwKSB5ID0gbWluWTtcclxuICAgICAgICAgICAgZWxzZSBpZiAobGF5b3V0SW5mby5yZWN0Lm1heFkgPiBtYXhZKSB5ICs9IGxheW91dEluZm8ucmVjdC5tYXhZIC0gbWF4WTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsVG8obmV3ICgwLCAkMzA0MWRiMzI5Njk0NWU2ZSRleHBvcnQkYmFmMjYxNDZhNDE0ZjI0YSkoeCwgeSksIGR1cmF0aW9uKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAqIFBlcmZvcm1zIGFuIGFuaW1hdGVkIHNjcm9sbCB0byB0aGUgZ2l2ZW4gb2Zmc2V0LlxyXG4gICAqIEBwYXJhbSBvZmZzZXQgLSBUaGUgb2Zmc2V0IHRvIHNjcm9sbCB0by5cclxuICAgKiBAcGFyYW0gZHVyYXRpb24gVGhlIGR1cmF0aW9uIG9mIHRoZSBhbmltYXRpb24uXHJcbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgYW5pbWF0aW9uIGlzIGNvbXBsZXRlLlxyXG4gICAqLyBzY3JvbGxUbyhvZmZzZXQsIGR1cmF0aW9uID0gMzAwKSB7XHJcbiAgICAgICAgLy8gQ2FuY2VsIHRoZSBjdXJyZW50IHNjcm9sbCBhbmltYXRpb25cclxuICAgICAgICBpZiAodGhpcy5fc2Nyb2xsQW5pbWF0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbEFuaW1hdGlvbi5jYW5jZWwoKTtcclxuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsQW5pbWF0aW9uID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gU2V0IHRoZSBjb250ZW50IG9mZnNldCBzeW5jaHJvbm91c2x5IGlmIHRoZSBkdXJhdGlvbiBpcyB6ZXJvXHJcbiAgICAgICAgaWYgKGR1cmF0aW9uIDw9IDAgfHwgdGhpcy52aXNpYmxlUmVjdC5wb2ludEVxdWFscyhvZmZzZXQpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NldENvbnRlbnRPZmZzZXQob2Zmc2V0KTtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnN0YXJ0U2Nyb2xsaW5nKCk7XHJcbiAgICAgICAgdGhpcy5fc2Nyb2xsQW5pbWF0aW9uID0gKDAsICQzZWIxMzFkY2YzN2FkNWY4JGV4cG9ydCRkYzBiNjM3MjA3ODgwOTBjKSh0aGlzLnZpc2libGVSZWN0LCBvZmZzZXQsIGR1cmF0aW9uLCAoMCwgJDNlYjEzMWRjZjM3YWQ1ZjgkZXhwb3J0JDU3NjM2YmI0M2IxY2NiYjApLCAob2Zmc2V0KT0+e1xyXG4gICAgICAgICAgICB0aGlzLl9zZXRDb250ZW50T2Zmc2V0KG9mZnNldCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fc2Nyb2xsQW5pbWF0aW9uLnRoZW4oKCk9PntcclxuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsQW5pbWF0aW9uID0gbnVsbDtcclxuICAgICAgICAgICAgLy8gUHJvY2VzcyB2aWV3IHNpemUgdXBkYXRlcyB0aGF0IG9jY3VycmVkIGR1cmluZyB0aGUgYW5pbWF0aW9uLlxyXG4gICAgICAgICAgICAvLyBPbmx5IHZpZXdzIHRoYXQgYXJlIHN0aWxsIHZpc2libGUgd2lsbCBiZSBhY3R1YWxseSB1cGRhdGVkLlxyXG4gICAgICAgICAgICBmb3IgKGxldCBba2V5LCBzaXplXSBvZiB0aGlzLl9zaXplVXBkYXRlUXVldWUpdGhpcy51cGRhdGVJdGVtU2l6ZShrZXksIHNpemUpO1xyXG4gICAgICAgICAgICB0aGlzLl9zaXplVXBkYXRlUXVldWUuY2xlYXIoKTtcclxuICAgICAgICAgICAgdGhpcy5yZWxheW91dCgpO1xyXG4gICAgICAgICAgICB0aGlzLl9wcm9jZXNzVHJhbnNhY3Rpb25RdWV1ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmVuZFNjcm9sbGluZygpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zY3JvbGxBbmltYXRpb247XHJcbiAgICB9XHJcbiAgICBfcnVuVHJhbnNhY3Rpb24oYWN0aW9uLCBhbmltYXRlZCkge1xyXG4gICAgICAgIHRoaXMuX3N0YXJ0VHJhbnNhY3Rpb24oKTtcclxuICAgICAgICBpZiAodGhpcy5fbmV4dFRyYW5zYWN0aW9uKSB0aGlzLl9uZXh0VHJhbnNhY3Rpb24uYWN0aW9ucy5wdXNoKGFjdGlvbik7XHJcbiAgICAgICAgdGhpcy5fZW5kVHJhbnNhY3Rpb24oYW5pbWF0ZWQpO1xyXG4gICAgfVxyXG4gICAgX3N0YXJ0VHJhbnNhY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9uZXh0VHJhbnNhY3Rpb24pIHRoaXMuX25leHRUcmFuc2FjdGlvbiA9IG5ldyAoMCwgJDhlMTM1ZTUzMWQ4ZGNiNjYkZXhwb3J0JGZlYmM1NTczYzc1Y2VmYjApO1xyXG4gICAgICAgIHRoaXMuX25leHRUcmFuc2FjdGlvbi5sZXZlbCsrO1xyXG4gICAgfVxyXG4gICAgX2VuZFRyYW5zYWN0aW9uKGFuaW1hdGVkKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9uZXh0VHJhbnNhY3Rpb24pIHJldHVybiBmYWxzZTtcclxuICAgICAgICAvLyBTYXZlIHdoZXRoZXIgdGhlIHRyYW5zYWN0aW9uIHNob3VsZCBiZSBhbmltYXRlZC5cclxuICAgICAgICBpZiAoYW5pbWF0ZWQgIT0gbnVsbCkgdGhpcy5fbmV4dFRyYW5zYWN0aW9uLmFuaW1hdGVkID0gYW5pbWF0ZWQ7XHJcbiAgICAgICAgLy8gSWYgd2UgaGF2ZW4ndCByZWFjaGVkIGxldmVsIDAsIHdlIGFyZSBzdGlsbCBpbiBhXHJcbiAgICAgICAgLy8gbmVzdGVkIHRyYW5zYWN0aW9uLiBXYWl0IGZvciB0aGUgcGFyZW50IHRvIGVuZC5cclxuICAgICAgICBpZiAoLS10aGlzLl9uZXh0VHJhbnNhY3Rpb24ubGV2ZWwgPiAwKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgLy8gRG8gbm90aGluZyBmb3IgZW1wdHkgdHJhbnNhY3Rpb25zXHJcbiAgICAgICAgaWYgKHRoaXMuX25leHRUcmFuc2FjdGlvbi5hY3Rpb25zLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLl9uZXh0VHJhbnNhY3Rpb24gPSBudWxsO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIERlZmF1bHQgYW5pbWF0aW9ucyB0byB0cnVlXHJcbiAgICAgICAgaWYgKHRoaXMuX25leHRUcmFuc2FjdGlvbi5hbmltYXRlZCA9PSBudWxsKSB0aGlzLl9uZXh0VHJhbnNhY3Rpb24uYW5pbWF0ZWQgPSB0cnVlO1xyXG4gICAgICAgIC8vIEVucXVldWUgdGhlIHRyYW5zYWN0aW9uXHJcbiAgICAgICAgdGhpcy5fdHJhbnNhY3Rpb25RdWV1ZS5wdXNoKHRoaXMuX25leHRUcmFuc2FjdGlvbik7XHJcbiAgICAgICAgdGhpcy5fbmV4dFRyYW5zYWN0aW9uID0gbnVsbDtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIF9wcm9jZXNzVHJhbnNhY3Rpb25RdWV1ZSgpIHtcclxuICAgICAgICAvLyBJZiB0aGUgY3VycmVudCB0cmFuc2FjdGlvbiBpcyBhbmltYXRpbmcsIHdhaXQgdW50aWwgdGhlIGVuZFxyXG4gICAgICAgIC8vIHRvIHByb2Nlc3MgdGhlIG5leHQgdHJhbnNhY3Rpb24uXHJcbiAgICAgICAgaWYgKHRoaXMuX3RyYW5zYWN0aW9uIHx8IHRoaXMuX3Njcm9sbEFuaW1hdGlvbikgcmV0dXJuO1xyXG4gICAgICAgIGxldCBuZXh0ID0gdGhpcy5fdHJhbnNhY3Rpb25RdWV1ZS5zaGlmdCgpO1xyXG4gICAgICAgIGlmIChuZXh0KSB0aGlzLl9wZXJmb3JtVHJhbnNhY3Rpb24obmV4dCk7XHJcbiAgICB9XHJcbiAgICBfZ2V0Q29udGVudFJlY3QoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyAoMCwgJDYwNDIzZjkyYzdmOWFkODckZXhwb3J0JGM3OWZjNjQ5MmYzYWYxM2QpKDAsIDAsIHRoaXMuY29udGVudFNpemUud2lkdGgsIHRoaXMuY29udGVudFNpemUuaGVpZ2h0KTtcclxuICAgIH1cclxuICAgIF9wZXJmb3JtVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcclxuICAgICAgICB0aGlzLl90cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uO1xyXG4gICAgICAgIHRoaXMucmVsYXlvdXROb3coe1xyXG4gICAgICAgICAgICB0cmFuc2FjdGlvbjogdHJhbnNhY3Rpb24sXHJcbiAgICAgICAgICAgIGFuaW1hdGVkOiB0cmFuc2FjdGlvbi5hbmltYXRlZCxcclxuICAgICAgICAgICAgYmVmb3JlTGF5b3V0OiAoKT0+e1xyXG4gICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBpbml0aWFsIGxheW91dCBpbmZvcyBmb3IgYWxsIHZpZXdzIGJlZm9yZSB0aGUgdXBkYXRlc1xyXG4gICAgICAgICAgICAgICAgLy8gc28gd2UgY2FuIGZpZ3VyZSBvdXQgd2hpY2ggdmlld3MgdG8gYWRkIGFuZCByZW1vdmUuXHJcbiAgICAgICAgICAgICAgICBpZiAodHJhbnNhY3Rpb24uYW5pbWF0ZWQpIHRyYW5zYWN0aW9uLmluaXRpYWxNYXAgPSB0aGlzLl9nZXRMYXlvdXRJbmZvTWFwKHRoaXMuX2dldENvbnRlbnRSZWN0KCksIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgLy8gQXBwbHkgdGhlIGFjdGlvbnMgdGhhdCBvY2N1cnJlZCBkdXJpbmcgdGhpcyB0cmFuc2FjdGlvblxyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYWN0aW9uIG9mIHRyYW5zYWN0aW9uLmFjdGlvbnMpYWN0aW9uKCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGFmdGVyTGF5b3V0OiAoKT0+e1xyXG4gICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBmaW5hbCBsYXlvdXQgaW5mb3MgYWZ0ZXIgdGhlIHVwZGF0ZXNcclxuICAgICAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvbi5hbmltYXRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLmZpbmFsTWFwID0gdGhpcy5fZ2V0TGF5b3V0SW5mb01hcCh0aGlzLl9nZXRDb250ZW50UmVjdCgpKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXR1cFRyYW5zYWN0aW9uQW5pbWF0aW9ucyh0cmFuc2FjdGlvbik7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgdGhpcy5fdHJhbnNhY3Rpb24gPSBudWxsO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBhZnRlckFuaW1hdGlvbjogKCk9PntcclxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBhbmQgcmV1c2Ugdmlld3Mgd2hlbiBhbmltYXRpb25zIGFyZSBkb25lXHJcbiAgICAgICAgICAgICAgICBpZiAodHJhbnNhY3Rpb24udG9SZW1vdmUuc2l6ZSA+IDAgfHwgdHJhbnNhY3Rpb24ucmVtb3ZlZC5zaXplID4gMCkgZm9yIChsZXQgdmlldyBvZiAoMCwgJGZjMzZmOWEwNDZhOWNlNzkkZXhwb3J0JGNmYzE0MDg4ZGZlZmNlNWYpKHRyYW5zYWN0aW9uLnRvUmVtb3ZlLnZhbHVlcygpLCB0cmFuc2FjdGlvbi5yZW1vdmVkLnZhbHVlcygpKSl7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hpbGRyZW4uZGVsZXRlKHZpZXcpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmV1c2VWaWV3KHZpZXcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNhY3Rpb24gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgLy8gRW5zdXJlIERPTSBvcmRlciBpcyBjb3JyZWN0IGZvciBhY2Nlc3NpYmlsaXR5IGFmdGVyIGFuaW1hdGlvbnMgYXJlIGNvbXBsZXRlXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jb3JyZWN0SXRlbU9yZGVyKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9mbHVzaFZpc2libGVWaWV3cygpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc1RyYW5zYWN0aW9uUXVldWUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgX3NldHVwVHJhbnNhY3Rpb25BbmltYXRpb25zKHRyYW5zYWN0aW9uKSB7XHJcbiAgICAgICAgbGV0IHsgaW5pdGlhbE1hcDogaW5pdGlhbE1hcCwgZmluYWxNYXA6IGZpbmFsTWFwIH0gPSB0cmFuc2FjdGlvbjtcclxuICAgICAgICAvLyBTdG9yZSBpbml0aWFsIGFuZCBmaW5hbCBsYXlvdXQgaW5mb3MgZm9yIGFuaW1hdGlvbnNcclxuICAgICAgICBmb3IgKGxldCBba2V5LCBsYXlvdXRJbmZvXSBvZiBpbml0aWFsTWFwKWlmIChmaW5hbE1hcC5oYXMoa2V5KSkgLy8gU3RvcmUgdGhlIGluaXRpYWwgbGF5b3V0IGluZm8gZm9yIHVzZSBkdXJpbmcgYW5pbWF0aW9ucy5cclxuICAgICAgICB0cmFuc2FjdGlvbi5pbml0aWFsTGF5b3V0SW5mby5zZXQoa2V5LCBsYXlvdXRJbmZvKTtcclxuICAgICAgICBlbHNlIC8vIFRoaXMgdmlldyB3YXMgcmVtb3ZlZC4gU3RvcmUgdGhlIGxheW91dCBpbmZvIGZvciB1c2VcclxuICAgICAgICAvLyBpbiBMYXlvdXQjZ2V0RmluYWxMYXlvdXRJbmZvIGR1cmluZyBhbmltYXRpb25zLlxyXG4gICAgICAgIHRyYW5zYWN0aW9uLmZpbmFsTGF5b3V0SW5mby5zZXQobGF5b3V0SW5mby5rZXksIGxheW91dEluZm8pO1xyXG4gICAgICAgIC8vIEdldCBpbml0aWFsIGxheW91dCBpbmZvcyBmb3Igdmlld3MgdGhhdCB3ZXJlIGFkZGVkXHJcbiAgICAgICAgZm9yIChsZXQgW2tleSwgbGF5b3V0SW5mb10gb2YgZmluYWxNYXApaWYgKCFpbml0aWFsTWFwLmhhcyhrZXkpKSB7XHJcbiAgICAgICAgICAgIGxldCBpbml0aWFsTGF5b3V0SW5mbyA9IHRoaXMubGF5b3V0LmdldEluaXRpYWxMYXlvdXRJbmZvKGxheW91dEluZm8uY29weSgpKTtcclxuICAgICAgICAgICAgdHJhbnNhY3Rpb24uaW5pdGlhbExheW91dEluZm8uc2V0KGtleSwgaW5pdGlhbExheW91dEluZm8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBGaWd1cmUgb3V0IHdoaWNoIHZpZXdzIHdlcmUgcmVtb3ZlZC5cclxuICAgICAgICBmb3IgKGxldCBba2V5LCB2aWV3XSBvZiB0aGlzLl92aXNpYmxlVmlld3MpLy8gSWYgYW4gaXRlbSBoYXMgYSB3aWR0aCBvZiAwLCB0aGVyZSBpcyBubyBuZWVkIHRvIHJlbW92ZSBpdCBmcm9tIHRoZSBfdmlzaWJsZVZpZXdzLlxyXG4gICAgICAgIC8vIFJlbW92aW5nIGFuIGl0ZW0gd2l0aCAgd2lkdGggb2YgMCBjYW4gY2F1c2UgYSBsb29wIHdoZXJlIHRoZSBpdGVtIGdldHMgYWRkZWQsIHJlbW92ZWQsXHJcbiAgICAgICAgLy8gYWRkZWQsIHJlbW92ZWQuLi4gZXRjIGluIGEgbG9vcC5cclxuICAgICAgICBpZiAoIWZpbmFsTWFwLmhhcyhrZXkpICYmIHZpZXcubGF5b3V0SW5mby5yZWN0LndpZHRoID4gMCkge1xyXG4gICAgICAgICAgICB0cmFuc2FjdGlvbi5yZW1vdmVkLnNldChrZXksIHZpZXcpO1xyXG4gICAgICAgICAgICB0aGlzLl92aXNpYmxlVmlld3MuZGVsZXRlKGtleSk7XHJcbiAgICAgICAgICAgIC8vIEluIGNhc2Ugc29tZXRoaW5nIHdlaXJkIGhhcHBlbmVkLCB3aGVyZSB3ZSBoYXZlIGEgdmlldyBidXQgbm9cclxuICAgICAgICAgICAgLy8gaW5pdGlhbCBsYXlvdXQgaW5mbywgdXNlIHRoZSBvbmUgYXR0YWNoZWQgdG8gdGhlIHZpZXcuXHJcbiAgICAgICAgICAgIGlmICh2aWV3LmxheW91dEluZm8pIHtcclxuICAgICAgICAgICAgICAgIGlmICghdHJhbnNhY3Rpb24uZmluYWxMYXlvdXRJbmZvLmhhcyh2aWV3LmxheW91dEluZm8ua2V5KSkgdHJhbnNhY3Rpb24uZmluYWxMYXlvdXRJbmZvLnNldCh2aWV3LmxheW91dEluZm8ua2V5LCB2aWV3LmxheW91dEluZm8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KXtcclxuICAgICAgICB0aGlzLl9jb250ZW50U2l6ZSA9IG5ldyAoMCwgJGVlMWJmYTkwYTk1N2ZiOGEkZXhwb3J0JGNiNmRhODljNmFmMWE4ZWMpO1xyXG4gICAgICAgIHRoaXMuX3Zpc2libGVSZWN0ID0gbmV3ICgwLCAkNjA0MjNmOTJjN2Y5YWQ4NyRleHBvcnQkYzc5ZmM2NDkyZjNhZjEzZCk7XHJcbiAgICAgICAgdGhpcy5fcmV1c2FibGVWaWV3cyA9IHt9O1xyXG4gICAgICAgIHRoaXMuX3Zpc2libGVMYXlvdXRJbmZvcyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLl92aXNpYmxlVmlld3MgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5fcmVuZGVyZWRDb250ZW50ID0gbmV3IFdlYWtNYXAoKTtcclxuICAgICAgICB0aGlzLl9jaGlsZHJlbiA9IG5ldyBTZXQoKTtcclxuICAgICAgICB0aGlzLl9pbnZhbGlkYXRpb25Db250ZXh0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9vdmVyc2Nhbk1hbmFnZXIgPSBuZXcgKDAsICQzNjQxOTFiM2RlY2YzNjk3JGV4cG9ydCQ0NDU1ZWU2YWZiMzhkY2JiKSgpO1xyXG4gICAgICAgIHRoaXMuX3BlcnNpc3RlZEtleXMgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgdGhpcy5fc2Nyb2xsQW5pbWF0aW9uID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9pc1Njcm9sbGluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3NpemVVcGRhdGVRdWV1ZSA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLl9hbmltYXRlZENvbnRlbnRPZmZzZXQgPSBuZXcgKDAsICQzMDQxZGIzMjk2OTQ1ZTZlJGV4cG9ydCRiYWYyNjE0NmE0MTRmMjRhKSgwLCAwKTtcclxuICAgICAgICB0aGlzLl90cmFuc2FjdGlvbiA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fbmV4dFRyYW5zYWN0aW9uID0gbnVsbDtcclxuICAgICAgICB0aGlzLl90cmFuc2FjdGlvblF1ZXVlID0gW107XHJcbiAgICAgICAgdmFyIF9vcHRpb25zX3RyYW5zaXRpb25EdXJhdGlvbjtcclxuICAgICAgICAvLyBTZXQgb3B0aW9ucyBmcm9tIHBhc3NlZCBvYmplY3QgaWYgZ2l2ZW5cclxuICAgICAgICB0aGlzLnRyYW5zaXRpb25EdXJhdGlvbiA9IChfb3B0aW9uc190cmFuc2l0aW9uRHVyYXRpb24gPSBvcHRpb25zLnRyYW5zaXRpb25EdXJhdGlvbikgIT09IG51bGwgJiYgX29wdGlvbnNfdHJhbnNpdGlvbkR1cmF0aW9uICE9PSB2b2lkIDAgPyBfb3B0aW9uc190cmFuc2l0aW9uRHVyYXRpb24gOiA1MDA7XHJcbiAgICAgICAgdGhpcy5hbmNob3JTY3JvbGxQb3NpdGlvbiA9IG9wdGlvbnMuYW5jaG9yU2Nyb2xsUG9zaXRpb24gfHwgZmFsc2U7XHJcbiAgICAgICAgdGhpcy5hbmNob3JTY3JvbGxQb3NpdGlvbkF0VG9wID0gb3B0aW9ucy5hbmNob3JTY3JvbGxQb3NpdGlvbkF0VG9wIHx8IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuc2hvdWxkT3ZlcnNjYW4gPSBvcHRpb25zLnNob3VsZE92ZXJzY2FuICE9PSBmYWxzZTtcclxuICAgICAgICBmb3IgKGxldCBrZXkgb2YgW1xyXG4gICAgICAgICAgICBcImRlbGVnYXRlXCIsXHJcbiAgICAgICAgICAgIFwic2l6ZVwiLFxyXG4gICAgICAgICAgICBcImxheW91dFwiLFxyXG4gICAgICAgICAgICBcImNvbGxlY3Rpb25cIlxyXG4gICAgICAgIF0paWYgKG9wdGlvbnNba2V5XSkgdGhpc1trZXldID0gb3B0aW9uc1trZXldO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gJGZjMGIxM2I0ODRhYzExOTQkZXhwb3J0JDE1MDVkYjgyZmUzNTdlNjUob3B0cykge1xyXG4gICAgbGV0IFt2aXNpYmxlVmlld3MsIHNldFZpc2libGVWaWV3c10gPSAoMCwgJDhEM25yJHVzZVN0YXRlKShbXSk7XHJcbiAgICBsZXQgW2NvbnRlbnRTaXplLCBzZXRDb250ZW50U2l6ZV0gPSAoMCwgJDhEM25yJHVzZVN0YXRlKShuZXcgKDAsICRlZTFiZmE5MGE5NTdmYjhhJGV4cG9ydCRjYjZkYTg5YzZhZjFhOGVjKSgpKTtcclxuICAgIGxldCBbaXNBbmltYXRpbmcsIHNldEFuaW1hdGluZ10gPSAoMCwgJDhEM25yJHVzZVN0YXRlKShmYWxzZSk7XHJcbiAgICBsZXQgW2lzU2Nyb2xsaW5nLCBzZXRTY3JvbGxpbmddID0gKDAsICQ4RDNuciR1c2VTdGF0ZSkoZmFsc2UpO1xyXG4gICAgbGV0IHZpcnR1YWxpemVyID0gKDAsICQ4RDNuciR1c2VNZW1vKSgoKT0+bmV3ICgwLCAkMzhiOTQ5MGMxY2NhOGZjNCRleHBvcnQkODliZTVhMjQzZTU5YzRiMikoKSwgW10pO1xyXG4gICAgdmlydHVhbGl6ZXIuZGVsZWdhdGUgPSB7XHJcbiAgICAgICAgc2V0VmlzaWJsZVZpZXdzOiBzZXRWaXNpYmxlVmlld3MsXHJcbiAgICAgICAgc2V0VmlzaWJsZVJlY3QgKHJlY3QpIHtcclxuICAgICAgICAgICAgdmlydHVhbGl6ZXIudmlzaWJsZVJlY3QgPSByZWN0O1xyXG4gICAgICAgICAgICBvcHRzLm9uVmlzaWJsZVJlY3RDaGFuZ2UocmVjdCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXRDb250ZW50U2l6ZTogc2V0Q29udGVudFNpemUsXHJcbiAgICAgICAgcmVuZGVyVmlldzogb3B0cy5yZW5kZXJWaWV3LFxyXG4gICAgICAgIHJlbmRlcldyYXBwZXI6IG9wdHMucmVuZGVyV3JhcHBlcixcclxuICAgICAgICBiZWdpbkFuaW1hdGlvbnM6ICgpPT5zZXRBbmltYXRpbmcodHJ1ZSksXHJcbiAgICAgICAgZW5kQW5pbWF0aW9uczogKCk9PnNldEFuaW1hdGluZyhmYWxzZSksXHJcbiAgICAgICAgZ2V0U2Nyb2xsQW5jaG9yOiBvcHRzLmdldFNjcm9sbEFuY2hvclxyXG4gICAgfTtcclxuICAgIHZpcnR1YWxpemVyLmxheW91dCA9IG9wdHMubGF5b3V0O1xyXG4gICAgdmlydHVhbGl6ZXIuY29sbGVjdGlvbiA9IG9wdHMuY29sbGVjdGlvbjtcclxuICAgIHZpcnR1YWxpemVyLnRyYW5zaXRpb25EdXJhdGlvbiA9IG9wdHMudHJhbnNpdGlvbkR1cmF0aW9uO1xyXG4gICAgKDAsICQ4RDNuciR1c2VMYXlvdXRFZmZlY3QpKCgpPT57XHJcbiAgICAgICAgdmlydHVhbGl6ZXIuYWZ0ZXJSZW5kZXIoKTtcclxuICAgIH0pO1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGFycm93LWJvZHktc3R5bGVcclxuICAgICgwLCAkOEQzbnIkdXNlRWZmZWN0KSgoKT0+e1xyXG4gICAgICAgIHJldHVybiAoKT0+dmlydHVhbGl6ZXIud2lsbFVubW91bnQoKTtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcclxuICAgIH0sIFtdKTtcclxuICAgIGxldCBzZXRWaXNpYmxlUmVjdCA9ICgwLCAkOEQzbnIkdXNlQ2FsbGJhY2spKChyZWN0KT0+e1xyXG4gICAgICAgIHZpcnR1YWxpemVyLnZpc2libGVSZWN0ID0gcmVjdDtcclxuICAgIH0sIFtcclxuICAgICAgICB2aXJ0dWFsaXplclxyXG4gICAgXSk7XHJcbiAgICBsZXQgc3RhcnRTY3JvbGxpbmcgPSAoMCwgJDhEM25yJHVzZUNhbGxiYWNrKSgoKT0+e1xyXG4gICAgICAgIHZpcnR1YWxpemVyLnN0YXJ0U2Nyb2xsaW5nKCk7XHJcbiAgICAgICAgc2V0U2Nyb2xsaW5nKHRydWUpO1xyXG4gICAgfSwgW1xyXG4gICAgICAgIHZpcnR1YWxpemVyXHJcbiAgICBdKTtcclxuICAgIGxldCBlbmRTY3JvbGxpbmcgPSAoMCwgJDhEM25yJHVzZUNhbGxiYWNrKSgoKT0+e1xyXG4gICAgICAgIHZpcnR1YWxpemVyLmVuZFNjcm9sbGluZygpO1xyXG4gICAgICAgIHNldFNjcm9sbGluZyhmYWxzZSk7XHJcbiAgICB9LCBbXHJcbiAgICAgICAgdmlydHVhbGl6ZXJcclxuICAgIF0pO1xyXG4gICAgbGV0IHN0YXRlID0gKDAsICQ4RDNuciR1c2VNZW1vKSgoKT0+KHtcclxuICAgICAgICAgICAgdmlydHVhbGl6ZXI6IHZpcnR1YWxpemVyLFxyXG4gICAgICAgICAgICB2aXNpYmxlVmlld3M6IHZpc2libGVWaWV3cyxcclxuICAgICAgICAgICAgc2V0VmlzaWJsZVJlY3Q6IHNldFZpc2libGVSZWN0LFxyXG4gICAgICAgICAgICBjb250ZW50U2l6ZTogY29udGVudFNpemUsXHJcbiAgICAgICAgICAgIGlzQW5pbWF0aW5nOiBpc0FuaW1hdGluZyxcclxuICAgICAgICAgICAgaXNTY3JvbGxpbmc6IGlzU2Nyb2xsaW5nLFxyXG4gICAgICAgICAgICBzdGFydFNjcm9sbGluZzogc3RhcnRTY3JvbGxpbmcsXHJcbiAgICAgICAgICAgIGVuZFNjcm9sbGluZzogZW5kU2Nyb2xsaW5nXHJcbiAgICAgICAgfSksIFtcclxuICAgICAgICB2aXJ0dWFsaXplcixcclxuICAgICAgICB2aXNpYmxlVmlld3MsXHJcbiAgICAgICAgc2V0VmlzaWJsZVJlY3QsXHJcbiAgICAgICAgY29udGVudFNpemUsXHJcbiAgICAgICAgaXNBbmltYXRpbmcsXHJcbiAgICAgICAgaXNTY3JvbGxpbmcsXHJcbiAgICAgICAgc3RhcnRTY3JvbGxpbmcsXHJcbiAgICAgICAgZW5kU2Nyb2xsaW5nXHJcbiAgICBdKTtcclxuICAgIHJldHVybiBzdGF0ZTtcclxufVxyXG5cclxuXHJcblxyXG5cclxuZXhwb3J0IHskYzc0Y2RhN2QzMWFmMTI1MyRleHBvcnQkYzg0NjcxZjQ2ZDZhMWNhIGFzIExheW91dCwgJGQ3ZmQ2MTAwOWMyMWQwYmIkZXhwb3J0JDdlMGVlYjlkYTcwMmEwODUgYXMgTGF5b3V0SW5mbywgJDMwNDFkYjMyOTY5NDVlNmUkZXhwb3J0JGJhZjI2MTQ2YTQxNGYyNGEgYXMgUG9pbnQsICQ2MDQyM2Y5MmM3ZjlhZDg3JGV4cG9ydCRjNzlmYzY0OTJmM2FmMTNkIGFzIFJlY3QsICRlZTFiZmE5MGE5NTdmYjhhJGV4cG9ydCRjYjZkYTg5YzZhZjFhOGVjIGFzIFNpemUsICRhZDFkOThhYThmMGMzMWI0JGV4cG9ydCQxYTUyMjM4ODdjNTYwNDQxIGFzIFJldXNhYmxlVmlldywgJGZjMGIxM2I0ODRhYzExOTQkZXhwb3J0JDE1MDVkYjgyZmUzNTdlNjUgYXMgdXNlVmlydHVhbGl6ZXJTdGF0ZX07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsZS5qcy5tYXBcclxuIl0sIm5hbWVzIjpbInVzZVN0YXRlIiwiJDhEM25yJHVzZVN0YXRlIiwidXNlTWVtbyIsIiQ4RDNuciR1c2VNZW1vIiwidXNlRWZmZWN0IiwiJDhEM25yJHVzZUVmZmVjdCIsInVzZUNhbGxiYWNrIiwiJDhEM25yJHVzZUNhbGxiYWNrIiwidXNlTGF5b3V0RWZmZWN0IiwiJDhEM25yJHVzZUxheW91dEVmZmVjdCIsIiRjNzRjZGE3ZDMxYWYxMjUzJGV4cG9ydCRjODQ2NzFmNDZkNmExY2EiLCJzaG91bGRJbnZhbGlkYXRlIiwibmV3UmVjdCIsIm9sZFJlY3QiLCJ3aWR0aCIsImhlaWdodCIsInZhbGlkYXRlIiwiaW52YWxpZGF0aW9uQ29udGV4dCIsImdldEluaXRpYWxMYXlvdXRJbmZvIiwibGF5b3V0SW5mbyIsImdldEZpbmFsTGF5b3V0SW5mbyIsIiRkN2ZkNjEwMDljMjFkMGJiJGV4cG9ydCQ3ZTBlZWI5ZGE3MDJhMDg1IiwiY29weSIsInJlcyIsInR5cGUiLCJrZXkiLCJyZWN0IiwiZXN0aW1hdGVkU2l6ZSIsIm9wYWNpdHkiLCJ0cmFuc2Zvcm0iLCJwYXJlbnRLZXkiLCJpc1N0aWNreSIsInpJbmRleCIsImFsbG93T3ZlcmZsb3ciLCJjb25zdHJ1Y3RvciIsIiQzMDQxZGIzMjk2OTQ1ZTZlJGV4cG9ydCRiYWYyNjE0NmE0MTRmMjRhIiwieCIsInkiLCJlcXVhbHMiLCJwb2ludCIsImlzT3JpZ2luIiwiJDYwNDIzZjkyYzdmOWFkODckZXhwb3J0JGM3OWZjNjQ5MmYzYWYxM2QiLCJtYXhYIiwibWF4WSIsImFyZWEiLCJ0b3BMZWZ0IiwidG9wUmlnaHQiLCJib3R0b21MZWZ0IiwiYm90dG9tUmlnaHQiLCJpbnRlcnNlY3RzIiwiY29udGFpbnNSZWN0IiwiY29udGFpbnNQb2ludCIsImdldENvcm5lckluUmVjdCIsInBvaW50RXF1YWxzIiwic2l6ZUVxdWFscyIsInNpemUiLCJ1bmlvbiIsIm90aGVyIiwiTWF0aCIsIm1pbiIsIm1heCIsImludGVyc2VjdGlvbiIsIiRlZTFiZmE5MGE5NTdmYjhhJGV4cG9ydCRjYjZkYTg5YzZhZjFhOGVjIiwiJGFkMWQ5OGFhOGYwYzMxYjQkdmFyJEtFWSIsIiRhZDFkOThhYThmMGMzMWI0JGV4cG9ydCQxYTUyMjM4ODdjNTYwNDQxIiwicHJlcGFyZUZvclJldXNlIiwiY29udGVudCIsInJlbmRlcmVkIiwidmlydHVhbGl6ZXIiLCIkM2ViMTMxZGNmMzdhZDVmOCR2YXIkcGVyZiIsIndpbmRvdyIsInBlcmZvcm1hbmNlIiwiJDNlYjEzMWRjZjM3YWQ1ZjgkdmFyJHBlcmZOb3ciLCJub3ciLCJ3ZWJraXROb3ciLCJtc05vdyIsIm1vek5vdyIsIiQzZWIxMzFkY2YzN2FkNWY4JHZhciRnZXRUaW1lIiwiYmluZCIsIkRhdGUiLCJnZXRUaW1lIiwiJDNlYjEzMWRjZjM3YWQ1ZjgkdmFyJGZpeFRzIiwiJDNlYjEzMWRjZjM3YWQ1ZjgkZXhwb3J0JGRjMGI2MzcyMDc4ODA5MGMiLCJiZWdpbiIsImVuZCIsImR1cmF0aW9uIiwiZWFzZSIsImZuIiwiY2FuY2VsZWQiLCJyYWZfaWQiLCJwcm9taXNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzdGFydCIsImRpZmZYIiwiZGlmZlkiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJydW4iLCJ0IiwiZGVsdGEiLCJwcm9jZWVkIiwiY2FuY2VsIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCIkM2ViMTMxZGNmMzdhZDVmOCRleHBvcnQkNzc4NjBjMTA2YjRhNmEyZSIsIiQzZWIxMzFkY2YzN2FkNWY4JGV4cG9ydCQ1NzYzNmJiNDNiMWNjYmIwIiwic2luIiwiUEkiLCIkZmMzNmY5YTA0NmE5Y2U3OSRleHBvcnQkMzdhMjZiMjgzZmQ3NzQwZSIsImEiLCJiIiwiU2V0Iiwia2V5cyIsImhhcyIsImFkZCIsIiRmYzM2ZjlhMDQ2YTljZTc5JGV4cG9ydCRhY2FmOTZhMjc0MzgyNDZiIiwidG9SZW1vdmUiLCJ0b0FkZCIsInRvVXBkYXRlIiwiJGZjMzZmOWEwNDZhOWNlNzkkZXhwb3J0JGNmYzE0MDg4ZGZlZmNlNWYiLCJpdGVyYXRvcnMiLCJpdGVyYXRvciIsIiRmYzM2ZjlhMDQ2YTljZTc5JGV4cG9ydCQ2ODk3YzI4NGI2ZjlmNGRjIiwib2JqZWN0IiwiJGZjMzZmOWEwNDZhOWNlNzkkZXhwb3J0JGE4ZDBkMGM4ZDFjNWRmNjQiLCIkMzY0MTkxYjNkZWNmMzY5NyR2YXIkUm9sbGluZ0F2ZXJhZ2UiLCJhZGRTYW1wbGUiLCJzYW1wbGUiLCJjb3VudCIsInZhbHVlIiwiJDM2NDE5MWIzZGVjZjM2OTckZXhwb3J0JDQ0NTVlZTZhZmIzOGRjYmIiLCJzZXRWaXNpYmxlUmVjdCIsInRpbWUiLCJzdGFydFRpbWUiLCJhdmVyYWdlVGltZSIsInZpc2libGVSZWN0IiwidmVsb2NpdHkiLCJjb2xsZWN0TWV0cmljcyIsImF2ZXJhZ2VQZXJmIiwibyIsImFicyIsIm92ZXJzY2FuWSIsIm92ZXJzY2FuWCIsImdldE92ZXJzY2FubmVkUmVjdCIsIm92ZXJzY2FubmVkIiwicm91bmQiLCIkOGUxMzVlNTMxZDhkY2I2NiRleHBvcnQkZmViYzU1NzNjNzVjZWZiMCIsImxldmVsIiwiYWN0aW9ucyIsImFuaW1hdGVkIiwiaW5pdGlhbE1hcCIsIk1hcCIsImZpbmFsTWFwIiwiaW5pdGlhbExheW91dEluZm8iLCJmaW5hbExheW91dEluZm8iLCJyZW1vdmVkIiwiJDM4Yjk0OTBjMWNjYThmYzQkZXhwb3J0JDg5YmU1YTI0M2U1OWM0YjIiLCJfc2V0Q29udGVudFNpemUiLCJfY29udGVudFNpemUiLCJkZWxlZ2F0ZSIsInNldENvbnRlbnRTaXplIiwiX3NldENvbnRlbnRPZmZzZXQiLCJvZmZzZXQiLCJfdmlzaWJsZVJlY3QiLCJjb250ZW50U2l6ZSIsIl9zZXRWaXNpYmxlUmVjdCIsImZvcmNlVXBkYXRlIiwiY3VycmVudCIsInNob3VsZE92ZXJzY2FuIiwiX292ZXJzY2FuTWFuYWdlciIsImxheW91dCIsIl9yZXNldEFuaW1hdGVkQ29udGVudE9mZnNldCIsInJlbGF5b3V0Tm93Iiwib2Zmc2V0Q2hhbmdlZCIsInNpemVDaGFuZ2VkIiwidXBkYXRlU3Vidmlld3MiLCJjb2xsZWN0aW9uIiwiX2NvbGxlY3Rpb24iLCJkYXRhIiwiX3NldERhdGEiLCJfcnVuVHJhbnNhY3Rpb24iLCJ0cmFuc2l0aW9uRHVyYXRpb24iLCJyZWxvYWREYXRhIiwicmVsYXlvdXQiLCJjb250ZW50Q2hhbmdlZCIsImdldEl0ZW0iLCJwZXJzaXN0ZWRLZXlzIiwiX3BlcnNpc3RlZEtleXMiLCJpc1BlcnNpc3RlZEtleSIsImsiLCJnZXRMYXlvdXRJbmZvIiwiX2xheW91dCIsInNldExheW91dCIsImFwcGx5TGF5b3V0IiwiX2dldFJldXNlVHlwZSIsImdldFR5cGUiLCJyZXVzZVR5cGUiLCJnZXRSZXVzYWJsZVZpZXciLCJfcmV1c2FibGVWaWV3cyIsInJldXNhYmxlIiwidmlldyIsImxlbmd0aCIsInBvcCIsInZpZXdUeXBlIiwiX2FuaW1hdGVkQ29udGVudE9mZnNldCIsIl9yZW5kZXJWaWV3IiwicmV1c2FibGVWaWV3IiwiX3JlbmRlckNvbnRlbnQiLCJjYWNoZWQiLCJfcmVuZGVyZWRDb250ZW50IiwiZ2V0IiwicmVuZGVyVmlldyIsInNldCIsInZpc2libGVWaWV3cyIsIkFycmF5IiwiZnJvbSIsIl92aXNpYmxlVmlld3MiLCJ2YWx1ZXMiLCJnZXRWaWV3IiwiZ2V0Vmlld3NPZlR5cGUiLCJmaWx0ZXIiLCJ2Iiwia2V5Rm9yVmlldyIsImtleUF0UG9pbnQiLCJsYXlvdXRJbmZvcyIsImdldFZpc2libGVMYXlvdXRJbmZvcyIsIndpbGxVbm1vdW50IiwiX3JlbGF5b3V0UmFmIiwiY29udGV4dCIsIl9zY3JvbGxBbmltYXRpb24iLCJfaW52YWxpZGF0aW9uQ29udGV4dCIsIk9iamVjdCIsImFzc2lnbiIsInNjcm9sbEFuY2hvciIsIl9nZXRTY3JvbGxBbmNob3IiLCJiZWZvcmVMYXlvdXQiLCJnZXRDb250ZW50U2l6ZSIsImFmdGVyTGF5b3V0IiwiZ2V0VmlzaWJsZVJlY3QiLCJyZXN0b3JlZFNjcm9sbEFuY2hvciIsIl9yZXN0b3JlU2Nyb2xsQW5jaG9yIiwiY29udGVudE9mZnNldFgiLCJjb250ZW50T2Zmc2V0WSIsImhhc0xheW91dFVwZGF0ZXMiLCJ0cmFuc2FjdGlvbiIsIl9hcHBseUxheW91dEluZm9zIiwiX2VuYWJsZVRyYW5zaXRpb25zIiwiZG9uZSIsIl9kaXNhYmxlVHJhbnNpdGlvbnMiLCJhZnRlckFuaW1hdGlvbiIsInNldFRpbWVvdXQiLCJfY29ycmVjdEl0ZW1PcmRlciIsIl9pc1Njcm9sbGluZyIsIl90cmFuc2FjdGlvbiIsIl92aXNpYmxlTGF5b3V0SW5mb3MiLCJfY2hpbGRyZW4iLCJkZWxldGUiLCJiZWdpbkFuaW1hdGlvbnMiLCJlbmRBbmltYXRpb25zIiwiYW5jaG9yU2Nyb2xsUG9zaXRpb24iLCJnZXRTY3JvbGxBbmNob3IiLCJjb3JuZXIiLCJhbmNob3JTY3JvbGxQb3NpdGlvbkF0VG9wIiwiY29ybmVyQW5jaG9yIiwiY29udGVudE9mZnNldCIsIl9jb250ZXh0X3RyYW5zYWN0aW9uIiwiZmluYWxBbmNob3IiLCJhZGp1c3RtZW50IiwiX2dldExheW91dEluZm9NYXAiLCJtYXAiLCJ2aXNpYmxlTGF5b3V0SW5mb3MiLCJjdXJyZW50bHlWaXNpYmxlIiwiaXRlbSIsInJldXNlVmlldyIsIl9hcHBseUxheW91dEluZm8iLCJyZW1vdmVWaWV3cyIsIl9mbHVzaFZpc2libGVWaWV3cyIsIl9oYXNMYXlvdXRVcGRhdGVzIiwiYWZ0ZXJSZW5kZXIiLCJfdHJhbnNhY3Rpb25RdWV1ZSIsIl9wcm9jZXNzVHJhbnNhY3Rpb25RdWV1ZSIsInZpZXdzQnlQYXJlbnRLZXkiLCJfdmlld19sYXlvdXRJbmZvIiwiX3ZpZXdzQnlQYXJlbnRLZXlfZ2V0IiwiX3ZpZXdfbGF5b3V0SW5mbzEiLCJfdmlld19sYXlvdXRJbmZvMiIsIl92aWV3X2xheW91dEluZm8zIiwicHVzaCIsImJ1aWxkVHJlZSIsInBhcmVudCIsInZpZXdzIiwiY2hpbGRyZW4iLCJyZW5kZXJXcmFwcGVyIiwiY2hpbGRWaWV3cyIsInNldFZpc2libGVWaWV3cyIsInVwZGF0ZWQiLCJjdXIiLCJ1cGRhdGVJdGVtU2l6ZSIsIl9zaXplVXBkYXRlUXVldWUiLCJjaGFuZ2VkIiwic3RhcnRTY3JvbGxpbmciLCJlbmRTY3JvbGxpbmciLCJzY3JvbGxUb0l0ZW0iLCJvcHRpb25zIiwic2hvdWxkU2Nyb2xsWCIsInNob3VsZFNjcm9sbFkiLCJvZmZzZXRYIiwib2Zmc2V0WSIsIm1pblgiLCJtaW5ZIiwic2Nyb2xsVG8iLCJ0aGVuIiwiY2xlYXIiLCJhY3Rpb24iLCJfc3RhcnRUcmFuc2FjdGlvbiIsIl9uZXh0VHJhbnNhY3Rpb24iLCJfZW5kVHJhbnNhY3Rpb24iLCJuZXh0Iiwic2hpZnQiLCJfcGVyZm9ybVRyYW5zYWN0aW9uIiwiX2dldENvbnRlbnRSZWN0IiwiX3NldHVwVHJhbnNhY3Rpb25BbmltYXRpb25zIiwiV2Vha01hcCIsIl9vcHRpb25zX3RyYW5zaXRpb25EdXJhdGlvbiIsIiRmYzBiMTNiNDg0YWMxMTk0JGV4cG9ydCQxNTA1ZGI4MmZlMzU3ZTY1Iiwib3B0cyIsImlzQW5pbWF0aW5nIiwic2V0QW5pbWF0aW5nIiwiaXNTY3JvbGxpbmciLCJzZXRTY3JvbGxpbmciLCJvblZpc2libGVSZWN0Q2hhbmdlIiwic3RhdGUiLCJMYXlvdXQiLCJMYXlvdXRJbmZvIiwiUG9pbnQiLCJSZWN0IiwiU2l6ZSIsIlJldXNhYmxlVmlldyIsInVzZVZpcnR1YWxpemVyU3RhdGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/virtualizer/dist/import.mjs\n");

/***/ })

};
;